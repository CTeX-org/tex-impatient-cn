% -*- coding: utf-8 -*-
% This is part of the book TeX for the Impatient.
% Copyright (C) 2003 Paul W. Abrahams, Kathryn A. Hargreaves, Karl Berry.
% See file fdl.tex for copying conditions.

\input macros
%\chapter{Concepts}
\chapter{概念}

\chapterdef{concepts}

%This part of the book contains definitions and explanations of
%the concepts that we use in describing \TeX.
%The concepts include both
%technical terms that we use in explaining the commands and
%important topics that don't fit elsewhere in the book.
本书的这部分包含了使用 \TeX\ 时所需要了解的概念。
它包括我们在解释命令时所使用的技术词汇以及重点内容，
这些内容并不适合放在本书的其它地方。

%The concepts are arranged alphabetically.
%The inside back cover of the book contains a complete list of
%concepts and the pages on which they are explained.
%We suggest that you make a copy of the inside back cover and keep it nearby
%so that you'll be able to identify and look up an unfamiliar
%concept immediately.
%As far as possible, we've kept our terminology consistent with that of
%\texbook.\idxref{\texbook}
这些概念使用英文字母顺序进行排列，
书背内页包含了一份详细的在此提及的概念列表，以及他们被提及时所在的页数。
我们建议你把书背内页复印下来，放在旁边，
这样你就能在遇到不熟悉的概念时马上查找到它们。
我们尽可能地使用和 \texbook\ 相一致的术语。\idxref{\texbook}

\beginconcepts

\bookmark{2}{以A开头}
%\conceptindex{active characters}
%\concept {active character}
\conceptindex{活动字符}
\concept {活动字符}

%An \defterm{active character} is a \refterm{character}
%that has a definition, e.g., a macro definition, associated with it.
%^^{macros//named by active characters}
%You can think of an active character as a special kind of control sequence.
%When \TeX\ encounters an active character, it
%executes the definition associated with the character.
%If \TeX\ encounters an active character that does not have
%an associated definition, it will complain about an
%undefined control sequence.
\defterm{活动字符}（active character）是一个有定义的\refterm{字符}。
比如一个活动字符可能表示着一个宏定义。
^^{宏//由活动字符命名}
你可以把活动字符理解为一种控制序列。
当 \TeX\ 碰到了一个活动字符，它就执行这个字符所表示的定义。
如果 \TeX\ 碰到的活动字符并没有表示一个定义，
则它会报错说这是一个没有定义的控制序列。

%An active character has a \refterm{category code} of $13$ (the value
%of ^|\active|).
%To define an active character, you should first
%use the ^|\catcode| command
%\ctsref{\catcode} to make it active
%and then provide the definition of the character, using
%a command such as |\def|, |\let|, or |\chardef|.
%The definition of an active character has the same form as
%the definition of a \refterm{control sequence}.
%^^{category codes//of active characters}
%If you try to define the macro for an active character
%before you make the character active, \TeX\ will complain about a
%missing control sequence.
一个活动字符的\refterm{类别码}为 $13$ (^|\active|的值)。
当你定义一个活动字符时，
你必须先使用 ^|\catcode| 命令 \ctsref{\catcode} 来使这个字符活动，
然后再使用类似 |\def|，|\let| 或者 |\chardef| 之类的命令指定这个字符的定义。
定义活动字符和定义\refterm{控制序列}所使用的方法是相同的。
^^{类别码//活动字符的类别码}
如因你尝试先对字符指定定义后把它设置成活动的，
\TeX\ 会报错说这是一个不明的控制序列。

%For example, the tilde character (|~|) is defined as an active character
%in \plainTeX.  It
%produces a space between two words but links those words so that
%\TeX\ will not turn the space into a \refterm{line break}.
%\refterm{\PlainTeX:\plainTeX} defines `|~|' by the commands:
比如，在 \PlainTeX\ 中，波浪号 (|~|) 被定义成一个活动字符。
它可以在所连接的两个单词当中产生一个空格，并且不让 \TeX\ 把这个空格转为 \refterm{断行}。
\refterm{\PlainTeX:\plainTeX} 通过以下方式来定义 `|~|'：

\csdisplay
\catcode `~ = \active \def~{\penalty10000\!visiblespace}
|
%(The |\penalty| inhibits a line break and the `|\!visiblespace|'
%inserts a space.)
（这里的 |\penalty| 可以阻止断行，`|\!visiblespace|' 可以插入一个空格。）
\endconcept


%\conceptindex{alignments}
%\concept alignment
\conceptindex{阵列}
\concept 阵列

%\bix^^{tables}
%An \defterm{alignment} is a construct for aligning material, such as a
%table, in columns or rows.  To form an alignment you need to
%(a)~describe the layout of the columns or rows and (b)~tell \TeX\ what
%material goes into the columns or rows.  A tabbing alignment or a
%horizontal alignment is organized as a sequence of rows; a vertical
%alignment is organized as a sequence of columns.  We first describe
%tabbing and horizontal alignments and then more briefly describe
%vertical alignments.
\bix^^{表格}
\defterm{阵列}（alignment）是一个把素材有序排印的结构，
就如一张有行有列的表格。当你需要构造一个阵列时，
你要 (a)~描述行和列的布局，并且 (b)~告诉 \TeX\ 各行或各列中的内容。
制表阵列和水平阵列是由一系列的行组成；竖直阵列则由一系列的列组成。
我们首先讲述制表阵列和水平阵列，然后简要地介绍一下竖直阵列。

%Tabbing alignments are defined by \plainTeX.  They are simpler but less
%flexible than horizontal alignments.  Tabbing and horizontal alignments
%differ principally in how you describe their layouts.
制表阵列是在 \PlainTeX\ 中定义的。它很简单，因此不如水平阵列那样灵活。
制表阵列和水平阵列的主要区别在于你如何定义它们的布局。

\bix^^|\settabs|
\bix\ctsidxref{+}
\bix\ctsidxref{cr}

%To construct a tabbing alignment you first issue a |\settabs| command
%\ctsref{\settabs} that specifies how \TeX\ should divide the available
%horizontal space into columns.  Then you provide a sequence of rows for
%the table.  Each row consists of a |\+| control sequence \ctsref{\@plus}
%followed by a list of ``entries'', i.e., row\slash column intersections.
%^^{entry (column or row)}
%Adjacent entries in a row are separated by an ampersand (|&|).
%\xrdef{@and}
%\ttidxref{&}
%The end of a row is indicated by ^|\cr| after its
%last entry.
%If a row has fewer entries than there are columns in the alignment,
%\TeX\ effectively fills out the row with blank entries.
要构造一个制表阵列，你首先需要用 |\settabs| 命令
\ctsref{\settabs} 确定 \TeX\ 如何将可用空白水平地分为多列。
然后你就可以逐行地填充表格的各行。
每行由控制序列|\+| \ctsref{\@plus} 及其后的一排用 |&| 隔开的“条目”组成%
^^{条目（在行或列中）}
\xrdef{@and}
\ifoldeplain\ttidxref{&}\fi
（条目是行和列的交叉部分），并以 ^|\cr| 结束。
如果某行的条目数目比该阵列的列数少，\TeX\ 就用空白条目填充它们。

%As long as it's preceded by a |\settabs| command, you can put a row of a
%tabbing alignment anywhere in your document.  In particular, you can put
%other things between the rows of a tabbing alignment or describe several
%tabbing alignments with a single |\settabs|.  Here's an example of a
%tabbing alignment:
你可以将制表阵列的行放在文档的任何地方，只要前面有 |\settabs| 命令。
特别地，你可以在制表阵列的各行之间添加其他内容，
或者用同一个  |\settabs| 描述多个制表阵列。
这里有一个制表阵列的例子：

%\xrdef{tabbedexample}\csdisplay
%{\hsize = 1.7 in \settabs 2 \columns
%\+cattle&herd\cr
%\+fish&school\cr
%\+lions&pride\cr}
%|
%The |\settabs 2 \columns| command in this example \ctsref{\settabs}
%tells \TeX\ to produce two equally wide columns.
%The line length is $1.7$ inches.
%The typeset alignment looks like this:
\xrdef{tabbedexample}\csdisplay
{\hsize = 1.7 in \settabs 2 \columns
\+cattle&herd\cr
\+fish&school\cr
\+lions&pride\cr}
|
这个例子中的 |\settabs 2 \columns| 命令\ctsref{\settabs}%
让 \TeX\ 生成总宽度为 $1.7$ 英寸的等宽两列。
所排版出的阵列如下：

%{\def\+{\tabalign}% so it isn't \outer.
%\vdisplay{%
%\hsize 1.7 in \settabs 2 \columns
%\+cattle&herd\cr
%\+fish&school\cr
%\+lions&pride\cr}
%}%
{\def\+{\tabalign}% so it isn't \outer.
\vdisplay{%
\hsize 1.7 in \settabs 2 \columns
\+cattle&herd\cr
\+fish&school\cr
\+lions&pride\cr}
}%

%\margin{Missing explanation added here.}
%There's another form of tabbing alignment in which you specify the column
%widths with a template.  The column widths in the template
%determine the column widths in the rest of the alignment:
%\csdisplay
%{\settabs\+cattle\quad&school\cr
%\+cattle&herd\cr
%\+fish&school\cr
%\+lions&pride\cr}
%|
%Here's the result:
%{\def\+{\tabalign}% so it isn't \outer.
%\vdisplay{%
%\settabs\+cattle\quad&school\cr
%\+cattle&herd\cr
%\+fish&school\cr
%\+lions&pride\cr}
%}%
\margin{Missing explanation added here.}
制表阵列还有另一种用模板指明各列宽度的用法。
模板的各列宽度决定了该阵列其后的各列宽度：
\csdisplay
{\settabs\+cattle\quad&school\cr
\+cattle&herd\cr
\+fish&school\cr
\+lions&pride\cr}
|
这是上面例子生成的结果：
{\def\+{\tabalign}% so it isn't \outer.
\vdisplay{%
\settabs\+cattle\quad&school\cr
\+cattle&herd\cr
\+fish&school\cr
\+lions&pride\cr}
}%

\eix^^|\settabs|
\eix\ifoldeplain\ctsidxref{+}\fi
\bix^^|\halign|
%Horizontal alignments are constructed with |\halign| \ctsref\halign.
%\TeX\ adjusts the column widths of a horizontal alignment according to
%what is in the columns.  When \TeX\ encounters the |\halign| command
%that begins a horizontal alignment, it first examines all the rows of
%the alignment to see how wide the entries are.  It then sets each column
%width to accommodate the widest entry in that column.
水平阵列用 |\halign| \ctsref\halign 命令构造。
\TeX\ 将根据各列内容调整水平阵列的列宽。
当 \TeX\ 碰到 |\halign| 命令要开始一个水平阵列时，
它首先检查该阵列的各行，看看各条目都有多宽。
然后设定各列宽度以容纳该列中最宽的条目。

%A horizontal alignment governed by |\halign| consists of a
%``\pix^{preamble}'' that indicates the row layout followed by the rows
%themselves.
%\ulist
%\li The preamble consists of a sequence of \pix^{template}s, one for each
%column.  The template for a column specifies how the text for that
%column should be typeset.  Each template must include a single |#|
%character
%\ttidxref{#}\xrdef{@asharp}
%to indicate where \TeX\ should substitute the text of an entry into the
%template.  The templates are separated by ampersands (|&|), \ttidxref{&}
%and the end of the preamble is indicated by |\cr|.  By providing an
%appropriate template you can obtain effects such as centering a column,
%left or right justifying a column, or setting a column in a particular
%\refterm{font}.
由 |\halign| 命令构造的水平阵列包含一个“\pix^{导言}”，
该导言说明了随后各行的布局。
\ulist
\li 导言由一系列\pix^{模板}组成，一个模板对应一列，
指明该列的文本应该如何排版。
每个模板中都必须包含一个|#|字符，
\ifoldeplain\ttidxref{#}\fi\xrdef{@asharp}
用于给出 \TeX\ 将条目的文本放入模板的位置。
各个模板之间用 |&| 分隔，\ifoldeplain\ttidxref{&}\fi 并以 |\cr| 结束该导言。
利用合适的模板你可以让某列居中，左对齐或右对齐，
或者使用某个特定的\refterm{字体}。

%\li The rows have the same form as in a tabbing alignment, except that
%you omit the |\+| at the beginning of each row.
%As before, entries are separated by |&| and the end of the row
%is indicated by |\cr|.
%\TeX\ treats each entry as a
%\refterm{group}, so any
%font-setting command or other \refterm{assignment}
%in a column template is in effect only for the entries in that column.
%\endulist
%\noindent The preamble and the rows must all be enclosed in the braces
%that follow |\halign|.  Each |\halign| alignment must include
%its own preamble.
\li 除了要省略各行开头的 |\+|，各行的写法都和制表阵列一样：
一行的各条目之间用 |&| 分隔，并以 |\cr| 结束该行。
\TeX\ 将各个条目都看作一个\refterm{编组}，
因此对某列模板的字体设定或其他\refterm{赋值}都只对该列各个条目有效。
\endulist
\noindent 导言和各行都必须放在 |\halign| 后的花括号里面。
每个 |\halign| 阵列都必须包含各自的导言。

%For example, the horizontal alignment:
%\csdisplay
%\tabskip=2pc
%\halign{\hfil#\hfil &\hfil#\hfil &\hfil#\hfil \cr
%  &&\it Table\cr
%\noalign{\kern -2pt}
%  \it Creature&\it Victual&\it Position\cr
%\noalign{\kern 2pt}
%  Alice&crumpet&left\cr
%  Dormouse&muffin&middle\cr
%  Hatter&tea&right\cr}
%|
例如，下面这个水平阵列：
\csdisplay
\tabskip=2pc
\halign{\hfil#\hfil &\hfil#\hfil &\hfil#\hfil \cr
  &&\it Table\cr
\noalign{\kern -2pt}
  \it Creature&\it Victual&\it Position\cr
\noalign{\kern 2pt}
  Alice&crumpet&left\cr
  Dormouse&muffin&middle\cr
  Hatter&tea&right\cr}
|

%\noindent produces the result:
\noindent 生成下面的结果：

%\xrdef{halignexample}
%\vdisplay{%
%\tabskip=2pc \halign{\hfil#\hfil &\hfil#\hfil &\hfil#\hfil \cr
%  &&\it Table\cr
%\noalign{\kern -2pt}
%  \it Creature&\it Victual&\it Position\cr
%\noalign{\kern 2pt}
%  Alice&crumpet&left\cr
%  Dormouse&muffin&middle\cr
%  Hatter&tea&right\cr}
%}%
%\noindent The ^|\tabskip| \ctsref{\tabskip} in this example
%tells \TeX\ to insert |2pc| of
%\refterm{glue} between the columns.
%The ^|\noalign| \ctsref{\noalign} commands tell \TeX\ to insert
%\refterm{vertical mode} material between two rows.
%In this example we've
%used |\noalign| to produce some extra space between the title rows and
%the data rows, and also to bring ``Table'' and ``Position'' closer together.
%(You can also use |\noalign| before the first row or after the
%last row.)
%\eix^^|\halign|
\xrdef{halignexample}
\vdisplay{%
\tabskip=2pc \halign{\hfil#\hfil &\hfil#\hfil &\hfil#\hfil \cr
  &&\it Table\cr
\noalign{\kern -2pt}
  \it Creature&\it Victual&\it Position\cr
\noalign{\kern 2pt}
  Alice&crumpet&left\cr
  Dormouse&muffin&middle\cr
  Hatter&tea&right\cr}
}%
\noindent 这个例子中的 ^|\tabskip| \ctsref{\tabskip}
命令让 \TeX\ 在各列间插入 |2pc| 的\refterm{粘连}。
^|\noalign| \ctsref{\noalign} 命令%
让 \TeX\ 在两行间插入\refterm{竖直模式}素材。
在此例子中我们用 |\noalign| 生成标题行和数据行之间的额外间距，
还让“Table”和“Position”紧挨在一起。%
（在首行之前或者末行之后你同样可以使用 |\noalign| 命令。）
\eix^^|\halign|

%You can construct a vertical alignment with the ^|\valign| command
%\ctsref{\valign}.  A vertical alignment is organized as a series of
%columns rather than as a series of rows.  A vertical alignment follows
%the same rules as a horizontal alignment except that the roles of rows
%and columns are interchanged.  For example, the vertical alignment:
用 ^|\valign| 命令
\ctsref{\valign}可以构造一个竖直阵列。
竖直阵列按照列而不按照行组织。
它遵循和水平阵列相同的法则，
只是此时行和列的地位交换了。
例如，下面的竖直阵列：

%\csdisplay
%{\hsize=0.6in \parindent=0pt
%\valign{#\strut&#\strut&#\strut\cr
%  one&two&three\cr
%  four&five&six\cr
%  seven&eight&nine\cr
%  ten&eleven\cr}}
%|
%\noindent yields:
%\vdisplay{%
%{\hsize=0.6in \parindent=\listleftindent % Because lists and displays
%                                         % are not indented just by \parindent.
%\valign{#\strut&#\strut&#\strut\cr
%  one&two&three\cr
%  four&five&six\cr
%  seven&eight&nine\cr
%  ten&eleven\cr}}
%}
%The ^|\strut| commands \ctsref{\strut}
%in the template are necessary to get the entries in each row
%to line up properly, i.e., to have a common \refterm{baseline},
%and to keep the distance between baselines uniform.
%\eix\ctsidxref{cr}
%\eix^^{tables}
\csdisplay
{\hsize=0.6in \parindent=0pt
\valign{#\strut&#\strut&#\strut\cr
  one&two&three\cr
  four&five&six\cr
  seven&eight&nine\cr
  ten&eleven\cr}}
|
\noindent 得到的结果为：
\vdisplay{%
{\hsize=0.6in \parindent=\listleftindent % Because lists and displays
                                         % are not indented just by \parindent.
\valign{#\strut&#\strut&#\strut\cr
  one&two&three\cr
  four&five&six\cr
  seven&eight&nine\cr
  ten&eleven\cr}}
}
模板中的 ^|\strut| 命令 \ctsref{\strut} 是必不可少的，
因为它让一行的各条目合适地排成一行，
即让它们有共同的\refterm{基线}，并让基线间的距离保持一致。
\eix\ctsidxref{cr}
\eix^^{表格}

\endconcept


\concept{\anatomy}

%\texbook\ describes the way that {\TeX} processes its input in terms of \TeX's
%``digestive tract''---its ``^{eyes}'', ``^{mouth}'',
%``^{gullet}'', ``^{stomach}'', and ``^{intestines}''.  Knowing how this
%processing works can be helpful when you're trying to understand subtle
%aspects of \TeX's behavior as it's digesting a document.
\texbook\ 将 {\TeX} 处理输入的过程用 \TeX\ 的“消化道”来描述，
包括“^{眼睛}”，“^{嘴巴}”，“^{食道}”，“^{胃}” 和“^{肠道}”。
知道这个处理过程如何运转，将有助于你理解\TeX\ 消化文档时的行为细节。

\ulist

%\li Using its ``\pix^{eyes}'', \TeX\ reads \refterm{characters:character} from
%^{input files} and passes them to its mouth.  Since an input file
%can contain ^|\input| commands \ctsref{\input},
%\TeX\ can in effect ``shift its gaze'' from one file to another.
\li 使用“\pix^{眼睛}”，\TeX\ 从^{输入文件}中读取\refterm{字符}并传给它的嘴巴。
由于输入文件中可能包含 ^|\input| 命令\ctsref{\input}，
\TeX\ 实际上能够从一个文件“转移视线”到另一个文件。

%\li Using its ``\pix^{mouth}'', {\TeX} assembles the characters into
%\refterm{tokens:token} and passes them to its gullet.
%Each token is either a \refterm{control sequence} or a single
%character.  A control sequence always starts with an \refterm{escape
%character}.  Note that spaces and ends-of-line are characters in their
%own right, although \TeX\ compresses a sequence of input spaces into a single
%space token.  See \knuth{pages~46--47} for the rules by which \TeX\ assembles
%characters into tokens.
%^^{tokens//assembled from characters}
\li 使用“\pix^{嘴巴}”，{\TeX} 将字符组合为\refterm{记号}并传给它的食道。
每个记号要么是一个\refterm{控制序列}要么是单个字符，
其中控制序列总是以\refterm{转义符}开始。
注意空格符以及行尾符自身也是字符，
只是 \TeX\ 将输入中的多个空格合并为一个空格记号。
在\knuth{第~46--47~页}
\footnote{译注：或见该书中文翻译版第35--37页。}
中介绍了 \TeX\ 将字符组合为记号的规则。
^^{记号//将字符组合为记号}

%\li Using its ``\pix^{gullet}'', {\TeX} expands any macros, conditionals, and
%^^{macros//expanded in \TeX's stomach}
%^^{tokens//passed to \TeX's stomach}
%similar constructs that it finds (see \knuth{pages~212--216}) and passes
%the resulting sequence of \refterm{tokens:token}
%to \TeX's stomach.  Expanding one token
%may yield other tokens that in turn need to be expanded.  {\TeX} carries
%out this expansion from left to right unless the order is modified by
%a command such as |\expandafter| \ctsref{\expandafter}.
%In other words, \TeX's gullet always expands the leftmost un\-ex\-panded
%token that it has not yet sent to \TeX's stomach.
\li 使用“\pix^{食道}”，{\TeX} 展开任何宏、条件句，
^^{宏//在 \TeX\ 的胃展开}
^^{记号//传给 \TeX\ 的胃}
以及它找到的类似结构（见\knuth{第~212--216~页}
\footnote{译注：或见该书中文翻译版第170--173页。}），
并将得到的一系列\refterm{记号}传给 \TeX\ 的胃。
展开一个记号也许会得到本身也需要展开的其他记号。
{\TeX} 按照从左到右的顺序执行记号展开，
除非你用类似 |\expandafter| \ctsref{\expandafter} 的命令改变其顺序。
换言之，\TeX\ 的食道总是展开未送入胃中的记号中最左边的未展开记号。

%\li Using its ``\pix^{stomach}'', {\TeX} processes the tokens in
%groups.
%Each group contains a primitive command followed by its arguments, if any.
%Most of the commands are of the ``typeset this character'' variety,
%so their groups consist of just one token.
%Obeying the instructions given by the commands,
%\TeX's stomach assembles larger and larger
%units, starting with
%characters and ending with pages,
%and passes the pages to \TeX's intestines.
%^^{pages//assembled in \TeX's stomach}
%\TeX's stomach handles the tasks of \refterm{line break}ing---%
%^^{line breaking}
%i.e., breaking each paragraph into a sequence of lines---%
%and of \refterm{page break}ing---i.e., breaking a continuous sequence of lines
%and other vertical mode material
%into pages.
\li 使用“\pix^{胃}”，{\TeX} 一组一组地处理记号。
每个分组里面包含一个原始命令及可能跟随着的命令参量。
大多数命令属于“排版此字符”这种，因此它们的分组中仅包含一个记号。
按照命令的指示，
\TeX\ 的胃从字符到页面逐步组装出越来越大的部件，
并将生成的页面传给 \TeX\ 的肠道。
^^{页面//在 \TeX\ 的胃中组装}
\TeX\ 的胃执行\refterm{断行}任务%
^^{断行}
——即将每个段落分为若干行，
以及\refterm{分页}任务%
——即将连续若干行和其他竖直模式素材分为多个页面。

%\li Using its ``\pix^{intestines}'', \TeX\ transforms the pages produced by its
%stomach into a form intended for processing
%by other programs.  It then sends the transformed output to the
%\dvifile.
%^^{\dvifile//created by \TeX's intestines}
\li 使用“\pix^{肠道}”，\TeX\ 将它的胃生成的页面转换为适合其他程序处理的形式，
并将转换出的结果送到 \dvifile 。
^^{\dvifile//由 \TeX\ 的肠道生成}

\endulist

%Most of the time you can think of the processes that take place in \TeX's
%eyes, mouth, gullet, stomach, and intestines
%as happening one after the other.  But the
%truth of the matter is that commands executed in \TeX's stomach can
%influence the earlier stages of digestion.  For instance, when \TeX's stomach
%encounters the |\input| command \ctsref{\input},
%its eyes start reading from a different
%file; when \TeX's stomach encounters a |\catcode| command
% \ctsref{\catcode} specifying a category code
%for a character $c$, the interpretation of $c$ by \TeX's mouth is affected.
%And when
%\TeX's stomach encounters a \refterm{macro} definition, the expansions carried
%out in \TeX's gullet are affected.
多数时候你都可以认为在 \TeX\ 的眼睛，嘴巴，食道，
胃和肠道中的操作是一个接一个进行的。
但事实真相是，在 \TeX\ 的胃中执行的命令可能会影响前面步骤的消化过程。
举例来说，当 \TeX\ 的胃碰到 |\input| 命令\ctsref{\input}时，
它的眼睛将开始读取另一个文件；
当 \TeX\ 的胃碰到指定字符$c$的类别码的 |\catcode| 命令\ctsref{\catcode}时，
\TeX\ 的嘴巴对 $c$ 的解释就会受影响；
而当 \TeX\ 的胃碰到\refterm{宏}定义时，
在 \TeX\ 的食道进行的宏展开也会受到影响。

%You can understand how the processes interact by imagining that each
%process eagerly gobbles up the output of its predecessor as soon as it
%becomes available.  For instance, once \TeX's stomach has seen
%the last character of the filename in an |\input| command, \TeX's gaze
%immediately shifts to the first character of the specified input file.
%\endconcept
为更好地理解各个器官的相互影响，你可以把各个器官都想象为急性子，
前任器官一有输出，后面的器官就急切地吞食该输出。
比如，\TeX\ 的胃一看到 |\input| 命令的文件名的最后一个字符，
它的眼睛就立即转移视线到所指定输入文件的第一个字符。
\endconcept

%\pagebreak
%\conceptindex{arguments}
%\concept argument
\conceptindex{参量}
\concept 参量

%^^{commands//arguments of}
%An \defterm{argument} contains text that is passed to a
%\refterm{command}.
%The arguments of a command complete the description of what
%the command is supposed to do.
%The command can either be a \refterm{primitive} command or a
%\refterm{macro}.
^^{命令//命令的参量}
命令的\defterm{参量}（argument）包含传递给\refterm{命令}的文本，
它补全了该命令正常运行所需的信息。
这里的命令可以是\refterm{原始命令}或者\refterm{宏}.

%Each primitive command ^^{primitive//command}
%has its own convention about the form of its
%arguments.  For instance, the sequence of \refterm{tokens:token}:
原始命令^^{原始的//原始命令}的参量有各自规定的形式。
例如，下面的一系列\refterm{记号}：

%\csdisplay
%\hskip 3pc plus 1em
%|
%consists of the command `|\hskip|' and the arguments
%`|3pc plus 1em|'.  But if you were to write:
\csdisplay
\hskip 3pc plus 1em
|
由 `|\hskip|' 命令及其参量 `|3pc plus 1em|' 组成。
但若你这样写：

%\csdisplay
%\count11 3pc plus 1em
%|
%you'd get an entirely different effect.
%\TeX\ would treat `|\count11|' as a command with argument `|3|',
%followed by the ordinary text tokens `|pc plus 1em|'
%(because count registers expect a number to be assigned to them)%
%---probably not what
%you intended.  The effect of the command, by the way, would be to
%assign $3$ to count register $11$ (see the discussion of ^|\count|,
%\xref\count).
\csdisplay
\count11 3pc plus 1em
|
你将得到完全不同的结果。
\TeX\ 将认为 `|\count11|' 为命令，其参量为`|3|'，
而后面的 `|pc plus 1em|' 是普通的文本记号%
（因为计数寄存器要求一个整数值作为参量）——这多半不是你想要的。
顺便说一下，该命令将给第$11$号计数寄存器赋值$3$
（见 ^|\count| 这里的讨论，\xref\count ）。

%Macros, on the other hand, all follow the same convention
%for their arguments.
%^^{macros//arguments of}
%Each argument passed to a macro
%corresponds to a \refterm{parameter}
%^^{parameters//and arguments}
%in the definition of that
%macro. ^^{macros//parameters of}
%A macro parameter is either ``delimited'' or ``undelimited''.
%The macro definition determines the number and nature of the macro parameters
%and therefore the number and nature of the macro arguments.
另一方面，所有宏都遵循相同的参量约定。
^^{宏//宏的参量}
传递给宏的每个参量都对应宏定义中的一个\refterm{参数}。
^^{参数//与参量对应}^^{宏//宏的参数}
宏的参数可以是“定界的”或是“非定界的”。
在宏的定义中确定了宏参数的个数和类型，
从而确定了宏参量的个数和类型。

%The difference between a delimited argument and an undelimited argument
%lies in the way that \TeX\ decides where the argument ends.
%^^{delimited arguments}
%^^{undelimited arguments}
%\ulist
%\li A delimited argument consists of the tokens
%from the start of the argument up to, but not including, the
%particular sequence of tokens that serves as the delimiter for that argument.
%The delimiter is specified in the macro definition.  Thus you
%supply a delimited argument to a macro by writing the argument itself
%followed by the delimiter.  A delimited argument can be empty, i.e., have
%no text at all in it.  Any braces in a delimited argument must be paired
%properly, i.e., every left brace must have a corresponding right brace
%and vice versa.
定界参量和非定界参量的区别在于，
\TeX\ 用不同方式确定该参量的结束位置。
^^{定界参量}
^^{非定界参量}
\ulist
\li 定界参量由该参量开始处和作为该参量定界子的特定记号序列之间的所有记号组成，
但不包含该定界子序列。其中的定界子是在宏的定义中规定的。
因此要给出定界参量，你需要写上该参量并在其后加上定界子。
定界参量也可以是空的，即不包含任何文本。
定界参量里面的任何花括号都必须配好对，
即每个左花括号必须有对应的右花括号，反之亦然。

%\li An undelimited argument consists of a single token or a sequence of
%tokens enclosed in braces, like this:
%`|{Here is {the} text.}|'.  Despite appearances, the outer braces don't
%form a \refterm{group}---\TeX\ uses them only to determine what the
%argument is.  Any inner braces, such as the ones around `|the|', must be
%paired properly.  If you make a mistake and put in too many right
%braces, \TeX\ will complain about an unexpected right brace.  \TeX\ will
%also complain if you put in too many left braces, but you'll probably
%get \emph{that} complaint long after the place where you intended to
%end the argument (see \xref{mismatched}).
%\endulist
%\noindent
%See \conceptcit{macro} for more information
%about parameters and arguments.  You'll find the precise rules pertaining
%to delimited and undelimited arguments in \knuth{pages~203--204}.
%\endconcept
\li 非定界参量由单个记号或者包含在花括号的一系列记号组成，
比如`|{Here is {the} text.}|'。
外面的一对花括号，虽然看起来像，实际上并不组成一个\refterm{编组}%
——\TeX\ 只是用它们确定参量的范围。
而参量内部的花括号，比如`|the|'两边的，必须正确配对。
若你误将太多右花括号放在里面，
\TeX\ 将报错说有多余的右花括号。
若左花括号太多，\TeX\ 同样会报错；
但\emph{这个错误}可能出现在该参量所期望的结束位置之后很远的地方
（见 \xref{mismatched}）。
\endulist
\noindent
请参阅\conceptcit{宏}这里的更多关于参数和参量的内容。
在\knuth{第~203--204~页}
\footnote{译注：或见该书中文翻译版第161--163页。}
你能找到定界参量和非定界参量的精确规则。
\endconcept


\concept{ASCII}

%\defterm{\ascii} is the abbreviation of ``American Standard Code for
%Information Interchange''.  There are $256$ \ascii\
%^{characters}, each with its own code number, but
%the meanings of only the first~$128$ have been standardized.  You can
%find these meanings in an \ascii\ ``code table'' such as the one on
%\knuth{page~367}.  Characters $32$--$126$ are ``printable characters'',
%^^{printable characters} such as letters, numbers, and punctuation
%marks. The remaining characters are ``^{control characters}'' that are
%typically used (in the computer industry, not in \TeX) to control
%input\slash output and data communications devices.  For instance,
%\ascii\ code $84$ corresponds to the letter `T', while \ascii\
%code~$12$ corresponds to the ``form feed'' function (interpreted by most
%printers as ``start a new page'').  Although the \ascii\ standard
%specifies meanings for the control characters, many manufacturers of
%equipment such as modems and printers have used the control characters
%for purposes other than the standard ones.
\defterm{\ascii} 是“美国信息交换标准编码”（American Standard Code for
Information Interchange）的缩写。总共有 $256$ 个 \ascii\ ^{字符}，
每个都有自己的编码，但只有前面 $128$ 个是标准编码。
在 \ascii\ “编码表”，比如\knuth{第~367~页}里面，你可以找到这些编码的含义。
编码在 $32$--$126$ 之间的字符为“可打印字符^^{可打印字符}”，
比如字母，数字和标点符号。
其余字符为“^{控制字符}”，通常用于（在计算机工业中，而不是 \TeX\ 中）
控制输入\slash 输出和数据交换设备。
比如，\ascii\ 码 $84$ 对应于字符`T'，
而 \ascii\ 码 $12$ 对应于“换页”功能（大多数打印机都将它解释为“开始新页”）。
虽然 \ascii\ 标准指定了控制字符的含义，
但很多设备，比如调制解调器和打印机，都将控制字符用于标准规定之外的目的。

%The meaning of a
%character in \TeX\ is usually consistent with its meaning in standard \ascii,
%and \refterm{fonts:font} that contain \ascii\
%printable characters usually have those characters in the same positions as
%their \ascii\ counterparts.
%But some fonts, notably those used for math, replace the \ascii\
%printable characters by other characters unrelated to the \ascii\ characters.
%For instance, the Computer Modern math font
%^^{Computer Modern fonts}
%|cmsy10| has the math symbol
%`{$\forall$}' in place of the \ascii\ digit `8'.
\TeX\ 中字符的含义通常和标准 \ascii 中的含义一致。
而且在包含 \ascii\ 可打印字符的\refterm{字体}中，
这些字符所在的位置也和 \ascii\ 中的一样。
但有些字体，特别是数学字体，
将 \ascii\ 可打印字符替换为与 \ascii\ 无关的字符。
比如，计算机现代数学字体 ^^{计算机现代字体} |cmsy10|
在 \ascii\ 数字 `8' 的位置上是数学符号 `{$\forall$}'。

\endconcept

%\conceptindex{assignments}
%\concept assignment
\conceptindex{赋值}
\concept 赋值

%An \defterm{assignment} is a construct that tells \TeX\ to assign a
%value to a register,
%^^{registers//assignment to}
%to one of its internal
%\refterm{parameters:parameter},
%^^{parameters//assignments to}
%to an entry in one of its internal tables,
%or to a \refterm{control sequence}. Some examples of assignments are:
\defterm{赋值}（assignment）是一种为 \TeX\ 的寄存器，
内部\refterm{参数}，内部表格项，或者\refterm{控制序列}分配值的结构。
^^{寄存器//给寄存器赋值}^^{参数//给参数赋值}
赋值的一些例子如下：

\csdisplay
\tolerance = 2000
\advance\count12 by 17
\lineskip = 4pt plus 2pt
\everycr = {\hskip 3pt \relax}
\catcode\`@ = 11
\let\graf = \par
\font\myfont = cmbx12
|

%The first assignment indicates that \TeX\ should assign the numeric value
%|2000| to the numeric parameter |\tolerance|, i.e., make the value of
%|\tolerance| be $2000$.  The other assignments are similar.  The `|=|'
%and the spaces are optional, so you could also write the first
%assignment more tersely as:
第一个赋值要求 \TeX\ 分配数值 |2000| 给数值参数 |\tolerance|，
即让 |\tolerance| 的值等于 $2000$。其他赋值类似。
赋值中的 `|=|' 和空格是可省略的，
因此你也可以把第一个赋值改写为下面更紧凑的形式：

\csdisplay
\tolerance2000
|

%See \knuth{pages~276--277} for the detailed syntax of assignments.
%\endconcept
在 \knuth{第~276--277~页}中对赋值语法有详细介绍。
\endconcept


\bookmark{2}{以B开头}
%\concept badness
\concept 劣度

%The \defterm{badness} of a line is a measure of how far the interword
%spaces ^^{interword spacing}
%in the line deviate from their natural values,
%i.e., the values specified in the \refterm{fonts:font} used in the line.
%The greater the
%deviation, the greater the badness.  Similarly, the badness of a page is
%a measure of how far the spaces between the boxes that
%make up the page deviate from their ideal values.  (Ordinarily, most of these
%boxes are single lines of paragraphs.)
文本行的\defterm{劣度}（badness）值测量该行的字间隔偏离它们的自然值多远，
^^{单词间距}
其中自然值就是文本行所用\refterm{字体}中指定的值。
偏离越大，劣度就越大。类似地，页面的劣度测量页面盒子的间隔偏离它们的理想值多远。%
（一般地，这些盒子大多数是段落的文本行。）

%More precisely, the badness
%is a measure of how much the \refterm{glue} associated with these spaces needs
%to stretch or shrink to fill the line or page exactly.
%\TeX\ computes the badness as approximately $100$
%times the cube of the ratio by which it must stretch or shrink the glue
%in order to compose a line or a page of the required size.
%^^{line breaks//badness for}^^{page breaks//badness for}
%For example, stretching the glue by twice its stated stretch yields a ratio of
%$2$ and a badness of $800$; stretching it by half its stated stretch yields
%a ratio of $.5$ and a badness of $13$.
%\TeX\ treats a badness greater than $10000$ as
%equal to $10000$.
更准确地说，劣度测量这些间隔对应的\refterm{粘连}要伸缩多少才能正好填满文本行或页面。
\TeX\ 让劣度近似等于，为组成所需尺寸的行或页，粘连必须伸缩的比例的立方的 $100$ 倍。
^^{断行//断行的劣度}^^{分页//分页的劣度}
例如，粘连伸长了给定伸长量的两倍得到的比例为 $2$ 而劣度为 $800$；
粘连伸长了给定伸长量的一半得到的比例为 $.5$ 而劣度为 $13$。
\TeX\ 将超过 $10000$ 的劣度视为等于 $10000$。

%\TeX\ uses the badness of a line when it's breaking a paragraph into lines
%\seeconcept{line break}.  It uses this information in two stages:
\TeX\ 分段为行时使用行劣度\seeconcept{断行点}。
它在下面两个步骤中使用行劣度：

%\olist
%\li When \TeX\ is choosing line breaks,
%it will eventually accept lines whose badness is less than or equal to
%the value of |\tolerance| (\xref \tolerance).  If \TeX\ cannot avoid setting
%a line whose badness exceeds this
%value, it will set it as an underfull or overfull \refterm{hbox}.
%\TeX\ will set
%an overfull or underfull hbox only as a last resort, i.e., only if there's no
%other way to break the paragraph into lines.
%\li Assuming that all lines are tolerably bad, \TeX\ uses the badness of lines
%in order to evaluate the different ways of breaking the paragraph into lines.
%During this evaluation it associates ``demerits'' with each potential line.
%The badness increases the number of \refterm{demerits}.
%\TeX\ then
%breaks the paragraph into lines in a way that minimizes the
%total demerits for the paragraph.
%Most
%often \TeX\ arranges the paragraph in a way that minimizes the badness of the
%worst line.  See \knuth{pages~97--98} for the details of how \TeX\
%breaks a paragraph into lines.
%\endolist
\olist
\li 在选择断行点时，\TeX\ 要求各行劣度小于或等于 |\tolerance| 值（\xref \tolerance ）。
如果不得不放置一个劣度超过此值的行，\TeX\ 将把它设定为未满或过满\refterm{水平盒子}。
\TeX\ 仅在万不得已时才会放置未满或过满水平盒子，即仅在没有其他方法分段为行时。
\li 假设各行都相当糟糕，\TeX\ 用行劣度评价不同的分段为行方式。
在评价过程中它对每个可能的行结合一个``缺陷''。劣度会增加\refterm{缺陷}值。
然后 \TeX\ 选择让段落总缺陷最小的方式来分段为行。
在多数情况下，\TeX\ 使用让最糟糕行的劣度最小的方式安排段落。
请参阅\knuth{第~97--98~页}中 \TeX\ 如何分段为行的细节。
\endolist

%\TeX's procedure for assembling a sequence of lines and other vertical
%mode material into pages is similar to its procedure for line breaking.
%However, assembling pages is
%not as complicated because \TeX\ only considers one page at a time
%when it looks for page breaks.
%Thus the only decision it must make is where to end the current page.
%In contrast, when \TeX\ is choosing line breaks it
%considers several of them simultaneously.
%(Most word processors choose line breaks one at a time,
%and thus don't do as good a job at it as \TeX\ does.)
%See \knuth{pages~111--113} for the details of how \TeX\ chooses its
%page breaks.
%\endconcept
\TeX 将一系列文本行和其他竖直模式素材组装为页面的过程与断行的过程类似。
但是组装页面没那么复杂，这是由于 \TeX\ 寻找分页点时每次只考虑一个页面，
因此只需要决定在哪里结束当前页面。
与此相反，当选择断行点时 \TeX\ 要同时考虑多行。%
（大多数文字处理器每次只选择一个断行点，因而断行做得不如 \TeX\ 。）%
请参阅\knuth{第~111--113~页}
\footnote{译注：或见该书中文翻译版第85--87页。}
中 \TeX\ 如何选择分页点的细节。
\endconcept


%\conceptindex{baselines}
%\concept baseline
\concept 基线

%The \defterm{baseline} of a \refterm{box} is an imaginary line that runs
%across the box.
%^^{boxes//baselines of}
%When \TeX\ is
%assembling the boxes of a \refterm{horizontal list} into a larger box,
%it lines up the boxes in the list so that their baselines coincide.
%As an analogy, think of writing on a pad of ruled paper.  Each letter
%that you write has
%an implicit baseline.
%In order to line up the letters horizontally,
%you place them on the pad so that their baselines
%agree with the light guidelines that are printed on the pad.
盒子的\defterm{基线}（baseline）是一条想象中的横穿盒子的线。
^^{盒子//盒子的基线}
在将\refterm{水平列表}的盒子组装为更大的盒子时，
\TeX\ 将列表中各盒子对齐，以让它们的基线重合。
打个比方，想象你在标线本上写字，你所写的每个字母都有一条隐含基线。
为让各字母水平对齐，你会让它们的基线和本子上印刷的浅色提示线重合。

%A box can and often does extend below its baseline.
%For instance, the letter `g' extends below the baseline of its box because
%it has a descender (the bottom loop of the `g').
%\endconcept
盒子可以而且也经常会延伸到基线下边。
比如，字母 `g' 就延伸到其盒子的基线下边，因为它有一个降部（`g' 底部弯曲部分）。
\endconcept


%\conceptindex{boxes}
%\concept box
\concept 盒子

%A \defterm{box}  is a rectangle of material to be typeset.  A single
%\refterm{character} is a box by itself,
%and an entire page is also a box.
%\TeX\ forms a page as a nest of boxes within boxes within boxes. The
%outermost box is the page itself, the innermost boxes are mostly
%single characters, and single lines are boxes that are
%somewhere in the middle.
\defterm{盒子}（box）是要排版的矩阵素材。
单个\refterm{字符}自身就是一个盒子，整个页面同样也是一个盒子。
\TeX\ 用盒子套盒子套盒子以形成页面。最外层盒子就是页面自身，
最内层盒子多半是单个字符，而单个文本行的盒子在中间某个地方。

%\TeX\ carries out most of its box-building activities implicitly as it
%constructs paragraphs and pages.
%You can construct boxes explicitly
%using a number of \TeX\ \refterm{commands}, notably
%^|\hbox| \ctsref{\hbox},
%^|\vbox| \ctsref{\vbox}, and
%^|\vtop| \ctsref{\vtop}.
%The ^|\hbox| command
%constructs a box by appending smaller boxes horizontally from left to right;
%it operates on a \refterm{horizontal list} and yields
%an \refterm{hbox} ^^{hboxes} (horizontal box).
%^^{horizontal lists}
%The ^|\vbox| and |\vtop| commands
%construct a box by appending smaller boxes vertically from top to bottom;
%^^{vboxes}
%they operate on a \refterm{vertical list}
%and yield a \refterm{vbox} ^^{vboxes} (vertical box).
%^^{vertical lists}
%These horizontal and vertical lists can include not just smaller boxes but
%several other kinds of entities as well, e.g.,  \refterm{glue} and
%kerns.
%^^{kerns//as list items}
\TeX\ 在构造段落和页面时隐式执行大多数盒子构建活动。
利用一些 \TeX\ \refterm{命令}，比如 ^|\hbox|\ctsref{\hbox}、
^|\vbox|\ctsref{\vbox}和 ^|\vtop|\ctsref{\vtop}，你可以显式构造盒子。
^|\hbox| 命令通过从左到右水平添加较小的盒子构造一个盒子；
它对一个\refterm{水平列表}进行操作以生成一个\refterm{水平盒子}^^{水平盒子}（horizontal box）。
^^{水平列表}
^|\vbox| 和 |\vtop| 命令通过从上到下竖直添加较小的盒子构造一个盒子；
它们对一个\refterm{竖直列表}进行操作以生成一个\refterm{竖直盒子}^^{竖直盒子}（vertical box）。
^^{竖直列表}
这些水平列表和竖直列表不仅可以包含较小的盒子，
还可以包含其他几种实体，比如\refterm{粘连}和紧排。
^^{紧排//作为列表项目}

%A box has \refterm{height}, \refterm{depth}, and \refterm{width},
%^^{height} ^^{depth} ^^{width}
%like this:
%\vdisplay{\offinterlineskip\sevenrm
%   \halign{#&#&\kern3pt \hfil#\hfil\cr
%      &\hrulefill\cr
%      &\vrule
%         \vtop to .7in{\vss \hbox to .9in{\hss baseline\hss}\vskip4pt}%
%       \vrule
%      &\labelledheight{.7in}{height}\cr
%      %
%       \vbox to 0pt{
%          \vss
%          \hbox{reference point \hbox to 15pt{\rightarrowfill}%
%          \hskip3pt}%
%       \kern-4.5pt}&{\box\refpoint}\hrulefill\cr
%      %
%      \omit
%      &\vrule\hfil\vrule
%      &\labelledheight{.4in}{depth}\cr
%      %
%      &\hrulefill\cr
%      %
%   \noalign{\vskip3pt}%
%      &\leftarrowfill { width }\rightarrowfill\cr
%}}
盒子有\refterm{高度}、\refterm{深度}和\refterm{宽度}，
^^{高度} ^^{深度} ^^{宽度}
如下所示
\vdisplay{\offinterlineskip\sevenrm
   \halign{#&#&\kern3pt \hfil#\hfil\cr
      &\hrulefill\cr
      &\vrule
         \vtop to .7in{\vss \hbox to .9in{\hss baseline\hss}\vskip4pt}%
       \vrule
      &\labelledheight{.7in}{height}\cr
      %
       \vbox to 0pt{
          \vss
          \hbox{reference point \hbox to 15pt{\rightarrowfill}%
          \hskip3pt}%
       \kern-4.5pt}&{\box\refpoint}\hrulefill\cr
      %
      \omit
      &\vrule\hfil\vrule
      &\labelledheight{.4in}{depth}\cr
      %
      &\hrulefill\cr
      %
   \noalign{\vskip3pt}%
      &\leftarrowfill { width }\rightarrowfill\cr
}}

%^^{baselines}
%The \refterm{baseline} is like one of
%the light guidelines on a pad of ruled paper.
%The boxes for letters such as `g'
%extend below the baseline; the boxes for letters such as `h' don't.
%The height of a box is the distance that the box extends above its
%baseline, while its depth is the distance that it extends below its
%baseline. \bix^^{reference point}
%The \minref{reference point}
%of a box is the place where its baseline intersects its left edge.
^^{基线}
\refterm{基线}（baseline）如同标线本上的浅色提示线。
像 `g' 这样的字母盒子延伸到基线下边；而像 `h' 这样的字母盒子却不会。
盒子的高度是盒子在基线上边的延伸距离，而它的深度是在基线下边的延伸距离。
\bix^^{基准点}
盒子的\minref{基准点}（reference point）是它的基线与左边缘的交点。

%{\tighten
%\TeX\ builds an hbox $H$ from a horizontal list by assuming
%a reference point for $H$ and then appending the items in the list to $H$
%one by one from left to right.
%Each box in the list is placed so that its baseline coincides with the
%baseline of $H$\kern-2pt,
%i.e., the component boxes are lined up horizontally.%
%\footnote{If a box is moved up or down with ^|\raise| or
%^|\lower|, \TeX\ uses its reference point before the move when
%placing it.}
%The height of $H$ is the
%height of the tallest box in the list, and the depth of $H$ is the depth
%of the deepest box in the list.
%The width of $H$ is the sum of the
%widths of all the items in the list.
%If any of these items are \refterm{glue} and \TeX\ needs to stretch or shrink
%the glue,
%the width of $H$ will be larger or smaller accordingly.
%See \knuth{page~77} for the~details.
%\par}
在从水平列表构建水平盒子 $H$ 时，\TeX\ 先设定 $H$ 的基准点，
然后从左到右逐个添加列表中的项目到 $H$ 中。
列表中的每个盒子按照其基线与 $H$ 的基线重合的方式放置，
即让组成盒子水平排成一排。%
\footnote{若盒子被 ^|\raise| 或 ^|\lower| 升高或降低了，
\TeX\ 放置时使用它移动之前的基准点。}
$H$ 的高度等于列表中最高盒子的高度，而深度等于列表中最深盒子的深度。
$H$ 的宽度等于列表中所有项目的宽度之和。
如果这些项目中有的是\refterm{粘连}，\TeX\ 需要伸缩粘连，
从而 $H$ 的宽度将相应地变大或变小。请参阅\knuth{第~77~页}
\footnote{译注：或见该书中文翻译版第57页。}
的细节描述。

%Similarly, \TeX\ builds a vbox $V$ from a vertical list by assuming a
%temporary reference point for $V$ and then appending the items in the
%list to $V$ one by one from top to bottom.  Each box in the list is
%placed so that its reference point is lined up vertically with the
%reference point of \Vperiod.\footnote{If a box is moved left or right with
%^|\moveleft| or ^|\moveright|, \TeX\ uses its reference point before the
%move when placing it.} As each box other than the first one is added to
%\Vcomma, \TeX\ puts \minref{interline glue} just above it.  (This
%^{interline glue} has no analogue for hboxes.)  The width of $V$ is the
%width of the widest box in the list, and the vertical extent (height
%plus depth) of $V$ is the sum of the vertical extents of all the
%items in the list.
类似地，在从竖直列表构建竖直盒子 $V$ 时，\TeX\ 先设定 $H$ 的临时基准点，
然后从上到下逐个添加列表中的项目到 $V$ 中。
列表中的每个盒子按照其基准点与 $V$ 的基准点竖直对齐的方式放置。%
\footnote{如果盒子被 ^|\moveleft| 或 ^|\moveright| 左移或右移了，
\TeX\ 放置时使用它移动之前的基准点。}
在第一个除外的每个盒子加到 $V$ 时，\TeX\ 在它之前放置\minref{行间粘连}。%
（在水平盒子中没有和^{行间粘连}对应的东西。）%
$V$ 的宽度等于列表中最宽盒子的宽度，
而 $V$ 的竖直长度（高度加深度）等于列表中所有项目的竖直长度之和。

%\bix^^|\vbox|
%\bix^^|\vtop|
%The difference between |\vbox| and |\vtop| is in how they partition
%the vertical extent of $V$ into a height and a depth.
%Choosing the reference point of $V$ determines that partition.
%\ulist
%\li For |\vbox|, \TeX\ places the reference point on a horizontal line
%with the reference point of the last component box
%or rule of \Vcomma, except
%that if the last box (or rule) is followed by glue or a kern, \TeX\ places the
%reference point at the very bottom of \Vperiod.%
%\footnote{The depth is limited by
%the parameter ^|\boxmaxdepth| \ctsref{\boxmaxdepth}.}
\bix^^|\vbox|
\bix^^|\vtop|
|\vbox| 和 |\vtop| 的区别在于它们如何将 $V$ 的竖直长度划分为高度和深度。
选定了 $V$ 的基准点就决定了划分方式。
\ulist
\li 对于 |\vbox|，\TeX\ 将基准点放在 $V$ 的最后一个组成盒子或标线的基准点所在的水平线上，
除非最后一个盒子（或标线）之后还有粘连或紧排，此时 \TeX\ 将基准点放在 $V$ 的最底端。
\footnote{深度还受 ^|\boxmaxdepth| 参数\ctsref{\boxmaxdepth}限制。}

%\li For |\vtop|, \TeX\ places the reference point on a horizontal line
%with the reference point of the first component box or rule of \Vcomma,
%except that if the first box (or rule)
%is preceded by glue or a kern, \TeX\ places
%the reference point at the very top of \Vperiod.
\li 对于 |\vtop|，\TeX\ 将基准点放在 $V$ 的第一个组成盒子或标线的基准点所在的水平线上，
除非第一个盒子（或标线）之前还有粘连或紧排，此时 \TeX\ 将基准点放在 $V$ 的最顶端。

%\endulist
%\noindent
%Roughly speaking, then, |\vbox| puts the reference point near the bottom
%of the vbox and |\vtop| puts it near the top.
%When you want to align a
%row of vboxes so that their tops line up horizontally,
%you should usually use |\vtop| rather than |\vbox|.
%See \knuth{pages~78 and 80--81} for the
%details of how \TeX\ builds vboxes.
%\eix^^|\vbox|
%\eix^^|\vtop|
%\eix^^{reference point}
\endulist
\noindent
粗略地说，|\vbox| 将基准点放在靠近竖直盒子底部处，而|\vtop| 将基准点放在靠近顶部处。
在你想对齐一行竖直盒子，让它们的顶部水平排成一排时，你通常应该使用 |\vtop| 而不是 |\vbox|。
请参阅\knuth{第~78 和 80--81~页}
\footnote{译注：或见该书中文翻译版第58和60--61页。}
中 \TeX\ 如何构建竖直盒子的详细信息。
\eix^^|\vbox|
\eix^^|\vtop|
\eix^^{基准点}

%You have quite a lot of freedom in constructing boxes.  The typeset
%material in a box can extend beyond the boundaries of the box as it does
%for some letters (mostly italic or slanted ones).  The component boxes
%of a larger box can overlap.  A box can have negative width, depth, or
%height, though boxes like that are not often needed.
在构造盒子时你有极大的自由度。盒子中排版的素材可以超出盒子的边界，
就像某些字母那样（多半是那些意大利体或斜体字母）。
大盒子的组成盒子可以相互重叠。
盒子可以有负的宽度、深度或高度，尽管这种盒子不常用到。

%You can save a box in a box \refterm{register} and retrieve it later.
%Before using a box register,
%^^{box registers}
%you should reserve it and give it a name
%with the ^|\newbox| command \ctsref{\@newbox}.  See
%\conceptcit{register} for more information about box
%registers.
%\endconcept
你可以把一个盒子保存在盒子\refterm{寄存器}中并在稍后取回它。
在使用盒子寄存器之前，
^^{盒子寄存器}
你应当用 ^|\newbox| 命令\ctsref{\@newbox}预留它并给它命名。
请参阅\conceptcit{寄存器}中的关于盒子寄存器的更多信息。
\endconcept

\bookmark{2}{以C开头}
%\conceptindex{category codes}
%\concept {category code}
\conceptindex{类别码}
\concept {类别码}

%The \defterm{category code} of a \refterm{character} determines that
%character's role in \TeX.
%^^{characters//category code of}
%For instance, \TeX\ assigns a certain role to
%letters, another to space characters, and so forth.  \TeX\ attaches a
%code to each character that it reads.  When \TeX\ reads the
%letter `|r|', for example, it ordinarily
%attaches the category code $11$ (letter)
%to it. For simple \TeX\ applications you won't need to worry about
%category codes, but they become important when you are trying to achieve
%special effects.
字符的\defterm{类别码}（category code）决定它在 \TeX\ 中扮演的角色。
^^{字符//字符的类别码}
例如，\TeX\ 赋予某个角色给字母，另一个角色给空格符，诸如此类。
\TeX\ 给读到的每个字符都附加一个代码。
例如，\TeX\ 读到字母 `|r|' 时附加类别码 $11$（字母符）给它。
在简单地使用 \TeX\ 时你无需考虑到类别码，
但当你试图达到特别效果时它们就变得很重要。

%Category codes apply only to characters that \TeX\ reads from input
%files.  Once a character has gotten past \TeX's ^{gullet}
%\seeconcept{\anatomy} and been interpreted, its category code no
%longer matters.  A character that you produce with the ^|\char| command
%\ctsref{\char} does not have a category code because |\char|
%is an instruction to \TeX\ to produce a certain character in a certain
%\refterm{font}.  For instance, the ^{\ascii} code for `|\|'
%(the usual escape character) is $92$.  If
%you type `|\char92 grok|', it is \emph{not} equivalent to |\grok|.
%Instead it tells \TeX\ to
%typeset `$c$grok', where $c$ is the character in position $92$
%of the code table for the current font.
类别码只附加到 \TeX\ 从输入文件中读取的字符中。
只要字符到达 \TeX\ 的^{食道}\seeconcept{\anatomy}并被解释完，它的类别码就不再改变。
用 ^|\char| 命令\ctsref{\char}生成的字符没有类别码，
因为 |\char| 命令是一个让 \TeX\ 生成特定\refterm{字体}中的某个特定字符的指令。
例如，`|\|'（通常的转义字符）的^{\ascii} 码是 $92$。
如果你键入 `|\char92 grok|'，却\emph{并不}等同于 |\grok|。
实际上它让 \TeX\ 排版出 `$c$grok'，其中 $c$ 是当前字体的编码表中位置为 $92$ 的字符。

%You can use the ^|\catcode| command \ctsref{\catcode} to reassign the
%category code of any character.  By changing category codes you can
%change the roles of various characters.  For instance, if you type
%`|\catcode`\@ = 11|', the category code of the at sign (|@|) will be set
%to ``letter''.  You then can use `|@|' in the name of a control
%sequence.
你可以用 ^|\catcode| 命令\ctsref{\catcode}重新设定任何字符的类别码。
改变了类别码就改变了各种字符所扮演的角色。
例如，如果你键入 `|\catcode`\@ = 11|'，|@| 符号的类别码就被设定为“字母符”。
这样你就可以在控制序列名称中使用 `|@|' 。

%Here is a list of the category codes as they're defined in
%\refterm{\plainTeX} (see \xref{twocarets} for an explanation of
%the |^^| notation),
%together with the characters in each category:
这里给出\refterm{\plainTeX} 定义的类别码列表，以及每个类别中的字符（\xref{twocarets}有|^^|记法的解释）：

%\xrdef{catcodes}
%\vskip\abovedisplayskip
%%k \vskip 0pt plus 2pt % to fix bad page break
%{%k \interlinepenalty = 10000
%\halign{\indent\hfil\strut#&\qquad#\hfil\cr
%\it Code&\it Meaning\cr
%\noalign{\vskip\tinyskipamount}
%0&Escape character \quad |\| ^^{escape character//category code of}
%   {\recat!ttidxref[\//category code of]]
%   \cr
%1&Beginning of group \quad |{| ^^{groups}
%   {\recat!ttidxref[{//category code of]]
%   \cr
%2&End of group   \quad |}|
%   {\recat!ttidxref[}//category code of]]
%   \cr
%3&Math shift   \quad |$| ^^{math shift}
%   {\recat!ttidxref[$//category code of]]
%   \cr
%4&Alignment tab   \quad |&| ^^{tabs} ^^{alignments//tab character for}
%   \ttidxref{&//category code of} \cr
%5&End of line   \quad |^^M| \tequiv \ascii\ \asciichar{return}
%   ^^{end of line} \ttidxref{^^M//category code of}\cr
%6&Macro parameter   \quad |#|
%   ^^{macros//parameters of}
%   ^^{parameters//indicated by \b\tt\#\e}
%   \ttidxref{#//category code of} \cr
%7&Superscript   \quad |^| and |^^K| ^^{superscripts}
%   \ttidxref{^^K}
%   \ttidxref{^//category code of} \cr
%8&Subscript   \quad |_| and |^^A| ^^{subscripts}
%   \ttidxref{^^A}
%   \ttidxref{_//category code of} \cr
%9&Ignored character  \quad |^^@| \tequiv \ascii\ \asciichar{null}
%  ^^{ignored characters} \indexchar ^^@ \cr
%10&Space  \quad \visiblespace\ and |^^I| \tequiv \ascii\
%  \asciichar{horizontal\ tab}
%  ^^{horizontal tab}
%  ^^{space characters//category code of} \indexchar ^^I
%  {\recat!ttidxref[ ]]
%  \cr
%11&Letter  \quad |A| \dots |Z| and |a| \dots |z| ^^{letter}\cr
%12&Other character \quad (everything not listed above or below)
%  ^^{other characters}\cr
%13&Active character  \quad |~| and |^^L| \tequiv\ascii\ \asciichar{form\ feed}
%   ^^{active characters} ^^{form feed} \indexchar ~ \indexchar ^^L \cr
%14&Comment character  \quad |%| ^^{comments}
%   {\recat!ttidxref[%//category code of]]
%   \cr
%15&Invalid character  \quad |^^?| \tequiv \ascii\ \asciichar{delete}
%  ^^{invalid character} \indexchar ^^? \cr
%}}
%\vskip\belowdisplayskip
%%k \vskip 0pt plus 2pt % to fix bad page break
\xrdef{catcodes}
\vskip\abovedisplayskip
%k \vskip 0pt plus 2pt % to fix bad page break
{%k \interlinepenalty = 10000
\halign{\indent\hfil\strut#&\qquad#\hfil&\qquad#\hfil\cr
\it 编码&\it 意义&\it 字符\cr
\noalign{\vskip\tinyskipamount}
0&转义符    & |\| ^^{转义符//转义符的类别码}
   %{\recat!ttidxref[\//其类别码]]
   \cr
1&编组开始符& |{| ^^{编组}
   %{\recat!ttidxref[{//其类别码]]
   \cr
2&编组结束符& |}|
   %{\recat!ttidxref[}//其类别码]]
   \cr
3&数学环境符& |$| ^^{数学开关}
   %{\recat!ttidxref[$//其类别码]]
   \cr
4&阵列制表符& |&| ^^{制表} ^^{阵列//阵列的制表符}
   \ifoldeplain\ttidxref{&//其类别码}\fi \cr
5&行结束符  & |^^M| \tequiv \ascii\ \asciichar{return}
   ^^{行结束符} \ifoldeplain\ttidxref{^^M//其类别码}\fi\cr
6&宏参数符  & |#|
   ^^{宏//宏的参数}
   ^^{参数//用 \b\tt\#\e 指明}
   \ifoldeplain\ttidxref{#//其类别码}\fi \cr
7&上标符    & |^| 和 |^^K| ^^{上标}
   \ttidxref{^^K}
   \ifoldeplain\ttidxref{^//其类别码}\fi \cr
8&下标符    & |_| 和 |^^A| ^^{下标}
   \ttidxref{^^A}
   \ifoldeplain\ttidxref{_//其类别码}\fi \cr
9&可忽略符  & |^^@| \tequiv \ascii\ \asciichar{null}
  ^^{可忽略符} \indexchar ^^@ \cr
10&空格符   & \visiblespace\ 和 |^^I| \tequiv \ascii\
  \asciichar{horizontal\ tab}
  ^^{水平制表符}
  ^^{空格符//其类别码} \indexchar ^^I
  %{\recat!ttidxref[ ]]
  \cr
11&字母符   & |A| \dots |Z| 和 |a| \dots |z| ^^{字母}\cr
12&其他字符 &（不属于其他类别的字符）
  ^^{其他字符}\cr
13&活动字符 & |~| 和 |^^L| \tequiv\ascii\ \asciichar{form\ feed}
   ^^{活动字符} ^^{换页符} \indexchar ~ \indexchar ^^L \cr
14&注释符   & |%| ^^{注释}
   %{\recat!ttidxref[%//其类别码]]
   \cr
15&无效字符 & |^^?| \tequiv \ascii\ \asciichar{delete}
  ^^{无效字符} \indexchar ^^? \cr
}}
\vskip\belowdisplayskip
%k \vskip 0pt plus 2pt % to fix bad page break

%\noindent Except for categories $11$--$13$,
%all the characters in a particular category produce the same effect.
%\margin{Misleading material removed.}
%For instance, suppose
%that you type:
%\csdisplay
%\catcode`\[ = 1 \catcode`\] = 2
%|
%Then the left and right bracket characters become
%beginning-of-group and end-of-group characters equivalent to
%the left and right brace characters.  With these definitions `|[a b]|'
%is a valid group, and so are \hbox{`|[a b}|'} and~\hbox{`|{a b]|'}.
\noindent 除了第 $11$--$13$ 类别，一个类别中的所有字符产生的效果都相同。
\margin{Misleading material removed.}
例如，假设你键入：
\csdisplay
\catcode`\[ = 1 \catcode`\] = 2
|
则左方括号和右方括号分别就变成编组开始符和编组结束符，即它们分别和左花括号和右花括号等价。
在这些定义之下，`|[a b]|' 是一个有效的编组，\hbox{`|[a b}|'} 和 \hbox{`|{a b]|'} 同样也是。

%The characters in categories $11$ (letter) and $12$
%(other character) act as \refterm{commands:command}
%that mean
%``produce a \refterm{box} containing this character
%typeset in the current font''.
%The only distinction between letters and ``other'' characters is
%that letters can appear in \refterm{control word}s but
%``other'' characters~can't.
类别为 $11$（字母符）或 $12$（其他字符）的字符成为一个\refterm{命令}，
它表示“用当前字体排版这个字符并放在一个\refterm{盒子}中”。
字母符和“其他字符”的惟一区别是，字母符可以出现在\refterm{控制词}中而“其他字符”不能。

%A character in category $13$ (active) acts like a control sequence
%all by itself.  \TeX\ complains if it encounters an active character that
%doesn't have a definition associated with it.
%^^{active characters}
类别为 $13$（活动字符）的字符单独作为控制序列。
如果 \TeX\ 碰到一个未定义的活动字符，它将会报错。
^^{活动字符}

%If \TeX\ encounters an ^{invalid character} (category $15$)
%in your input, it will complain about it.
如果 \TeX\ 在输入中碰到一个^{无效字符}（类别为$15$），它也会报错。

%The `|^^K|' and `|^^A|' characters have been included in categories
%$8$ (subscript) and $9$ (superscript), even though these meanings
%don't follow the standard \refterm{\ascii} interpretation.
%That's because some keyboards, notably some at Stanford
%University where \TeX\ originated,
%have down arrow and up arrow keys that generate these characters.
%\ttidxref{^^A}
%\ttidxref{^^K}
字符 `|^^K|' 和 `|^^A|' 被包含在类别$7$（上标符）和 $8$（下标符）中，
即使它们的意义并不符合标准\refterm{\ascii} 中的解释。
这是因为某些键盘，尤其是 \TeX\ 起源地哈佛大学的键盘，用上方向键和下方向键生成这两个字符。
\ttidxref{^^A}
\ttidxref{^^K}

%There's a subtle point about the way \TeX\ assigns category codes that
%can trip you up if you're not aware of it.  \TeX\ sometimes needs to
%look at a character twice as it does its initial scan: first to find the
%end of some preceding construct, e.g., a control sequence, and later to
%turn that character into a token.  \TeX\ doesn't assign the category
%code until its \emph{second} look at the character.  For example:
在 \TeX\ 分配类别码的方式中有个细微之处，如果没注意到它你就会犯错误。
\TeX\ 在初步扫描时有时候需要查看一个字符两次：
第一次找到前面的控制序列等结构的结束位置，第二次才将该字符转换为记号。
\TeX\ 在\emph{第二次}查看该字符时才会给它分配类别码。例如：

%\csdisplay
%\def\foo{\catcode`\$ = 11 }% Make $ be a letter.
%\foo$ % Produces a `$'.
%\foo$ % Undefined control sequence `foo$'.
%|
%\noindent
%This bit of \TeX\ code produces `\$' in the typeset output.  When
%\TeX\ first sees the `|$|' on the second line,
%it's looking for the end of a control sequence name.  Since
%the `|$|' isn't yet a letter, it marks the end of `|\foo|'.  Next,
%\TeX\ expands the `|\foo|' macro and changes the category code of `|$|'
%to $11$ (letter).  Then \TeX\ reads the `|$|' ``for real''.  Since
%`|$|' is now a letter, \TeX\ produces a box
%containing the `|$|' character in the current font.
%When \TeX\ sees the third line, it treats `|$|' as a letter and thus
%considers it to be part of the control sequence name.
%As a result it complains about an undefined control sequence |\foo$|.
\csdisplay
\def\foo{\catcode`\$ = 11 } % 将 $ 变成字母符。
\foo$ % 生成一个 `$'。
\foo$ % 未定义的控制序列 `foo$'。
|
\noindent
这段 \TeX\ 代码在输出中生成 `\$'。
在第二行，当 \TeX\ 首次查看 `|$|' 时，它是在寻找控制序列名称的结束位置。
由于 `|$|' 还不是字母符，它表示 `|\foo|' 已结束。
接下来，\TeX\ 展开 `|\foo|' 宏并将 `|$|' 的类别码改为 $11$（字母符）。
然后 \TeX\ 才“真正地”读取 `|$|'。
由于 `|$|' 已经是字母符，\TeX\ 用当前字体生成包含 `|$|' 的盒子。
当 \TeX\ 看到第三行时，它将 `|$|' 视为字母符，因此认为它是控制序列名称的一部分。
结果它抱怨 |\foo$| 是一个未定义的控制序列。

%\TeX\ behaves this way even when the terminating character is an
%end of line.  For example, suppose that the macro |\fum| activates the
%end-of-line character.  Then if |\fum| appears on a line $\ell$ by
%itself, \TeX\ will first interpret the end of line of $\ell$ as
%the end of the |\fum| control sequence and then will \emph{reinterpret}
%the end of line of $\ell$ as an active character.
%\endconcept
即使当结束符号是行尾符时，\TeX\ 也是这样处理的。
举个例子，假设你用 |\fum| 宏激活行尾符。
那么，如果 |\fum| 单独出现在第 $\ell$ 行中，
\TeX\ 将首先将第$\ell$行的行尾符解释为 |\fum| 控制序列的结束，
然后将该行尾符\emph{重新解释}为活动字符。
\endconcept


%\conceptindex{characters}
%\concept character
\concept 字符

%{\tighten
%\TeX\ works with \defterm{字符} in two contexts:
%as input characters, which it reads, and as output characters,
%which it typesets.
%\TeX\ transforms most input characters
%into the output characters that depict them.
%For example, it normally
%transforms the input letter `|h|' into the letter `h' typeset in the current
%font.
%That is not the case, however, for an input character such as `|$|' that has a
%special meaning.
%\par}
\TeX\ 在两个方面用到\defterm{字符}（character）：
作为读取的输入字符，以及作为排版的输出字符。
\TeX\ 将大多数输入字符转变成输出字符以显示它们。
例如，它通常将输入字母 `|h|' 转换为用当前字体排版的字母 `h'。
但是，对于类似 `|$|' 这些有特别意义的字符，却不是这么回事。

%\TeX\ gets its input characters by reading them from input files (or from your
%terminal) and by expanding \refterm{macros:macro}.  These are the
%\emph{only} ways that \TeX\ can acquire an input character.
%Each input character has a code number corresponding to its position in the
%\refterm{\ascii} code table.  ^^{\ascii}
%For instance, the letter `|T|' has \ascii\ code~$84$.
\TeX\ 通过读取输入文件（或终端）和展开\refterm{宏}得到输入字符。
它们是 \TeX\ 获取输入字符的\emph{仅有的}途径。
每个输入字符有一个编码，它表示该字符在\refterm{\ascii} 码表的位置。
^^{\ascii}
例如，字母 `|T|' 的 \ascii\ 编码为 $84$。

%When \TeX\ reads
%a character, it attaches a \refterm{category code}
%^^{category codes//attached during input}
%to it.  The category code affects how \TeX\ interprets the
%character once it has been read in.  \TeX\ determines
%(and remembers) the category codes of the characters in a macro when it
%reads the macro's definition.  As \TeX\ reads characters with its eyes
%\seeconcept{\anatomy} it does some ``filtering'',
%such as condensing
%sequences of spaces to a single space.  See \knuth{pages~46--48} for the
%details of this filtering.
在读取字符时，\TeX\ 给它附加一个\refterm{类别码}。
^^{类别码//在读取时附加}
类别码影响 \TeX\ 读取字符时对该字符的解释。
在读取宏定义时，\TeX\ 判定（并记住）宏里面的字符的类别码。
在用它的眼睛读取字符时\seeconcept{\anatomy}，\TeX\ 执行一些“过滤”，
比如将连续多个空格压缩为一个。在\knuth{第~46--48~页}
\footnote{译注：或见该书中文翻译版第35--37页。}
中描述了过滤的细节。

%The \ascii\
%``^{control characters}'' have codes $0$--$31$ and $127$--$255$.
%They either don't
%show up or cause strange behavior on most terminals if you try to
%display them.  Nonetheless they are sometimes needed in \TeX\ input,
%so \TeX\ has a special notation for them.
%\xrdef{twocarets}
%If you type `|^^|$c$', where $c$ is any character, you get the character
%whose \ascii\ code is either $64$ greater or $64$ less than $c$'s
%\ascii\ code.  The largest acceptable code value using this notation
%is $127$, so the notation is unambiguous.
%Three particularly common instances of this
%notation are `|^^M|' (the \ascii\ \asciichar{return} character),
%`|^^J|' (the \ascii\ \asciichar{line\ feed} character) and `|^^I|'
%(the \ascii\ \asciichar{horizontal\ tab} character).
%\ttidxref{^^M}\ttidxref{^^J}\ttidxref{^^I}
\ascii{}“^{控制字符}”的编码为 $0$--$31$ 和 $127$--$255$。
倘若你试图在终端中显示它们，在多数终端中它们将显示不出来或导致奇怪行为。
即便如此，有时候它们还是需要在 \TeX\ 输入中出现，
因此对这些字符 \TeX\ 给出了一种特别的表示法。
\xrdef{twocarets}
如果你键入 `|^^|$c$'，其中 $c$ 为任何字符，
你将得到一个比 $c$ 的\ascii\ 码大 $64$ 或小 $64$ 的字符。
这种表示法得到的编码不能超过 $127$，因此它是无歧义的。
这种表示法的三个最常见例子是 `|^^M|'（\ascii\ \asciichar{return}字符），
`|^^J|'（\ascii\ \asciichar{line\ feed}字符）和
`|^^I|'（\ascii\ \asciichar{horizontal\ tab}字符）。
\ttidxref{^^M}\ttidxref{^^J}\ttidxref{^^I}

%{\tighten
%\TeX\ also has another notation for indicating \ascii\ code values
%that works for all character codes from $0$ to $255$.
%\xrdef{hexchars}
%If you type `|^^|$xy$', where $x$
%and $y$ are any of the ^{hexadecimal digit}s `|0123456789abcdef|',
%you get the single character with the specified code.
%(Lowercase letters are required here.)
%\TeX\ opts for the ``hexadecimal digits''
%interpretation whenever it has a choice, so you must not follow a character
%like `|^^a|' with a lowercase hexadecimal digit---if you do, you'll get the
%wrong interpretation.
%If you need to use this
%notation you'll find it handy to have a table of \ascii\ codes.
%\par}
\TeX\ 还有另一种指明 \ascii\ 编码的表示法，它能够表示从 $0$ 到 $255$ 的所有字符。
\xrdef{hexchars}
如果你键入 `|^^|$xy$'，其中 $x$ 和 $y$ 是任何^{十六进制数字} `|0123456789abcdef|'，
你就得到该编码对应的字符（这里只能使用小写字符。）
\TeX\ 优先选择“十六进制数字”这种解释，
因此在类似 `|^^a|' 的字符后面不要跟着一个小写十六进制数字——这样将会得到错误的解释。
在需要使用这种表示法时，你会发现有个\ascii\ 编码表更方便些。

%An output character is a character to be typeset.
%A command for producing an output character has the meaning
%``Produce a \refterm{box} containing
%character number $n$ from the current \refterm{font}'',
%where $n$ is determined by the command.
%\TeX\ produces your typeset document by combining such boxes with
%other typographical \hbox{elements} and arranging them
%on the page.
输出字符就是待排版的字符。生成输出字符的命令有这样的意义：
“生成一个包含当前\refterm{字体}第$n$个字符的盒子”，其中$n$由该命令给出。
\TeX\ 将这些盒子和其他排版\hbox{元素}组合起来并在页面上排好，以生成你排版的文档。

%An input character whose category code is $11$ (^{letter}) or $12$ (other)
%^^{other characters}
%acts as a command to produce the corresponding output character.  In
%addition you can get \TeX\ to produce character $n$ by issuing the
%command `|\char |$n$' \ctsref{\char}, ^^|\char| where $n$ is a
%\refterm{number} between $0$ and $255$.  The commands `|h|',
%|\char`h|, and |\char104| all have the same effect.  ($104$ is the
%\ascii\ code for `h'.)
类别码为 $11$（^{字母}）或 $12$（其他）^^{其他字符}的输入字符，
是一个生成对应输出字符的命令。
另外，你也可以用 `|\char |$n$'\ctsref{\char}^^|\char| 让 \TeX\ 生成字符 $n$，
其中$n$是介于$0$和$255$之间的\refterm{数}。
命令 `|h|'，|\char`h| 和 |\char104| 的结果相同（$104$ 是`h' 的\ascii\ 编码。）

\endconcept


%\concept class
\concept 类

%The \defterm{class} of a \refterm{character} specifies that character's
%role in math formulas.  The class of a character is encoded in its
%\refterm{mathcode}.  ^^{mathcodes//class encoded in} For example, the
%equals sign `|=|' is in class $3$ (Relation).  \TeX\ uses its knowledge
%of character classes to decide how much space to put between different
%components of a math formula.  \margin{clarifying material added} For
%example, here's a math formula shown first as \TeX\ normally prints it
%and then with the class of each character randomly changed:
%$$\strut a+(b-a)=a \qquad
%   \mathopen{a}\mathord{+}\mathrel{(}\mathclose{b}\mathclose{-}
%   \mathop{a}\mathopen{)}\mathord{=}\mathopen{a}$$
\refterm{字符}所属的\defterm{类}（class）指明该字符在数学公式中的角色。
字符的类记录在它的\refterm{数学码}中。^^{数学码//数学码中的类}
例如，等号 `|=|' 属于第 $3$ 类（关系符号）。
\TeX\ 利用字符类的知识确定数学公式的各部分的间隔的大小。
\margin{clarifying material added}
例如，下面这个公式首先用正常方式显示，然后用随机修改各字符类的方式显示：
$$\strut a+(b-a)=a \qquad
   \mathopen{a}\mathord{+}\mathrel{(}\mathclose{b}\mathclose{-}
   \mathop{a}\mathopen{)}\mathord{=}\mathopen{a}$$

%See \xrefpg\mathord\ of this book for a list of the classes and
%\knuth{page~154} for their meanings.
参见本书\xrefpg\mathord 中各种类的列表，以及\knuth{第~154~页}
\footnote{译注：或见该书中文翻译版第120页。}
中各种类的含义。

\endconcept


%\conceptindex{commands}
%\concept command
\concept 命令

%A \defterm{command} instructs \TeX\ to carry out a certain action.
%Every \refterm{token} that reaches \TeX's stomach \seeconcept{\anatomy}
%acts as a command, except for those that are parts of arguments to
%other commands (see below).
%^^{tokens//as commands}
%A command can be invoked by a
%\refterm{control sequence}, by an \refterm{active character}, or by an
%ordinary character.  It might seem odd that \TeX\ treats an ordinary
%character as a command, but in fact that's what it does:
%when \TeX\ sees
%an ordinary character
%it constructs a \refterm{box} containing that character typeset in
%the current font.
\defterm{命令}（command）指导 \TeX\ 执行某种动作。
到达\TeX\ 的胃\seeconcept{\anatomy}的每个\refterm{记号}都作为一个命令，
那些作为其他命令的参量（见下面）的记号除外。
^^{记号//作为命令}
命令可以由\refterm{控制序列}，由\refterm{活动字符}，或者由普通字符产生。
\TeX\ 将普通字符视为命令这事看来有些奇怪，但实际上它是这样做的：
当 \TeX\ 看到一个普通字符时，它构造一个用当前字体排版该字符的\refterm{盒子}。

%A command can have arguments.
%The arguments of a command are single tokens or
%groups of tokens that complete the description of what
%the command is supposed to do.
%For example, the command `|\vskip 1in|' tells \TeX\ to skip
%$1$ inch vertically.  It has an argument `|1in|',
%which consists of three tokens.
%The description of what |\vskip| is supposed to do would be incomplete
%without specifying how far it is supposed to skip.
%The tokens in the arguments to a command are not themselves considered
%to be commands.
命令可以有参量。命令的参量为单个记号或一组记号，
它们完成对命令该如何执行的说明。
例如，命令 `|\vskip 1in|' 告诉 \TeX\ 竖直跳过 $1$ 英寸。
它有一个参量 `|1in|' 包含三个记号。
如果不指明跳过的距离，对 |\vskip| 如何执行的说明就是不完整的。
这些出现在命令参量中的记号不被看成命令。

%Some examples of different kinds of \TeX\ commands are:
%\ulist\compact
%\li Ordinary characters, such as `|W|', which instructs \TeX\
%to produce a box containing a typeset `W'
%\li Font-setting commands,
%such as |\bf|, which begins boldface type
%\li Accents, such as |\`|, which produces a grave accent as in `\`e'
%\li Special symbols and ligatures, such as |\P| (\P) and |\ae| (\ae)
%\li Parameters, such as |\parskip|, the amount of glue that
%\TeX\ puts between paragraphs
%\li Math symbols, such as |\alpha| ($\alpha$) and |\in| ($\in$)
%\li Math operators, such as |\over|, which produces a fraction
%\endulist
%\endconcept
各种类型的 \TeX\ 命令的一些例子如下：
\ulist\compact
\li 普通字符，比如 `|W|' 指导 \TeX\ 生成包含排版好的 `W' 的盒子
\li 字体设置命令，比如 |\bf| 开始粗体形式
\li 重音符，比如 |\`| 生成一个如同 `\`e' 的钝音符
\li 特殊符号和连写，比如 |\P|（\P ）和 |\ae|（\ae ）
\li 参数，比如 |\parskip| 说明 \TeX\ 在段落间添加的粘连的大小
\li 数学符号，比如 |\alpha|（$\alpha$）和 |\in|（$\in$）
\li 数学运算符，比如 |\over| 生成一个分式
\endulist
\endconcept


%\conceptindex{conditional tests}
%\concept {conditional test}
\concept {条件测试}

%A \defterm{conditional test} is a command that tests whether or not a certain
%condition is true and
%causes \TeX\ either to expand or to skip some text, depending on
%the outcome.
%The general form of a conditional test is either:
%\display{
%{\tt \\if}$\alpha$\<true text>{\tt \\else}\<false text>{\tt \\fi}}
%^^|\else|^^|\fi|
%\noindent or:\hfil\
%\display{
%{\tt \\if}$\alpha$\<true text>{\tt \\fi}}
%\noindent where $\alpha$ specifies the particular test.
%For example, |\ifvmode| tests the condition that \TeX\
%is currently in a \refterm{vertical mode}.
%If the condition is true, \TeX\ expands \<true text>.
%If the condition is false, \TeX\ expands \<false text> (if it's present).
%Conditional tests are interpreted in \TeX's gullet
%\seeconcept{\anatomy}, so any expandable \minref{token}s in
%the interpreted text are expanded after the test has been resolved.
%The
%various conditional tests are explained in \headcit{Conditional tests}%
%{conds}.
%
%\endconcept
\defterm{条件测试}（conditional test）是一个命令，它测试某个条件是否成立，
并依此让 \TeX\ 展开或忽略某些文本。条件测试的一般形式是：
\display{
{\tt \\if}$\alpha$\<true text>{\tt \\else}\<false text>{\tt \\fi}}
^^|\else|^^|\fi|
\noindent 或者：\hfil\
\display{
{\tt \\if}$\alpha$\<true text>{\tt \\fi}}
\noindent 其中 $\alpha$ 指定某个特定的测试。
例如，|\ifvmode| 测试 \TeX\ 是否位于\refterm{竖直模式}中。
如果条件成立，\TeX\ 展开 \<true text>。
如果条件不成立，\TeX\ 展开 \<false text>（如果它存在）。
条件测试在 \TeX\ 的食道\seeconcept{\anatomy}中解释，
因此在解释出的文本中，任何可展开\minref{记号}都被展开了。
在\headcit{条件测试}{conds}中解释了各种条件测试。
\endconcept


%\conceptindex{control sequences}
%\concept{control sequence}
\concept{控制序列}

%A \defterm{control sequence} is a name for a \TeX\ \refterm{command}.
%A control sequence always starts with an ^{escape character}, usually
%a backslash (|\|).
%\indexchar \
%A control sequence takes one of two forms:
\defterm{控制序列}（control sequence）是 \TeX\ \refterm{命令}的名称。
控制序列总是以^{转义符}开头，即以反斜杠（|\|）开头。
\indexchar \
控制序列必为如下两种形式中的一种：

%\ulist
%
%\li A \refterm{control word} is a control sequence consisting of an
%\refterm{escape character} followed by one or more letters.
%^^{control words}
%The control
%word ends when \TeX\ sees a nonletter.  For instance, when \TeX\ reads
%`\hbox{|\hfill!visiblespace,!visiblespace!.the|}', it sees six
%\refterm{tokens:token}:
%the control sequence `|\hfill|', comma, space, `|t|', `|h|', `|e|'.  The
%space after `|\hfill|' ends the control sequence and
%is absorbed by \TeX\ when it scans the control sequence.
%(For the text `|\hfill,!visiblespace!.the|', on the other hand,
%the comma both ends the control sequence and counts as a character in its
%own right.)
\ulist
\li \refterm{控制词}是由\refterm{转义符}紧跟一个或多个字母组成的控制序列。
^^{控制词}
控制词在 \TeX\ 碰到非字母符时结束。
例如，当 \TeX\ 读取 `\hbox{|\hfill!visiblespace,!visiblespace!.the|}' 时，
它看到六个\refterm{记号}：控制序列 `|\hfill|'、逗号、空格、`|t|'、`|h|'、`|e|'。
在 \TeX\ 扫描控制序列时，`|\hfill|'之后的空格结束该控制序列并被吸收掉。%
（另一方面，对于 `|\hfill,!visiblespace!.the|'，
逗号不仅结束控制序列，而且自身也算作一个字符。）
%\li A \refterm{control symbol}
%^^{control symbols}
%is a control sequence consisting of an
%^{escape character} followed by any character other than a letter---%
%even a space or an end of line.
%A control symbol is self-delimited, i.e., \TeX\ knows where it ends without
%having to look at what character comes after it.
%The character after a control symbol is never absorbed by
%the control symbol.
%\endulist
%\noindent See \xrefpg{spaces} for more information about spaces after control
%sequences.
\li \refterm{控制符}是由^{转义符}紧跟单个非字母符组成的控制序列%
——非字母符也可以是空格符或者行尾符。
^^{控制符}
控制符是自定界的，即 \TeX\ 无需读取后面的字符就知道它在哪里结束。
控制符之后的字符永远不会被吸收掉。
\endulist
\noindent 你可以参考\xrefpg{spaces}，其中有对控制序列后的空格的介绍。

%\TeX\ provides a great many predefined control sequences.  The
%\refterm{primitive} control sequences are built into the \TeX\ computer
%program and thus are available in all forms of \TeX.
%^^{primitive//control sequence}
%Other
%predefined control sequences are provided by \refterm{\plainTeX}, the
%form of \TeX\ described in this book.
\TeX\ 提供了许多预定义的控制序列。
\refterm{原始的}控制序列内建于 \TeX\ 程序中，因此可以在各种 \TeX\ 形式中使用。
^^{原始的//原始控制序列}
其他预定义的控制序列由\refterm{\plainTeX}（即本书描述的 \TeX\ 形式）提供。

%You can augment the predefined control sequences with ones of your own,
%using commands such as ^|\def| and ^|\let| to define them.
%\chapterref{eplain} of this book contains a
%collection of control sequence definitions that you may find
%useful.  In addition, your computing facility may
%be able to provide a collection of
%locally developed \TeX\ macros.
%\endconcept
你可以用自己的控制序列扩充预定义的控制序列，只需用 ^|\def| 和 ^|\let| 等命令定义它们。
本书\chapterref{eplain}包含了一批实用的控制序列定义。
此外，你的计算设备也可能提供一批本地开发的 \TeX\ 宏。
\endconcept


%\conceptindex{control symbols}
%\concept{control symbol}
\concept{控制符}

%A \defterm{control symbol} is a \refterm{control sequence} that consists
%of an \refterm{escape character} followed by any character other than a
%letter---even a space or end of line.
%^^{escape character}
%\endconcept
\defterm{控制符}（control symbol）是由\refterm{转义符}紧跟单个非字母符组成的%
\refterm{控制序列}——非字母符也可以是空格符或者行尾符。
^^{转义符}
\endconcept


%\conceptindex{control words}
%\concept{control word}
\concept{控制词}

%A \defterm{control word} is a \refterm{control sequence} that consists
%of an \refterm{escape character} followed by one or more
%letters.\footnote{A ``letter'' here has the strict meaning of a
%character with category code $11$.}
%\TeX\
%ignores any spaces or ends-of-line that follow a control word, except to
%note that they end the control word.
%^^{escape character}
%\endconcept
\defterm{控制词}（control word）是由\refterm{转义符}紧跟一个或多个字母
组成的\refterm{控制序列}。\footnote{其中“字母”的确切含义是指类别码为 $11$ 的字符。}
\TeX\ 忽略控制词之后的空格符或行尾符，仅仅用它们表示控制词的结束。
^^{转义符}
\endconcept


\bookmark{2}{以D开头}
%\concept {decimal constant}
\concept {小数}

见\conceptcit{数}。
\endconcept


%\conceptindex{delimiters}
%\concept delimiter
\concept 定界符

%A \defterm{delimiter} is a character
%that is intended to be used as
%a visible boundary of a math formula.
%The essential property of a delimiter is that \TeX\ can adjust
%its size according
%to the vertical size (\refterm{height} plus \refterm{depth})
%of the subformula.
%However, \TeX\ performs the adjustment only if the delimiter
%appears in a ``delimiter context'', namely, as an argument to
%one of the commands ^|\left|,
%^|\right|,
%|\over!-with!-delims|,
%|\atop!-with!-delims|,
%or |\above!-with!-delims|
%^^|\overwithdelims|
%^^|\atopwithdelims|
%^^|abovewithdelims|
%\margin{Footnote deleted}
%(see \pp\xrefn{\overwithdelims},~\xrefn{\left}).
%The delimiter contexts also include any \refterm{argument}
%to a \refterm{macro} that uses the argument in a delimiter context.
\defterm{定界符}（delimiter）是一个作为数学公式的可见边界的字符。
\TeX\ 可以根据子公式的竖直尺寸（\refterm{高度}加\refterm{深度}）调整定界符大小，
这就是定界符的本质特性。
然而，要让 \TeX\ 对定界符作调整，定界符必须出现在“定界环境”中，
即作为 ^|\left|、^|\right|、|\overwithdelims|、|\atopwithdelims|或 |\abovewithdelims|%
（见\xrefn{\overwithdelims}，\xrefn{\left}页）这些命令之一的参量。
^^|\overwithdelims|
^^|\atopwithdelims|
^^|\abovewithdelims|
\margin{Footnote deleted}
定界环境也包括在定界环境中使用参量的\refterm{宏}的任何\refterm{参量}。

%For example, the left and right
%parentheses are delimiters.
%If you use ^{parentheses} in a delimiter context
%around a formula, \TeX\ makes the parentheses big
%enough to enclose the \refterm{box} that contains the formula (as long as the
%\refterm{fonts:font} you're using have big enough parentheses).
%For example:
%\csdisplay
%$$ \left( a \over b \right) $$
%|
%yields:
%\centereddisplays $$\left (a \over b \right ) $$
%Here \TeX\ has made the parentheses big enough to accommodate the fraction.
%But if you write, instead:
%\csdisplay
%$$({a \over b})$$
%|
%you'll get:
%$$({a \over b})$$
%Since the parentheses aren't in a delimiter context,
%they are \emph{not} enlarged.
举例说，左圆括号和右圆括号是定界符。
如果你在定界环境中用^{圆括号}围住一个公式，
\TeX\ 将增加圆括号的大小以让它们框住包含该公式的\refterm{盒子}%
（只要你所使用的\refterm{字体}有足够大的圆括号）。
例如：
\csdisplay
$$ \left( a \over b \right) $$
|
得到下面的结果：
\centereddisplays $$\left (a \over b \right ) $$
这里 \TeX\ 已经调整了圆括号的大小以框住分数。
但是如果你改为这样写：
\csdisplay
$$({a \over b})$$
|
将会得到下面的结果：
$$({a \over b})$$
由于圆括号不在定界环境中，\TeX\ \emph{不会}增加它们的大小。

%Delimiters come in pairs:
%an opening delimiter at the left of the subformula
%and a closing delimiter at its right.
%You can explicitly choose a larger height for a
%delimiter with the commands ^|\bigl|, ^|\bigr|, and their
%relatives \ctsref{\bigl}.\footnote
%{\PlainTeX\ defines the various |\big| commands by using |\left| and |\right|
%to provide a delimiter context.  It sets the size by
%constructing an empty formula with the desired height.}
%For instance, in order to get the
%displayed formula:
%$$\bigl(f(x) - x \bigr) \bigl(f(y) - y \bigr)$$
定界符必须成对出现：一个开定界符放在子公式左边，
另一个闭定界符放在子公式右边。
你可以用 ^|\bigl|，^|\bigr| 及其他相关命令\ctsref{\bigl}直接选择较大号的定界符。
\footnote
{\PlainTeX\ 定义了各种 |\big| 命令，其中用 |\left| 和 |\right| 提供定界环境。
它通过构造所需尺寸的空公式来设定尺寸。}
例如，要得到下面的陈列公式：
$$\bigl(f(x) - x \bigr) \bigl(f(y) - y \bigr)$$

%\noindent in which the outer parentheses are a little bigger than the inner
%ones, you should write:
\noindent 其中外层的圆括号比内层的稍微大一点，你应该这样写：

%\csdisplay
%$$\bigl( f(x) - x \bigr) \bigl( f(y) - y \bigr)$$
%|
\csdisplay
$$\bigl( f(x) - x \bigr) \bigl( f(y) - y \bigr)$$
|

%The $22$ \plainTeX\ delimiters, shown at their normal size, are:
%\display{%
%$( \>) \>[ \>] \>\{ \>\}
%\>\lfloor \>\rfloor \>\lceil \>\rceil
%\>\langle \>\rangle \>/ \>\backslash
%\>\vert \>\Vert
%\>\uparrow \>\downarrow \>\updownarrow
%\>\Uparrow \>\Downarrow \>\Updownarrow$}
%^^|)| ^^|)| ^^|[| ^^|]| ^^|\lbrack| ^^|\rbrack|
%^^|\{| ^^|\}| ^^|\lbrace| ^^|\rbrace|
%^^|\lfloor| ^^|\rfloor|  ^^|\lceil|  ^^|\rceil|
%^^|\langle|  ^^|\rangle|  ^^|/|  ^^|\backslash|
%^^|\vert|  ^^|\Vert|
%^^|\uparrow|  ^^|\downarrow|  ^^|\updownarrow|
%^^|\Uparrow|  ^^|\Downarrow|  ^^|\Updownarrow|
%\noindent
%Here they are at the largest size provided explicitly by \plainTeX\
% (the |\Biggl|, |\Biggr|, etc., versions):
%\nobreak\vskip .5\abovedisplayskip
%\display{%
%$\Biggl( \>\Biggr) \>\Biggl[ \>\Biggr]
%\>\Biggl\{ \>\Biggr\} \>\Biggl\lfloor \>\Biggr\rfloor
%\>\Biggl\lceil \>\Biggr\rceil
%\>\Biggl\langle \>\Biggr\rangle
%\>\Biggm/ \>\Biggm\backslash
%\>\Biggm\vert \>\Biggm\Vert
%\>\Biggm\uparrow \>\Biggm\downarrow \>\Biggm\updownarrow
%\>\Biggm\Uparrow \>\Biggm\Downarrow \>\Biggm\Updownarrow$}
%\vskip .5\belowdisplayskip
%\noindent
%The delimiters (except for `|(|', `|)|', and
%`|/|')
%are among the symbols listed on
%pages~\xrefn{\lbrace}--\xrefn{\Uparrow}.
%They are listed in one place on \knuth{page~146}.
\PlainTeX\ 中有 $22$ 个定界符，用它们的自然尺寸显示如下：
\display{%
$( \>) \>[ \>] \>\{ \>\}
\>\lfloor \>\rfloor \>\lceil \>\rceil
\>\langle \>\rangle \>/ \>\backslash
\>\vert \>\Vert
\>\uparrow \>\downarrow \>\updownarrow
\>\Uparrow \>\Downarrow \>\Updownarrow$}
\ifoldeplain ^^|(| ^^|)| ^^|[| ^^|]| \fi ^^|\lbrack| ^^|\rbrack|
^^|\{| ^^|\}| ^^|\lbrace| ^^|\rbrace|
^^|\lfloor| ^^|\rfloor|  ^^|\lceil|  ^^|\rceil|
^^|\langle|  ^^|\rangle|  ^^|/|  ^^|\backslash|
^^|\vert|  ^^|\Vert|
^^|\uparrow|  ^^|\downarrow|  ^^|\updownarrow|
^^|\Uparrow|  ^^|\Downarrow|  ^^|\Updownarrow|
\noindent
而用 \plainTeX\ 提供的最大尺寸（|\Biggl|，|\Biggr| 形式）显示如下：
\nobreak\vskip .5\abovedisplayskip
\display{%
$\Biggl( \>\Biggr) \>\Biggl[ \>\Biggr]
\>\Biggl\{ \>\Biggr\} \>\Biggl\lfloor \>\Biggr\rfloor
\>\Biggl\lceil \>\Biggr\rceil
\>\Biggl\langle \>\Biggr\rangle
\>\Biggm/ \>\Biggm\backslash
\>\Biggm\vert \>\Biggm\Vert
\>\Biggm\uparrow \>\Biggm\downarrow \>\Biggm\updownarrow
\>\Biggm\Uparrow \>\Biggm\Downarrow \>\Biggm\Updownarrow$}
\vskip .5\belowdisplayskip
\noindent
这些定界符（`|(|'，`|)|' 和 `|/|' 除外）都出现在%
第~\xrefn{\lbrace}--\xrefn{\Uparrow}页的符号列表中。
它们也都出现在\knuth{第~146~页}
\footnote{译注：或见该书中文翻译版第113页。}
的列表中。

%A delimiter can belong to any class.
%^^{class//of a delimiter}
%For a delimiter that you enlarge with
%|\bigl|, |\bigr|, etc., the class is determined by the command:
%``opener'' for |l|-commands, ``closer'' for |r|-commands,
%``relation'' for |m|-commands, and ``ordinary symbol'' for |g|-commands,
%e.g., |\Big|.
定界符可以属于任何类。
^^{类//定界符的类}
对于用 |\bigl| 和 |\bigr| 等命令增加大小的定界符，它所属的类由该命令决定：
|l|-命令属于“开符号”，|r|-命令属于“闭符号”，
|m|-命令属于“关系符号”，|g|-命令比如 |\Big| 属于“普通符号”。

%You can obtain a delimiter in two different ways:
%\olist
%\li You can make a character be a delimiter by assigning it a
%nonnegative delimiter code
%\bix^^{delimiter codes}
%(see below) with the ^|\delcode| command (\xref\delcode).
%Thereafter the character acts as a delimiter whenever you use it in a
%delimiter context.\footnote{%
%It's possible to use a character with a nonnegative delimiter code in
%a context where it isn't a delimiter. In this case \TeX\ doesn't perform the
%search; instead it just uses the character in the ordinary way
%(see \knuth{page~156}).}
%\li You can produce a delimiter explicitly with the ^|\delimiter| command
%(\xref\delimiter), in analogy to the way that you can produce an ordinary
%character with the |\char| command or a math character with the |\mathchar|
%command.
%The |\delimiter| command uses the same delimiter codes that are used in a
%|\delcode| table entry, but with an extra digit in front to indicate a
%class.
%It's rare to use |\delimiter| outside of a macro definition.
%\endolist
你可以用两种不同方法得到一个定界符：
\olist
\li 通过用 ^|\delcode| 命令（\xref\delcode ）给一个字符赋予非负定界码（见下面），
\bix^^{定界码}
你可以将这个字符变成定界符。
这样，如果你在定界环境中使用这个字符，它就和定界符一样。\footnote{%
在非定界环境中使用定界码非负的字符也是可以的。
此时 \TeX\ 将不会执行搜索，而仅仅以普通方式使用该字符（见\knuth{第~156~页}）。}
\li 你可以用 ^|\delimiter| 命令（\xref\delimiter ）直接生成一个定界符，
这与你用 |\char| 命令生成一个普通字符或者用 |\mathchar| 命令生成一个数学字符类似。
|\delimiter| 命令使用的定界码和 |\delcode| 表格项用到的一样，
但前面多了一个数字用于标示所属的类。
除了在宏定义中，其他地方很少用到 |\delimiter| 命令。
\endolist

%A delimiter code tells
%\TeX\ how to search for an appropriate output character to represent
%a delimiter.
%The rules for this search are rather complicated
%(see \knuth{pages~156 and 442}).
%A complete understanding of these rules requires knowing
%about the organization of font ^{metrics file}s, a topic that is not just beyond
%the scope of this book but beyond the scope of \texbook\ as well.
定界码（delimiter code）告诉 \TeX\ 如何搜索合适的输出字符来表示一个定界符。
这些搜索规则相当复杂（见\knuth{第~156 和 442~页}
\footnote{译注：或见该书中文翻译版第122页。}）。
要完全理解这些规则需要熟悉字体^{度量文件}的结构，
而这个主题不仅超出本书范围，也超出 \texbook\ 的范围。

%In essence the search works like this.  The delimiter code specifies a
%``small'' output character and a ``large'' output character by
%providing a \refterm{font} position and a font \refterm{family} for each
%(see \xref\delcode).
%Using this information, \TeX\ can find (or construct)
%larger and larger versions of the delimiter.  \TeX\ first tries
%different sizes (from small to large)
%of the ``small'' character in the ``small'' font
%and then
%different sizes (also from small to large)
%of the ``large'' character in the ``large'' font,
%seeking one whose height plus depth is sufficiently large.
%If none of the characters it finds are large
%enough, it uses the largest one that it finds.
%It's possible that
%the small character, the large character, or both have been left unspecified
%(indicated by a zero in the appropriate part of the delimiter code).
%If only one character
%has been specified, \TeX\ uses that one. If neither has been specified,
%it replaces the delimiter by a space of width ^|\nulldelimiterspace|.
%\eix^^{delimiter codes}
本质上搜索过程是这样运行的。定界码给出了字体\refterm{族}和\refterm{字体}位置，
从而指定了一个“小号”输出字符和一个“大号”输出字符（见\xref\delcode ）。
利用这些信息，\TeX\ 能够找到（或者构造）定界符的越来越大的版本。
\TeX\ 首先尝试“小号”字体的“小号”字符的不同尺寸（从小到大），
然后是“大号”字体的“大号”字符的不同尺寸（同样是从小到大），
寻找一个高度加上深度足够大的字符。
如果所找到的字符都不够大，它就用最大那个。
也有可能小号字符或大号字符，或两者都没指定（即定界码的对应部分为零）。
如果只指定了一个字符，\TeX\ 使用那一个。如果两个字符都没指定，
它就将定界符替换为宽度为 ^|\nulldelimiterspace| 间隔。
\eix^^{定界码}

\endconcept


%\concept demerits
\concept 缺陷

%\TeX\ uses \refterm{demerits} as a measure of how undesirable a line is
%when it's breaking a paragraph into lines \seeconcept{line break}.
%^^{line breaks//demerits for}
%The demerits of a line are affected both by the \refterm{badness} of the line
%and by \refterm{penalties:penalty} associated with the line.
%^^{badness}
%\TeX's goal in choosing a particular arrangement of lines is to minimize the
%total demerits for the paragraph, which it computes by adding up the demerits
%for the individual lines.
%See \knuth{pages~97--98} for the details of how \TeX\
%breaks a paragraph into lines.
%\TeX\ does not use demerits when it's choosing page breaks; instead, it uses
%a similar measure known as the ``cost'' of a particular page break.
%\endconcept
\TeX\ 用\refterm{缺陷}（demerits）度量它分段为行时文本行的不良度\seeconcept{断行点}。
^^{断行//断行的缺陷}
文本行的缺陷同时受该行的\refterm{劣度}和它带有的\refterm{惩罚}影响。
^^{劣度}
\TeX\ 的目标是合理地分配各行文本，以让段落的总缺陷最小，
其中总缺陷由各行的缺陷加起来。
参见 \knuth{第~97--98~页}
\footnote{译注：或见该书中文翻译版第74--75页。}
以了解 \TeX\ 分段为行的细节。
\TeX\ 选择分页点时不使用缺陷；它使用的是被称为分页“代价”的类似概念。
\endconcept


%\concept depth
\concept 深度

%^^{boxes//depth of}
%The \defterm{depth} of a \refterm{box} is the distance that the box extends
%below its \refterm{baseline}.
%\endconcept
^^{盒子//盒子的深度}
盒子的\defterm{深度}（depth）是盒子在\refterm{基线}之下的距离。
\endconcept


%\conceptindex{dimensions}
%\concept dimension
\conceptindex{尺寸}
\concept 尺寸

%A \defterm{dimension} specifies a distance, that is, a linear measure of
%space.  You use dimensions to specify sizes of things, such as the length
%of a line.  Printers in English-speaking countries traditionally measure
%distance in points and picas, while printers in continental Europe
%traditionally measure distance in did\^ot points and ciceros.  You can
%use these units or others, such as inches, that may be more
%familiar to you.  The font-independent
%^{units of measure} that \TeX\ understands are:
\defterm{尺寸}（dimension）指定了一个距离，即对空间的长度测量。
你用尺寸指定事物的大小，比如文本行的长度。
英语国家的打印机习惯用点（point）和派卡（pica）来测量距离，
而欧洲大陆的打印机习惯用迪多点（ did\^ot points）和西塞罗（cicero）。
你可以使用这些单位，或者其他你更熟悉的单位，比如英寸。
\TeX\ 能够识别的与字体无关的^{度量单位}有如下这些：

%\xrdef{dimdefs}
%\nobreak\vskip\abovedisplayskip
%\halign{\indent\hfil\tt #\qquad&#\hfil\cr
%pt&^{point} (72.27 points = 1 inch)\cr
%pc&^{pica} (1 pica = 12 points)\cr
%bp&big point (72 big points = 1 inch)\cr
%in&^{inch}\cr
%cm&^{centimeter} (2.54 centimeters = 1 inch)\cr
%mm&^{millimeter} (10 millimeters = 1 centimeter)\cr
%dd&^{\didotpt} (1157 {\didotpt}s = 1238 points)\cr
%cc&^{cicero} (1 cicero = 12 {\didotpt}s)\cr
%sp&^{scaled point} (65536 scaled points = 1 point)\cr
%}
%\vskip\belowdisplayskip
\xrdef{dimdefs}
\nobreak\vskip\abovedisplayskip
\halign{\indent\hfil\tt #\qquad&#\ \hfil&#\qquad\hfil&#\hfil\cr
pt& point        & ^{点} & 72.27 points = 1 inch\cr
pc& pica         & ^{派卡} &1 pica = 12 points\cr
bp& big point    & ^{大点} & 72 big points = 1 inch\cr
in& inch         & ^{英寸} &\cr
cm& centimeter   & ^{厘米} & 2.54 centimeters = 1 inch\cr
mm& millimeter   & ^{毫米}  & 10 millimeters = 1 centimeter\cr
dd& \didotpt     & ^{迪多点}  & 1157 {\didotpt}s = 1238 points\cr
cc& cicero       & ^{西塞罗} & 1 cicero = 12 {\didotpt}s\cr
sp& scaled point & ^{缩点}  & 65536 scaled points = 1 point\cr
}
\vskip\belowdisplayskip

%Two additional units of measure are associated with every font: `^|ex|',
%a vertical measure usually about the height of the letter `x'
%in the font, and `^|em|', a
%horizontal measure usually equal to the point size of the font and
%about the width of the letter `M' in the font. Finally,
%\TeX\ provides three ``infinite'' units of measure: `^|fil|', `^|fill|', and
%`^|filll|', in increasing order of~strength.
还有两个与字体相关的度量单位：
`^|ex|' 是一个纵向尺寸，通常与字体中字母 `x' 的高度相关；
`^|em|' 是一个横向尺寸，通常等于字体的大小，与字体中字母 `M' 的宽度相关。
最后，\TeX\ 还提供了三个“无限的”度量单位：`^|fil|'，`^|fill|' 和 `^|filll|'，
它们的强度的阶依次增大。

%A dimension is written as a ^{factor}, i.e, a multiplier,
%followed by a unit of measure.
%^^{units of measure}
%The factor can be either a whole \refterm{number} or
%a \refterm{decimal constant} containing a decimal point
%or decimal comma.
%The factor can be preceded by a plus or minus sign, so a dimension
%can be positive or negative.
%^^{dimensions//negative}
%The unit of measure must be there, even if the number is
%zero.  Spaces between the number and the unit of measure are permitted
%but not required.  You'll find a precise definition of a
%dimension on \knuth{page~270}.  Here are some examples of dimensions:
尺寸可以用一个^{因子}，即乘数，后面加上度量单位来表示。
^^{度量单位}
因子可以是一个整\refterm{数}，或是一个带有小数点或小数逗号的\refterm{小数}。
因子之前可以带有加号或减号，因此尺寸可正可负。
^^{尺寸//负尺寸}
即使数值为零，度量单位也必须写上。数值和度量单位之间可以有也可以没有空格。
在\knuth{第~270~页}
\footnote{译注：或见该书中文翻译版第221页。}
中有尺寸的精确定义。下面这些是尺寸的例子：

%\csdisplay
%5.9in    0pt    -2,5 pc    2fil
%|
%The last of these represents a first-order infinite distance.
\csdisplay
5.9in    0pt    -2,5 pc    2fil
|
其中最后一个尺寸表示一个一阶无限距离。

%An infinite distance outweighs any finite distance or any weaker infinite
%distance.  If you add |10in| to |.001fil|, you get |.001fil|; if you add
%|2fil| to |-1fill| you get |-1fill|; and so forth.
%\TeX\ accepts infinite distances
%only when you are specifying the \refterm{stretch} and \refterm{shrink}
%of \refterm{glue}.
无限距离远远大于任何有限距离或者任何低阶的无限距离。
如果你给 |.001fil| 加上 |10in|，你得到 |.001fil|；
如果你给 |-1fill| 加上 |2fil|，你得到 |-1fill|，依此类推。
只有在指定\refterm{粘连}的\refterm{伸长量}和\refterm{收缩量}时，
才可以使用无限距离。

%\TeX\ multiplies all dimensions in your document by a
%\refterm{magnification} factor $f/1000$,
%where $f$ is the value of the ^|\mag| parameter.
%^^{magnification}
%Since the default value of
%|\mag| is $1000$, the normal case is that your document is
%typeset just as specified.  You can specify a dimension as it will be
%measured in the final document independent of magnification by putting
%`|true|' in front of the unit.  For instance, `|\kern 8 true pt|'
%produces a kern of $8$ points whatever the magnification.
%\endconcept
\TeX\ 对文档中的所有尺寸都乘以一个\refterm{放大率}因子$f/1000$，
其中 $f$ 是 ^|\mag| 参数的值。
^^{放大率}
由于 |\mag| 的默认值为 $1000$，在一般情形下文档是照常排版的。
你可以指定一个与放大率无关的最终文档尺寸，
只要在度量单位前加上 `|true|'。
例如，`|\kern 8 true pt|' 生成了一个与放大率无关的 $8$ 点大小的紧排。
\endconcept


%\concept {display math}
\concept {陈列公式}

%The term \defterm{display math} refers to a math formula that \TeX\
%places on a line by itself with extra space above and below
%so as to set it off from the surrounding text.
%A display math formula is enclosed by `|$$|'s.
%\ttidxref{$$}
%\TeX\ reads display math in display math \refterm{mode}.
%\endconcept
\defterm{陈列公式}（display math）表示在单独一行显示的公式；
\TeX 在陈列公式上边和下边添加额外间隔，以隔开周围文本。
陈列公式两边用 `|$$|' 括起来。
\ifoldeplain\ttidxref{$$}\fi
\TeX\ 在陈列数学\refterm{模式}中读取陈列公式。
\endconcept


\bookmark{2}{以E开头}
%\concept{escape character}
\concept{转义符}

%An \defterm{escape character} introduces a control sequence.  The escape
%character in \refterm{\plainTeX} is the backslash (|\|).
%\indexchar \
%You can change the escape character from $c_1$ to $c_2$
%by reassigning the category codes of $c_1$ and $c_2$
%with the ^|\catcode| command \ctsref{\catcode}.
%You can also define additional escape characters similarly.
%If you want to typeset material containing literal escape characters, you must
%either
%(a) define a control sequence that stands for the printed escape character or
%(b) temporarily
%disable the escape character by changing its category code, using the
%method shown on \xrefpg{verbatim}.  The definition:
\defterm{转义符}（escape character）引入一个控制序列。
\refterm{\PlainTeX} 的转义符是反斜杠(|\|)。
\indexchar \
利用 ^|\catcode| 命令\ctsref{\catcode}重新定义 $c_1$ 和 $c_2$ 的类别码，
你可以将转义符从 $c_1$ 改为 $c_2$。类似地你可以定义额外的转义符。
如果你想排版包含字面转义符的材料，你必须或者
(a) 定义一个表示打印转义符的控制序列，或者
(b) 使用\xrefpg{verbatim}介绍的方法，改变转义符的类别码以临时取消转义。
% 译注：这里给出的页码似乎有误。
下述定义：

%\csdisplay
%\def\\{$\backslash$}
%|
%is one way of creating a control sequence that stands for `$\backslash$'
%(a backslash typeset in a math font).
\csdisplay
\def\\{$\backslash$}
|
是一种生成表示 `$\backslash$' 的控制序列的方法（用数学字体排版反斜杠）。

%You can use the ^|\escapechar| parameter \ctsref{\escapechar} to specify
%how the escape character is represented in synthesized control sequences,
%e.g., those created by |\string| and |\message|.
%
%\endconcept
对于合成控制序列，比如那些由 |\string| 和 |\message| 生成的控制序列，
你可以用 ^|\escapechar| 参数\ctsref{\escapechar}指定其中的转义符用哪个字符表示。
\endconcept


\bookmark{2}{以F开头}
%\concept family
\concept 族

%A \defterm{family} is a group of three related \refterm{fonts:font} used
%when \TeX\ is in \refterm{math mode}.
%^^{fonts//families of}
%Outside of math mode, families
%have no effect.  The three fonts in a family are used for normal symbols
%(\refterm{text size}), subscripts and superscripts (\refterm{script
%size}), and sub-subscripts, super-superscripts, etc.\
%(\refterm{scriptscript size}).
%^^{text size}
%^^{script size}
%^^{scriptscript size}
%For example, the numeral `|2|' set in
%these three fonts would give you `$2$', `$\scriptstyle 2$', and
%`$\scriptscriptstyle 2$' (in \plainTeX).
%Ordinarily you would set up the
%three fonts in a family as different point sizes of the same typeface,
%but nothing prevents you from using different typefaces for the three
%fonts as well or using the same font twice in a family.
\defterm{族}（family）是用于\refterm{数学模式}的，由三个相关\refterm{字体}组成的集合。
^^{字体//字体族}
在数学模式之外，族没有任何作用。
一个族的三个字体分别用于正常符号（\refterm{文本尺寸}），
上标和下标（\refterm{标号尺寸}），以及次上标和次下标等（\refterm{小标号尺寸}）。
^^{文本尺寸}
^^{标号尺寸}
^^{小标号尺寸}
例如，数字 `|2|' 用这三个字体分别显示为 `$2$'、`$\scriptstyle 2$' 和
`$\scriptscriptstyle 2$'（在 \plainTeX\ 中）。
通常你会将一个族的三个字体设定为相同字型且不同点数，
但没人阻止你将这三个字体也设定为不同字型，或者将其中两个字体设定为完全一样。

%{\tighten
%\TeX\ provides for up to sixteen families, numbered $0$--$15$.  For
%example, family $0$ in \refterm{\plainTeX} consists of $10$-point roman
%for text, $7$-point roman for script, and $5$-point roman for
%scriptscript.
%^^{\plainTeX//font families in}
%\PlainTeX\ also defines family $1$ to consist of math
%italic fonts and reserves families $2$ and $3$ for ^{special symbols} and
%^{math extensions} respectively.\footnote{Families $2$ and $3$ are special
%in that their font metric files must include parameters for math
%spacing.} If you need to define a family for yourself, you should use
%the ^|\newfam| command \ctsref{\@newfam} to get the number of a family that
%isn't in use, and the ^|\textfont|, ^|\scriptfont|,
%and ^|\scriptscriptfont| commands \ctsref{\scriptscriptfont}
%to assign fonts to that family.
%\par}
%
%\endconcept
\TeX\ 提供多达十六个字体族，它们用 $0$--$15$ 编号。
比如在\refterm{\plainTeX} 中，第 $0$ 族由用于文本尺寸的 $10$ 点罗马字体，
用于标号尺寸的 $7$ 点罗马字体，以及用于小标号尺寸的 $5$ 点罗马字体组成。
^^{\plainTeX//其中的字体族}
\PlainTeX\ 还将第 $1$ 族定义为由数学意大利字体组成，
并将第 $2$ 族和第 $3$ 族分别保留给^{特殊符号}和^{数学扩展符号}。
\footnote{第 $2$ 族和第 $3$ 族的特殊之处在于，它们的字体度量文件必须包含数学间隔参数。}
\footnote{译注：第 $4$--$7$ 族分别定义为 |\itfam|、|\slfam|、|\bffam| 和 |\ttfam|。}
如果你需要自己定义字体族，你应该使用 ^|\newfam| 命令\ctsref{\@newfam}获取未使用的族编号，
再用 ^|\textfont|、^|\scriptfont| 和 ^|\scriptscriptfont|
命令\ctsref{\scriptscriptfont}分别设定该族的各个字体。
\endconcept


%\conceptindex{files}
%\concept file
\concept 文件

%A \defterm{file} is a stream of information that \TeX\ interprets or
%creates.  Files are managed by the ^{operating system} that supervises your
%\TeX\ run.  \TeX\ deals with files in four different contexts:
%\olist
%\li A ``^{source file}'' is one that \TeX\ reads with its ``eyes''
%\seeconcept{\anatomy} and interprets according to its ordinary rules.
%Your primary input file---the one you specify after `|**|' or
%on the command line when
%you invoke \TeX---is a source file, and so is any file that you call for
%with an ^|\input| command \ctsref \input.
\defterm{文件}（file）是 \TeX\ 解释或者创建的信息流。
文件由监督 \TeX\ 运行的^{操作系统}管理。
\TeX\ 在四种不同的背景中用到文件：
\olist
\li “^{源码文件}”是 \TeX\ “眼睛”读取\seeconcept{\anatomy}，并根据它的一般法则解释的文件。
你的主要输入文件——即调用 \TeX\ 时在 `|**|' 之后或者在命令行中指定的文件%
——是一个源码文件，你用 ^|\input|命令\ctsref \input 请求的任何文件同样也是。

%\li A ``^{result file}'' is one that contains the results of
%running \TeX.  A \TeX\ run creates two result files: the
%\dvifile\ and the log file.
%^^{\dvifile//as a result file}
%^^{log file//as a result file}
%The \dvifile\ contains the information needed to print your document;
%the
%log file contains a record of what happened during the run, including any
%error messages that \TeX\ generated.
%If your primary source file is named
%|screed.tex|, your \dvifile\ and log file will be named |screed.dvi|
%and |screed.log|.\footnote{This is the usual convention, but
%particular implementations of \TeX\ are free to change it.}
\li “^{结果文件}”是包含 \TeX\ 运行结果的文件。
\TeX\ 运行后产生两个结果文件：\dvifile 和日志文件。
^^{\dvifile//作为结果文件}
^^{日志文件//作为结果文件}
\dvifile 包含打印文档所需的信息，而日志文件包含运行记录，包括 \TeX\ 生成的任何错误信息。
若主要输入文件的名称是 |screed.tex|，则 \dvifile 和日志文件的名称分别是
|screed.dvi| 和 |screed.log|。\footnote{这是通常的约定，
但特定的 \TeX\ 实现可以自由地修改它。}

%\li To read from a file with the ^|\read|
%command \ctsref{\read} you need to associate the file with an input stream.
%^^{input streams//reading with \b\tt\\read\e}
%You can have up to $16$ input streams active
%at once, numbered $0$--$15$.
%The |\read| command reads a single line and makes it the value of a
%designated \refterm{control sequence}, so reading with
%|\read| is very different from reading with ^|\input| (which brings in an
%entire file).
%\TeX\ takes any input stream number not between
%$0$ and $15$ to refer to the terminal,
%so `|\read16|', say, reads the next line that you type at the terminal.
\li 要用 ^|\read| 命令\ctsref{\read}读取一个文件，你需要将这个文件和一个输入流关联起来。
^^{输入流//用 \b\tt\\read\e 读取}
你最多可以有 $16$ 个同时活动的输入流，它们以 $0$--$15$ 编号。
|\read| 命令读取一行并把它作为指定\refterm{控制序列}的值，
因此用 |\read| 读取和用 ^|\input| 读取是大不相同的（后者读入整个文件）。
\TeX\ 将编号不在 $0$ 和 $15$ 之间的输入流视为终端，
因此，比如说 `|\read16|'，将读取你在终端中键入的下一行文本。

%\li To write to a file with the |\write|
%command \ctsref \write\ you need to associate the file
%with an output stream.
%^^|\write//output stream for|
%^^{output streams}
%You can have up to $16$ output streams active
%at once, numbered $0$--$15$.
%Input and output streams are independent.
%Anything sent to an output stream with a negative number goes to the log
%file; anything sent to an output stream with a number greater than $15$
%goes both to the log file and to the terminal.
%Thus `|\write16|', say, writes a line on the terminal and also sends
%that line
%to the log~file.
%
%\endolist
\li 要用 |\write| 命令\ctsref \write 写入一个文件，你需要将这个文件和一个输出流关联起来。
^^|\write//用于输出流|
^^{输出流}
你最多可以有 $16$ 个同时活动的输出流，它们以 $0$--$15$ 编号。输入流和输出流是相互独立的。
任何送到编号为负数的输出流的东西，将被写到日志文件中；
而任何送到编号大于 $15$ 的输出流的东西，将同时被写到日志文件和终端中。
因此，比如说 `|\write16|'，将在终端中写上一行文本并将它送到日志文件中。
\endolist

%You must open a stream file before you can use it.
%An input stream file is opened with an ^|\openin|
%command  \ctsref \openin\ and an output stream file is opened with an
%^|\openout| command \ctsref\openout.
%For tidiness
%you should close a stream file when you're done with it, although
%\TeX\ will do that at the end of the run if you don't.
%The two commands for closing a stream file are ^|\closein| \ctsref\closein\
%and ^|\closeout| \ctsref\closeout.
%An advantage of closing a stream when
%you're done with it is that you can then reuse the stream for a different file.
%Doing this can be essential when you're reading a long sequence of files.
在使用流文件之前，你必须先打开它。输入流文件用 ^|\openin| 命令\ctsref \openin 打开，
而输出流文件用 ^|\openout| 命令\ctsref\openout 打开。
为保持整洁，你应该在完成后关闭流文件；
然而即使你不这么做，\TeX\ 在运行结束时也会帮你关闭它。
用于关闭流文件的两个命令分别是 ^|\closein|\ctsref\closein 和 ^|\closeout|\ctsref{\closeout}。
在完成后关闭流文件的优点是，你可以把它重新用到另一个文件去。
在读取一长串文件时，这样做是很有必要的。

%Although you can assign numbers yourself to input and output streams,
%it's better to do it with the ^|\newread| and
%^|\newwrite| \ctsref{\@newwrite} commands.
%You can have more than one stream associated with a particular file,
%but you'll get (probably undiagnosed) garbage unless all of the streams
%are input streams.  Associating more than one stream with an input file
%can be useful when you want to use the same input file for two different
%purposes.
虽然你可以自己给输入流和输出流编号，
但最好还是用 ^|\newread| 和 ^|\newwrite|\ctsref{\@newwrite}命令处理流编号。
一个特定文件可以关联到多个流，
但除非所有流都是输入流，否则你将会得到（也许是原因不明的）垃圾。
当你想把同个输入文件用于两个不同目的时，一个输入文件关联多个流就很有用。

%\TeX\ ordinarily defers the actions of opening, writing to, or closing
%an output stream until it ships out a page with ^|\shipout|
%(see \knuth{page~227}
%for the details).  This behavior applies even to messages written to the
%terminal with |\write|.  But you can get \TeX\ to perform an action
%on an output stream immediately by preceding the action command with
%^|\immediate| \ctsref\immediate.  For example:
%\csdisplay
%\immediate\write16{Do not pass GO!! Do not collect $200!!}
%|
%\endconcept
一般地，\TeX\ 会推迟输出流的打开、写入和关闭操作，
直到它用 ^|\shipout|送出一个页面（详情可见\knuth{第~227~页}
\footnote{译注：或见该书中文翻译版第183页。}）。
甚至用 |\write| 输出消息到终端时也是这样的。
然而，通过在操作命令之前加上 ^|\immediate|\ctsref\immediate ，
你可以让 \TeX\ 立即执行输出流操作。比如：
\csdisplay
\immediate\write16{Do not pass GO!! Do not collect $200!!}
|
\endconcept


%\conceptindex{file names}
%\concept {file name}
\concept {文件名}

%A \defterm{file name} names a
%\refterm{file} that is known to the ^{operating system}
%that in turn
%supervises your \TeX\ run.  The syntax of a file name does \emph{not}
%follow the usual rules of \TeX\ syntax, and in fact it is different
%in different implementations of \TeX.
%In particular, most \TeX\ implementations consider a file name to be
%terminated by a blank or an end of line.  Thus \TeX\ is likely to
%misinterpret `|{\input chapter2}|'
%by taking the right brace as part of the file name.
%As a general rule, you should follow a file name by a blank or the
%end of the line as in `|{\input chapter2!visiblespace}|'.
\defterm{文件名}（file name）是\refterm{文件}在监督 \TeX\ 运行的^{操作系统}中的名称。
文件名的语法\emph{并不}遵循 \TeX\ 语法的一般规则，
而且实际上在不同的 \TeX\ 实现中它们各不相同。
特别地，大多数 \TeX\ 实现都认为文件名在空格符或行尾符处结束。
因此 \TeX\ 有可能曲解 `|{\input chapter2}|'，将右括号视为名称的一部分。
一般来说，你应该在文件名后面添加一个空格符或行尾符，
就像 `|{\input chapter2!visiblespace}|' 这样。

\endconcept


%\eject
%\conceptindex{fonts}
%\concept font
\concept 字体

%A \defterm{font} in \TeX\ is a collection of up to $256$ output
%characters, usually having the same typeface design, style (roman,
%italic, bold, condensed, etc.),
%and point size.\footnote{\PlainTeX\ uses a special
%font for constructing ^{math symbols} in which the characters have
%different sizes.  Other special fonts are often useful for applications
%such as typesetting ^{logos}.} The ^{Computer Modern fonts} that
%generally come with \TeX\ have only $128$ characters. The colophon on
%the last page of this book describes the typefaces that we used to set
%this book.
在 \TeX\ 中，\defterm{字体}（font）是由不超过 $256$ 个输出字符组成的集合，
这些字符通常有相同的设计、样式（罗马体、意大利体、粗体、窄体等）和点数。
\footnote{\PlainTeX\ 用于构造^{数学符号}的特殊字体包含点数不同的字符。
在排版^{标识}（logo）等应用中也经常使用其他的特殊字体。}
\TeX\ 自带的^{计算机现代字体}一般只有 $128$ 个字符。
在本书最后面的书尾页中描述了排版本书所用的字体。

%For instance, here is the alphabet in the Palatino Roman $10$ point font:
%^^{Palatino fonts}
%\vskip\abovedisplayskip{\narrower\tenpal
%\noindent ABCDEFGHIJKLMNOPQRSTUVWXYZ\hfil\break
%abcdefghijklmnopqrstuvwxyz\par
%}\vskip\belowdisplayskip
%\noindent
%And here it is in the Computer Modern Bold Extended $12$
%point font:
%^^{Computer Modern fonts}
%\vskip\abovedisplayskip{\narrower\font\twelvebf=cmbx12\twelvebf
%\noindent ABCDEFGHIJKLMNOPQRSTUVWXYZ\hfil\break
%abcdefghijklmnopqrstuvwxyz\par
%}\vskip\belowdisplayskip
%The characters in a font are numbered.
%The numbering usually agrees with the ^{\ascii} numbering
%for those characters that exist in the \ascii\ character set.
%The code table for each font indicates what the character
%with code $n$ looks like in that font.
%Some fonts, such as the ones used for mathematical symbols, have no
%letters at all in them.  You can produce a \refterm{box} containing the
%character numbered $n$, typeset in the current font, by writing `|\char |$n$'
% \ctsref{\char}.
举个例子，这里是 $10$ 点 Palatino 罗马字体的字母表：
^^{Palatino 字体}
\vskip\abovedisplayskip{\narrower\tenpal
\noindent ABCDEFGHIJKLMNOPQRSTUVWXYZ\hfil\break
abcdefghijklmnopqrstuvwxyz\par
}\vskip\belowdisplayskip
\noindent
而这里是 $12$ 点计算机现代粗体扩展字体的字母表：
^^{计算机现代字体}
\vskip\abovedisplayskip{\narrower\font\twelvebf=cmbx12\twelvebf
\noindent ABCDEFGHIJKLMNOPQRSTUVWXYZ\hfil\break
abcdefghijklmnopqrstuvwxyz\par
}\vskip\belowdisplayskip
字体中的字符都是编好号的。对于在 \ascii\ 字符表中存在的字符，
它们的编号一般与其 ^{\ascii} 编码一致。
每个字体的编码表指明该字体的第 $n$ 个字符是怎样的。
有些字体，比如那些用于数学符号的字体，根本不包含任何字母字符。
你可以用 `|\char |$n$'\ctsref{\char}生成包含第 $n$ 个字符的盒子，
该字符用当前字体排版。

%In order to use a font in your document,
%you must first name it with a control sequence and load it.  Thereafter you
%can select it by typing
%that control sequence whenever you want to use it.
%\PlainTeX\ provides a number of fonts that are already named and~loaded.
要在文档中使用某个字体，你必须先用控制序列给它命名再载入它。
此后，在需要用到它的地方，你就可以键入该控制序列来选择它。
\PlainTeX\ 提供了若干已经命名和载入的字体。

%You name and load a font as a single operation, using a
%command such as `|\font\twelvebf=cmbx12|'.  Here `|\twelvebf|' is the
%control sequence that you use to name the font
%and `|cmbx12|' identifies the font metrics file
%|cmbx12.tfm|
%in your computer's file system.
%You then can start to use the font by typing
%`|\twelvebf|'.  After that, the font will be in effect until
%either (a)~you select another font or (b)~you terminate the
%\refterm{group}, if any, in which you started the
%font.  For example, the input:
你可以用像 `|\font\twelvebf=cmbx12|' 这样的命令在同一个操作中命名并载入字体。
这里的 `|\twelvebf|' 是用于命名该字体的控制序列，
而 `|cmbx12|' 表示计算机文件系统中的字体度量文件 |cmbx12.tfm|。
现在你可以通过键入 `|\twelvebf|' 开始使用这个字体。
在此之后，这个字体将一直生效，直到
(a)~你选择了另一个字体，或者 (b)~你结束了\refterm{编组}，
如果在开始字体时就位于这个编组中。例如下面的输入：

%\csdisplay
%{\twelvebf white rabbits like carrots}
%|
%will cause the |cmbx12| font to be in effect just for the
%text `|white rabbits like carrots|'.
\csdisplay
{\twelvebf white rabbits like carrots}
|
将使得 |cmbx12| 字体只对文本 `|white rabbits like carrots|' 生效。

%You can use \TeX\ with fonts other than
%Computer Modern (look at the example on \xrefpg{palatino} and
%at the page headers).
%The files for such fonts need to be
%installed in your computer's file system in a place where \TeX\ can find
%them.  \TeX\ and its companion programs generally need two files for each font:
%one to give its metrics (|cmbx12.tfm|,
%^^{\tfmfile}
%for example) and another to
%give the shape of the characters (|cmbx12.pk|, for example).
%\TeX\ itself uses only the metrics
%file.  Another program, the device driver,
%^^{device drivers}
%converts the \dvifile\
%^^{\dvifile//converted by driver}
%produced by \TeX\ to a form that your printer
%or other output device can handle.  The driver
%uses the shape file (if it exists).
在 \TeX\ 中你可以使用与计算机现代不同的字体（见\xrefpg{palatino}的例子以及页眉）。
这些字体的文件需要安装在计算机文件系统的某个 \TeX\ 能找到的位置中。
对每个字体，\TeX\ 及相关程序一般需要两个文件：
一个给出各字符的度量（比如 |cmbx12.tfm|），
^^{\tfmfile}
另一个给出各字符的形状（比如 |cmbx12.pk|）。
\TeX\ 本身仅用到度量文件。另一个程序，设备驱动程序，
^^{设备驱动}
把 \TeX\ 生成的 \dvifile 转换为能被打印机或其他输出设备处理的格式。
^^{\dvifile//由驱动程序转换}
设备驱动程序要用到形状文件（如果该文件存在）。

%The font metrics file contains the information that \TeX\ needs in
%order to allocate space for each typeset character.
%Thus it includes the size of each character, the ligatures and
%kerns that pertain to sequences of adjacent characters, and so on.
%What the metrics file
%\emph{doesn't} include is any information about the shapes
%of the characters in the font.
字体度量文件包含 \TeX\ 对每个排版字符所分配空间的信息。
即它包含各个字符的尺寸，对相邻字符的连字和紧排，等等。
字体度量文件\emph{并不}包含关于其字符的形状的任何信息。

%{\tighten
%The shape (pixel) file \xrdef{shape}
%^^{pixel file}^^{shape file}
%may be in any of several
%formats. The extension part of the name (the part after the dot)
%tells the driver which format the shape file is in.  For example,
%|cmbx12.pk| ^^{\pkfile} might be the shape file for font |cmbx12| in
%packed format, while |cmbx12.gf| ^^{\gffile} might be the shape file
%for font |cmbx12| in generic font format.
%A shape file may not be needed for a font that's resident in your
%output device.
%\par}
{\tighten
形状（像素）文件\xrdef{shape}可以有多种格式。
^^{像素文件}^^{轮廓文件}
文件的扩展名（点号之后部分）告诉驱动文件该形状文件的格式。
例如，|cmbx12| 字体的形状文件 可以是压缩格式的 |cmbx12.pk| ^^{\pkfile}，
也可以是一般格式的 |cmbx12.gf| ^^{\gffile}。
对存在于输出设备中的字体，其形状文件也许不是必需的。
\par}

\endconcept


%\conceptindex{footers}
%\concept footer
\concept 页脚

%A \defterm{footer} is material that \TeX\ puts at the bottom of every page,
%below the text of that page.
%The default footer in \plainTeX\ is a centered page number.
%Ordinarily a footer consists of a single line, which you can set by
%assigning a token list to ^|\footline| \ctsref\footline.
%See \xrefpg{bighead} for a method of producing multiline footers.
\defterm{页脚}（footer）是放在每个页面底部，位于正文之下的素材。
在 \plainTeX\ 中默认页脚是居中的页码。通常页脚只包含一行文本，
你可以通过给 ^|\footline|\ctsref\footline 指定一个记号列来设定页脚。
请参阅\xrefpg{bighead}中介绍的生成多行页脚的方法。

\endconcept

%k \vskip 0pt plus 2pt % to solve page break problem

%\concept {format file}
\concept {格式文件}

%{\tighten
%A \defterm{format file} is a file that contains an image of
%\TeX's memory in a form in which it can be reloaded quickly.
%A format file can be created with the ^|\dump| command \ctsref\dump.
%The image contains a complete record
%of the definitions (of \refterm{fonts:font}, \refterm{macros:macro}, etc.)
%that were present when the dump took place.
%By using ^|virtex|, a special ``virgin'' form of \TeX,
%you can then reload the format file at high speed and
%continue in the same state that \TeX\ was in at the time of the dump.
%The advantage of a format file over an ordinary input
%file containing the same information is that \TeX\ can load it much
%faster.
%\par}
\defterm{格式文件}（format file）是一个包含 \TeX\ 的内存映像的文件，
该文件以一种能够快速重新载入的形式存储。
格式文件可以用 ^|\dump| 命令\ctsref\dump 建立。
映像文件包含转储发生时存在的（\refterm{字体}和\refterm{宏}等）定义的完整记录。
然后利用 ^|virtex|，\TeX\ 的一种特别的“原生”形式,
你可以快速地重新载入该格式文件，并从 \TeX\ 转储时所在的状态中继续。
相对于包含相同信息的普通输入文件，格式文件的优点是 \TeX\ 能够更快地载入它。

%Format files can only be created by ^|initex|, another special
%form of \TeX\ intended just for that purpose.
%Neither |virtex| nor |initex| has any
%facilities other than the primitives built into the
%\TeX\ program itself.
格式文件仅可以用 ^|initex| 建立，|initex| 是专用于此目的的另一种 \TeX\ 形式。
除了内建于 \TeX\ 本身的原始命令，|virtex| 和 |initex| 均不包含其他任何命令。

%A ^{preloaded} form of \TeX\ is one that has a format file already
%loaded and is ready to accept user input.
%The form of \TeX\ that's called |tex|
%often has the \plainTeX\ definitions preloaded.
%(\PlainTeX\ is ordinarily  available in two other forms as well:
%as a format file and as a \TeX\ source file.
%In some environments, |tex| is equivalent to calling |virtex|
%and then loading |plain|.)
%Creating preloaded forms of \TeX\ requires a special program;
%it cannot be done using only the facilities of \TeX\ itself.
\TeX\ 的^{预载入}形式是一种已载入某个格式文件 ，并准备接收用户输入的形式。
称为 |tex| 的 \TeX\ 形式通常都预载入了 \plainTeX\ 定义。%
（\PlainTeX\ 通常还以另外两种形式出现：作为格式文件与作为\TeX\ 源码文件。
在某些环境中，|tex| 等价于调用 |virtex| 然后载入 |plain|。）%
仅仅用 \TeX\ 本身无法建立 \TeX\ 的预载入形式，它需要一个特别的程序。

\endconcept

\bookmark{2}{以G开头}
%\concept global
\concept 全局的

%A \defterm{global} definition is effective
%until the end of the
%document or until it is overridden by another definition,
%even when it occurs within a \refterm{group}.
%Thus a global definition is unaffected by group boundaries.
%You can make any definition global by prefixing it with the |\global|
%command \ctsref{\global} unless ^|\globaldefs| \ctsref\globaldefs{}
%is negative.
%^^|\global|
一个\defterm{全局的}（global）定义在文档结束前始终有效，
即使它出现在一个\refterm{编组}里面（除非它被其他定义覆盖）。
即全局定义不受编组范围的影响。
要让任何定义成为全局的，你可以在它前面加上 |\global| 命令\ctsref{\global}，
除非 ^|\globaldefs|\ctsref\globaldefs{} 为负值。
^^|\global|

%There's a special way of making a \refterm{macro} definition global.
%^^{macros//global}
%Normally you define a macro using either the |\def| command
%or the |\edef| command \ctsref{\edef}.
%^^|\edef//making global|
%^^|\def//making global|
%If you use |\gdef| or |\xdef|
%instead of |\def| and |\edef| respectively, the macro definition will
%be global.  That is, `^|\gdef|' is equivalent to `|\global\def|' and
%`^|\xdef|' is equivalent to `|\global\edef|'.
%\endconcept
还有种特殊方法将一个\refterm{宏}定义为全局的。
^^{宏//全局宏}
通常你用 |\def| 命令或者 |\edef| 命令\ctsref{\edef}来定义一个宏。
^^|\edef//变成全局的|
^^|\def//变成全局的|
如果你将 |\def| 和 |\edef| 分别换为 |\gdef| 和 |\xdef|，
这个宏定义就会是全局的。也就是说，`^|\gdef|'等价于`|\global\def|'，
而`^|\xdef|'等价于`|\global\edef|'。
\endconcept


%\concept glue
\concept 粘连

%\bix^^{stretch}
%\bix^^{shrink}
%\defterm{Glue} is blank space that can stretch or shrink.
%Glue gives \TeX\ the flexibility that it needs in order to produce
%handsome
%documents.  Glue comes in two flavors: horizontal glue and vertical glue.
%Horizontal glue occurs within \refterm{horizontal lists:horizontal list},
%while vertical glue occurs within \refterm{vertical lists:vertical list}.
%^^{horizontal lists}
%^^{vertical lists}
%You
%can produce a glue item either implicitly, e.g., with an interword space, or
%explicitly, e.g., with the ^|\hskip| command.
%^^{spaces//interword}
%\TeX\ itself produces many glue
%items as it typesets your document.
%We'll just describe horizontal glue---vertical glue is analogous.
\bix^^{伸长量}
\bix^^{收缩量}
\defterm{粘连}（glue）是可以伸长或者收缩的空白间距。
粘连给 \TeX\ 提供了生成漂亮文档所需的灵活性。
粘连有两种类型：水平粘连和竖直粘连。
水平粘连出现在\refterm{水平列表}中，而竖直粘连出现在\refterm{竖直列表}中。
^^{水平列表}
^^{竖直列表}
你可以隐式地生成一个粘连项，比如用单词间空格，
或者显式地生成一个粘连项，比如用 ^|\hskip| 命令。
^^{间隔//单词间距}
在排版文档时 \TeX\ 本身也生成很多粘连项。
这里我们只描述水平粘连——竖直粘连与之类似。

%When \TeX\ assembles a list of boxes and glue into a larger
%unit,
%^^{boxes//glue with}
%it adjusts the size of the glue to meet the space requirements of the
%larger unit.  For instance, \TeX\ ensures that the ^{right margin} of a page
%is uniform by adjusting the horizontal glue within lines.
%Similarly, it ensures that different pages have the
%same ^{bottom margin}
%by adjusting the glue between blocks of text such as paragraphs and
%math displays
%(where the change is least likely to be conspicuous).
在 \TeX\ 将一系列盒子和粘连组装成一个较大单元时，
^^{盒子//盒子与粘连}
它调整各个粘连的尺寸以适合较大单元的空间要求。
例如，为了让页面的^{右边距}保持一致，\TeX\ 调整了各行的水平粘连。
类似地，为了让各页的^{下边距}保持相同，
它调整了各个文本块比如段落和陈列公式之间的粘连%
（这种修改是最不可能引人注意的）。

%A glue item has a natural space---the size it ``wants to be''.  Glue
%also has two other attributes: its \refterm{stretch} and its
%\refterm{shrink}.  You can produce a specific amount of horizontal glue
%with the ^|\hskip| \refterm{command} \ctsref{\hskip}.  The command
%|\hskip 6pt plus 2pt minus 3pt|
%produces a horizontal glue item whose natural
%size is $6$ points, whose stretch is $2$ points, and whose shrink is
%$3$ points.  Similarly, you can produce a specific amount of vertical
%glue with the ^|\vskip| command \ctsref{\vskip}.
每个粘连项有它的自然间距——即它“所期望的”尺寸。粘连还有另外两个属性：
它的\refterm{伸长量}（stretch）和它的\refterm{收缩量}（shrink）。
你可以用^|\hskip| \refterm{命令}\ctsref{\hskip}生成特定大小的水平粘连。
命令 |\hskip 6pt plus 2pt minus 3pt| 生成一个水平粘连，
其自然尺寸为$6$点，伸长量为$2$点，收缩量为$3$点。
类似地，你可以用 ^|\vskip| 命令\ctsref{\vskip}生成特定大小的竖直粘连。

%The best way to understand what stretch and shrink are about
%is to see an example of glue at work.
%Suppose you're constructing an \refterm{hbox} from three boxes and two glue
%items, as in this picture:
%\gluepicture
%   29 {\picbox 4 \gluebox 6 4 1 6 \picbox 5 \gluebox 10 8 3 10 \picbox 4 }
%\noindent
%The units of measurement here could be points, millimeters, or anything else.
%If the hbox is allowed to assume its natural width, then each glue item in the
%box also assumes its natural width.  The total width of the hbox is then the
%sum of the widths of its parts, namely, $29$ units.
要理解什么是伸长量和收缩量，最好方法是看粘连的一个实际例子。
假设你要用三个盒子和两个粘连项构造一个\refterm{水平盒子}项目，
如下图：
\gluepicture
   29 {\picbox 4 \gluebox 6 4 1 6 \picbox 5 \gluebox 10 8 3 10 \picbox 4 }
\noindent
这里的度量单位可以是点，毫米，或其他任何单位。
如果水平盒子可以呈现它的自然宽度，
那么盒子内的每个粘连项也呈现它的自然宽度。
从而水平盒子的总宽度就是它个各部分宽度之和，即$29$点。

%Next, suppose that the hbox is required to be wider than $29$ units, say
%$35$ units.  This
%could happen, for example, if the hbox is required to occupy an entire
%line and the line width is $35$ units.
%Since the boxes can't change their width,
%\TeX\ produces the necessary extra space by making the glue items wider.
%The picture now looks like this:
%\gluepicture
%   35 {\picbox 4 \gluebox 6 4 2 8 \picbox 5 \gluebox 10 8 6 14 \picbox 4 }
%The glue items don't become wider equally; they became wider in proportion to
%their stretch.  Since the second glue item
%has twice as much stretch as the first one,
%it gets wider by four units while the first glue item gets wider by only
%two units.
%Glue can be stretched as far as necessary, although \TeX\ is
%somewhat reluctant to
%stretch it beyond the amount of stretch given in its definition.
接下来，假设这个水平盒子需要比 $29$ 单位还宽，比方说 $35$ 单位。
这是可能出现的，比如水平盒子可能需要占据行宽为 $35$ 单位的整行。
由于 \TeX\ 不可能改变盒子的宽度，
它通过增加粘连项的宽度生成所需的额外间距。
现在的图形看起来是这样的：
\gluepicture
   35 {\picbox 4 \gluebox 6 4 2 8 \picbox 5 \gluebox 10 8 6 14 \picbox 4 }
各粘连项增加的宽度并不相等；增加的宽度与它们的伸长量成比例。
由于第二个粘连项的伸长量是第一个的两倍，
它的宽度增加了四个单位，而后者只增加了两个单位。
粘连允许任意伸长，
尽管 \TeX\ 有时不愿意超出定义中给出的伸长量。

%Finally, suppose that the hbox is required to be narrower than $29$ units, say
%$25$ units.  In this case \TeX\ makes the glue items narrower.
%The picture looks like this:
%\gluepicture
%   25 {\picbox 4 \gluebox 6 4 2 5 \picbox 5 \gluebox 10 8 6 7 \picbox 4 }
%The glue items become narrower in proportion to their shrink.
%The first glue item becomes narrower by one unit, while the second glue item
%becomes narrower by three units.  Glue cannot shrink by a distance
%less than the amount of shrink
%given in its definition even though the distance it can stretch is
%unlimited.  In this important sense the shrink and
%the stretch behave differently.
最后，假设这个水平盒子需要比 $29$ 单位还窄，比如说 $25$ 单位。
此时 \TeX\ 将减少粘连项的宽度。图形看起来是这样的：
\gluepicture
   25 {\picbox 4 \gluebox 6 4 2 5 \picbox 5 \gluebox 10 8 6 7 \picbox 4 }
各粘连项减少的宽度于它们的收缩量成比例。
第一个粘连项的宽度减少了一个单位，而第二个粘连项减少了三个单位。
粘连收缩时不能超出定义中给出的收缩量，而伸长时却不受限制。
从这个重要意义上说，收缩和伸长有不同的表现。

%A good rule of thumb for glue is to set the natural size to the amount
%of space that looks best, the stretch to the largest amount of space
%that \TeX\ can add before the document starts to look bad, and the
%shrink to the largest amount of space that \TeX\ can take away before
%the document starts to look bad.  You may need to set the values by
%experiment.
有一个不错的经验法则可用于设定粘连，
即取它的自然尺寸为文档最美观时的间距大小，
取它的伸长量为文档开始变难看之前 \TeX\ 能添加的最大间距，
取它的收缩量为文档开始变难看之前 \TeX\ 能去掉的最大间距。
你也许需要通过试验确定这些值。

%You can produce glue that is infinitely stretchable  by specifying
%its stretch in units of `^|fil|', `^|fill|', or `^|filll|'.   Glue measured in
%`|fill|' is infinitely more stretchable than glue measured in `|fil|', and
%glue measured in `|filll|'  is infinitely more stretchable than glue measured
%in `|fill|'.  You should rarely have any need for `|filll|' glue.  Glue whose
%stretch is |2fil| has twice as much stretch as glue whose stretch is |1fil|,
%and similarly for the other kinds of infinitely stretchable glue.
以 `^|fil|'，`^|fill|'，或 `^|filll|' 为单位设定粘连的伸长量，
就可以生成可无限伸长的粘连。
以 `|fill|' 为单位的粘连相比以 `|fil|' 为单位的粘连有更加无限的伸长能力，
以 `|filll|' 为单位的粘连相比以 `|fill|' 为单位的粘连有更加无限的伸长能力。
你很少需要使用 `|filll|' 粘连。
伸长量为 |2fil| 的粘连，其伸长能力是伸长量为 |1fil| 的粘连的两倍，
对其他类型的可无限伸长粘连情形类似。

%When \TeX\ is
%apportioning extra space among glue items, the infinitely stretchable
%ones, if there
%are any, get all of it.  Infinitely stretchable glue is particularly useful for
%setting text flush left, flush right, or centered:
在 \TeX\ 给各个粘连项分配额外间距时，
如果存在可无限伸长的粘连，它们将分到全部间距。
可无限伸长的粘连在设定文本左对齐，右对齐或者居中时特别有用：

%\ulist\compact
%\li To set text ^{flush left}, put infinitely stretchable
%horizontal glue to the right of it.
%That glue will consume all the
%extra space that's available on the line.
%You can use the ^|\leftline| command \ctsref{\leftline}
%or the |\raggedright| command \ctsref{\raggedright} to do~this.
%\li To set text ^{flush right}, put infinitely
%stretchable horizontal glue to the left of it.
%As before, that glue will consume all the extra space on the line.
%You can use the ^|\rightline| command \ctsref{\rightline} to do~this.
%\li To set ^{centered text}, put identical infinitely stretchable
%horizontal glue items
%on both sides of it.
%These two glue items will divide all the extra space on the line
%equally between them.
%You can use the ^|\centerline| command \ctsref{\centerline} to do~this.
%\endulist
\ulist\compact
\li 要让文本^{左对齐}，可以在它右边放上一个可无限伸长的水平粘连。
这个粘连将占用该行所有可用的多余间距。
你可以用 ^|\leftline| 命令\ctsref{\leftline}或
|\raggedright| 命令\ctsref{\raggedright}达到此目的。
\li 要让文本^{右对齐}，可以在它左边放上一个可无限伸长的水平粘连。
如同上面，这个粘连将占用该行所有可用的多余间距。
你可以用 ^|\rightline| 命令\ctsref{\rightline}达到此目的。
\li 要设定^{居中文本}，可以在它两边各放上一个同样的可无限伸长的水平粘连。
这两个粘连项将平分该行的多余间距。
你可以用 ^|\centerline| 命令\ctsref{\centerline}达到此目的。
\endulist

%You can also specify infinitely shrinkable glue
%^^{glue//infinitely shrinkable}
%in a similar way.  Infinitely shrinkable glue can act as negative space.
%Note that |fil|, etc., can be used only
%to specify the stretch and shrink of glue---they can't be used to specify
%its natural size.
%\eix^^{stretch}
%\eix^^{shrink}
%\endconcept
类似地，你也可以指定可无限收缩的粘连。
^^{粘连//可无限收缩的粘连}
可无限收缩粘连可以作为负间距。
注意 |fil| 等只可用于指定粘连的伸长量和收缩量——%
它们不能用于指定自然尺寸。
\eix^^{伸长量}
\eix^^{收缩量}
\endconcept


%\conceptindex{groups}
%\concept group
\conceptindex{编组}
\concept 编组

%A \defterm{group} is a part of your manuscript that \TeX\ treats as a unit.
%You indicate a group by enclosing it in the braces
%`|{|' and `|}|' (or any other characters with the appropriate
%\refterm{category codes}).
%^^|{//starting a group|
%^^|}//ending a group|
\defterm{编组}（group）是文稿中 \TeX\ 视为一个单元的一部分。
要表示一个编组，你可以用括号 `|{|' 和 `|}|'%
（或者\refterm{类别码}合适的其他字符）将它括起来。
^^|{//开始编组|
^^|}//结束编组|

%The most important property of a group is that any nonglobal
%definition or assignment that you make inside a group disappears when
%the group ends.  For instance, if you write:
编组的重要特性在于，当一个编组结束时，
在其中所作的任何非全局的定义或赋值都消失了。假如你这样写：

%\csdisplay
%Please don't pour {\it any} more tea into my hat.
%|
%the |\it| \refterm{control sequence} causes \TeX\ to set the word
%`|any|' in italic type but does not affect the rest of the text.
%As another example, if you use the |\hsize| parameter
%\ctsref{\hsize} to change the line length within a group, the line length
%reverts to its previous value once \TeX\ has gotten past the group.
\csdisplay
Please don't pour {\it any} more tea into my hat.
|
|\it| \refterm{控制序列}让 \TeX\ 设定 `|any|' 为意大利体，
但它不会影响其他文本。
再举一个例子，如果你在编组中用 |\hsize| 命令\ctsref{\hsize}改变行宽，
在 \TeX\ 完成这个编组后，行宽将恢复为之前的取值。

%Groups are also useful as a way of controlling spacing.  For instance, if you
%write:
编组也可以作为一种控制间距的方法。举个例子，如果你这样写：

%\csdisplay
%\TeX for the Impatient and the Outpatient too.
%|
%\noindent
%you'll get:
%\display{%
%\TeX for the Impatient and the Outpatient too.
%}
%\noindent
%since the control sequence |\TeX| (which produces the \TeX\
%logo) absorbs the following space.
%What you probably want is:
%\display{%
%{\TeX} for the Impatient and the Outpatient too.
%}
%\noindent
%One way to get it is to enclose `|\TeX|' in a group:
%\csdisplay
%{\TeX} for the Impatient and the Outpatient too.
%|
%The right brace prevents the control sequence from absorbing the space.
%\endconcept
\csdisplay
\TeX for the Impatient and the Outpatient too.
|
\noindent
你将会得到下列结果：
\display{%
\TeX for the Impatient and the Outpatient too.
}
\noindent
这是由于控制序列 |\TeX|（它生成 \TeX\ 标识）吸收了其后的空格。
你所需要的也许是这样：
\display{%
{\TeX} for the Impatient and the Outpatient too.
}
\noindent
要得到这种结果，其中一种方法就是将 `|\TeX|' 括到一个编组里面：
\csdisplay
{\TeX} for the Impatient and the Outpatient too.
|
其中的右花括号阻止了控制序列吸收空格。
\endconcept


\bookmark{2}{以H开头}
%\conceptindex{hboxes}
%\concept hbox
\concept 水平盒子

%An \defterm{hbox} (horizontal box) is a \refterm{box} that \TeX\
%constructs by placing the items of a \refterm{horizontal list} one after
%another, left to right.
%^^{horizontal lists//hboxes formed from}
%An hbox, taken as a unit, is neither
%inherently horizontal nor inherently vertical, i.e., it can appear as an
%item of either a horizontal list or a \refterm{vertical list}.  You can
%construct an hbox with the |\hbox| command \ctsref{\hbox}.
%\endconcept
\defterm{水平盒子}（hbox，horizontal box）是 \TeX\
从左到右逐个放置\refterm{水平列表}的项目而构造出来的\refterm{盒子}。
^^{水平列表//组成水平盒子}
水平盒子，作为一个单元，既不是本质上水平的也不是本质上竖直的，
即它可以出现在水平列表或\refterm{竖直列表}中。
你可以用 |\hbox| 命令\ctsref{\hbox}构造水平盒子。
\endconcept


%\conceptindex{headers}
%\concept header
\concept 页眉

%A \defterm{header} is material that \TeX\ puts at the top of every page,
%above the text of that page.
%The header for a simple report
%might consist of the title on the left side of
%the page and the text ``Page $n$'' on the right side of the page.
%Ordinarily a header consists of a single line, which you can set by
%assigning a token list to ^|\headline| \ctsref\headline.
%The default \plainTeX\ header is blank.
%It's possible to produce multiline headers too; see \xrefpg{bighead} for
%how to do it.
%\endconcept
\defterm{页眉}（header）是放在每个页面顶部，位于正文之上的素材。
一个简单报告的页眉可能由左侧的标题和右侧的`第 $n$ 页''组成。
通常页眉只包含一行文本，你可以通过给 ^|\headline|\ctsref\headline 指定一个记号列来设定页眉。
在 \plainTeX\ 中默认页眉是空白的。
你也可以生成多行页眉；请参阅\xrefpg{bighead}中介绍的方法。
\endconcept


%\concept height
\concept 高度

%The \defterm{height} of a \refterm{box} is the distance that the box
%extends above its \refterm{baseline}.
%^^{boxes//height of}
%\endconcept
\refterm{盒子}的\defterm{高度}（height）是盒子在\refterm{基线}之上的距离。
^^{盒子//盒子的高度}
\endconcept


%\conceptindex{horizontal lists}
%\concept{horizontal list}
\concept{水平列表}

%A \defterm{horizontal list} is a list of items
%that \TeX\ has produced while it is
%in one of its \refterm{horizontal modes:horizontal mode}, i.e., assembling
%either a paragraph or an hbox.  See ``horizontal mode'' below.
%\endconcept
\defterm{水平列表}（horizontal list）是 \TeX\ 位于某种\refterm{水平模式}时
（即组装段落或水平盒子时）生成的一列项目。见下面的``水平模式''。
\endconcept


%\concept {horizontal mode}
\concept {水平模式}

%^^{hboxes//horizontal mode for}
%When \TeX\ is assembling a paragraph or an \refterm{hbox}, it is in one
%of two \defterm{horizontal modes}: ^{ordinary horizontal
%mode} for assembling paragraphs and ^{restricted horizontal mode} for
%assembling hboxes.  Whenever \TeX\ is in a horizontal mode its stomach
%\seeconcept{\anatomy} is constructing a \refterm{horizontal
%list} of items (boxes, glue, penalties, etc.).
%\TeX\ typesets the items in the list
%one after another, left to right.
^^{水平盒子//处于水平模式中}
在组装段落或者\refterm{水平盒子}时，
\TeX\ 位于两种\defterm{水平模式}（horizontal mode）之一:
^{普通水平模式}用于组装段落，而^{受限水平模式}用于组装水平盒子。
只要 \TeX\ 位于水平模式中，它的胃\seeconcept{\anatomy}就在构造项目%
（盒子、粘连、惩罚等）的\refterm{水平列表}。
\TeX\ 逐个排版列表中的项目，从左到右。

%A horizontal list can't contain any
%items produced by inherently vertical commands, e.g., |\vskip|.
%^^{horizontal lists//can't contain vertical commands}
水平列表不能包含任何用本质上的竖直命令，比如 |\vskip|，生成的项目。
^^{水平列表//不能包含竖直命令}

%\ulist
%\li If \TeX\ is  assembling a horizontal list in ordinary horizontal mode and
%encounters an inherently vertical command, \TeX\ ends the paragraph and
%enters \refterm{vertical mode}.
\ulist
\li 如果 \TeX\ 正在普通水平模式中组装水平列表，并碰到一个本质上的竖直命令，
它将结束当前段落并进入\refterm{竖直模式}。

%\li If \TeX\ is assembling a horizontal list in restricted horizontal
%mode and encounters an inherently vertical command, it complains.
%\endulist Two commands that you might at first think are inherently
%horizontal are in fact inherently vertical: |\halign| \ctsref{\halign}
%and |\hrule| \ctsref{\hrule}.
%^^|\hrule//inherently vertical|
%^^|\halign//inherently vertical|
%See \knuth{page~286} for a list
%of the inherently vertical commands.
\li 如果 \TeX\ 正在受限水平模式中组装水平列表，并碰到一个本质上的竖直命令，
它将报错。
\endulist 这两个命令你也许会认为是本质上水平的，实际上却是本质上竖直的：
|\halign|\ctsref{\halign}和 |\hrule|\ctsref{\hrule}。
^^|\hrule//本质上竖直的|
^^|\halign//本质上竖直的|
在\knuth{第~286~页}
\footnote{译注：或见该书中文翻译版第236页。}
中列出了所有本质上的竖直命令。

%{\tighten
%You should be aware of a subtle but important property of restricted
%horizontal mode: \emph{you can't enter restricted horizontal mode
%when you're in ordinary horizontal mode}.  What this means in practice is that
%when \TeX\ is assembling an hbox it
%won't handle paragraph-like text, i.e., text for which it does
%\refterm{line breaking}.  You can get
%around this restriction by enclosing the paragraph-like text in a
%\refterm{vbox} within the hbox.  The same method works if you want to
%put, say, a horizontal \refterm{alignment} inside an~hbox.
%}% end scope of tighten
对于受限水平模式，你要知道这个微小但是重要的特性：
\emph{你无法从普通水平模式进入受限水平模式}。%
\footnote{译注：此处似乎有误，应为“你无法从受限水平模式进入普通水平模式”。}
在实践上，这意味着在组装水平盒子时 \TeX\ 无法处理类似段落的文本，
即需要\refterm{断行:断行点}的文本。在水平盒子内部，
通过把类似段落的文本放入一个\refterm{竖直盒子}中，你就可以绕过此限制。
其他类似方法也可行，比如将一个水平\refterm{阵列}放在水平盒子内部。

\endconcept


%\concept{hyphenation}
\concept{连字}

%\TeX\ automatically hyphenates words as it is processing your document.
%\TeX\ is not eager to insert hyphens, preferring instead to find good
%line breaks by adjusting the spacing between words and moving words
%from one line to another.
%\TeX\ is clever enough to understand
%hyphens that are already in words.
在处理文档时，\TeX\ 自动将单词连字化（hyphenation）。
\TeX\ 并不急于插入连字符，它更喜欢通过调整单词间隔找到合适断行点，
从而将单词用一行移动到另一行。
\TeX\ 足够聪明，它可以理解已经出现在单词中的连字符。

%You can control \TeX's hyphenation in several ways:
%\ulist
%\li You can tell \TeX\ to
%allow a hyphen in a particular place by inserting a
%discretionary hyphen
%^^{discretionary hyphens}
%with the ^|\-| command \ctsref{\@minus}.
%\li You can tell \TeX\ how to
%hyphenate particular words throughout your document with the ^|\hyphenation|
%command \ctsref{\hyphenation}.
%\li You can enclose a word in an \refterm{hbox}, thus preventing \TeX\
%from hyphenating it.
%\li You can set the value of penalties such as |\hyphenpenalty|
%\ctsref\hyphenpenalty.
%\endulist
%\noindent If a word contains an explicit or discretionary hyphen,
%\TeX\ will never break it elsewhere.
%\endconcept
你可以用如下几种方式控制 \TeX\ 的连字：
\ulist
\li 你可以用 ^|\-| 命令\ctsref{\@minus}插入自定连字符，
以允许 \TeX\ 在特定位置连字化。
^^{自动连字符}
\li 你可以用 ^|\hyphenation| 命令\ctsref{\hyphenation}%
告诉 \TeX\ 在整个文档中如何对某个单词连字化。
\li 你可以将单词放入一个\refterm{水平盒子}中，以阻止 \TeX\ 将它连字化。
\li 你可以设定一些惩罚值，比如 |\hyphenpenalty|\ctsref\hyphenpenalty。
\endulist
\noindent 如果单词中包含显式或自定连字符，\TeX\ 将不会在其他位置断开。
\endconcept


\bookmark{2}{以I开头}
%\conceptindex{input streams}
%\concept {input stream}
\concept {输入流}

%See \conceptcit{file}.
%\endconcept
见\conceptcit{文件}。
\endconcept

%\conceptindex{insertions}
%\concept insertion
\concept 插入项

%\looseness = -1
%An \defterm{insertion} is a vertical list containing material
%to be inserted into
%a page when \TeX\ has finished building that page.\footnote
%{\tighten
%\TeX\ itself doesn't
%insert the material---it just makes the material available to
%the output routine, which is then responsible for transferring
%it to the composed page.
%^^{output routine//insertions, treatment of}
%The only immediate effect of the ^|\insert| command
%\ctsref{\insert} is to change \TeX's page break calculations so that it
%will leave room on the page for the inserted material.  Later, when
%\TeX\ actually breaks the page, it divides the inserted material into
%two groups: the material that fits on the current page and the material
%that doesn't.
%^^{page breaks//insertions at}
%The material that fits on the page is placed into box registers,
%one per insertion,
%and the material that doesn't fit is carried over to the next page.
%This procedure allows \TeX\ to do such
%things as distributing parts of a long footnote over several consecutive
%pages.} Examples of such insertions are footnotes and figures.  The
%\refterm{\plainTeX} commands for
%creating insertions are ^|\footnote|, ^|\topinsert|, |\mid!-insert|,
%^^|\midinsert|
%and ^|\pageinsert|, as well as the primitive ^|\insert| command
%itself (\pp\xrefn\footnote--\xrefn{endofinsert}).
%\TeX's mechanism for handling insertions is rather complicated;
%see \knuth{pages~122--125} for the details.
%\endconcept
\defterm{插入项}（insertion）是一个竖直列表，
它包含即将在页面建造完成后插入到该页面的素材。\footnote
{\TeX\ 本身并不插入这些素材——它仅提供这些素材给输出例行程序，
输出例行程序负责将它们移动到排版出的页面中。
^^{输出例行程序//处理插入项}
^|\insert| 命令\ctsref{\insert}仅有的直接效果是，
改变了 \TeX\ 的分页计算公式以给插入素材留出空间。
稍后，当 \TeX\ 实际分出了页面时，它将插入素材分为两组：当前页能够放下的和无法放下的。
^^{分页//分页时的插入项}
当前页能够放下的素材被放入盒子寄存器中，每个插入项放入一个寄存器，
而无法放下的素材则保留到下一页中。
此过程允许 \TeX\ 将长脚注分到连续多个页面中。}
脚注和图片就是插入项的例子。
在\refterm{\plainTeX} 中，用于创建插入项的命令有
^|\footnote|，^|\topinsert|，|\mid!-insert| 和 ^|\pageinsert|，
^^|\midinsert|
以及原始命令 ^|\insert| 本身（见~\xrefn\footnote--\xrefn{endofinsert}~页）。
\TeX\ 插入项的处理机制是相当复杂的；你可以在\knuth{第~122--125~页}
\footnote{译注：或见该书中文翻译版第95--97页。}
中看到详细介绍。
\endconcept


%\concept {interline glue}
\concept {行间粘连}

%\defterm{Interline glue} is the glue that \TeX\ inserts in front of every
%\refterm{box} in a \refterm{vertical list} except for the first one.
%The interline glue is ordinarily specified so as to maintain a constant
%distance between the baselines of the boxes.
%Its value is jointly determined by the ^|\baselineskip|,
%^|\lineskip|, and ^|\lineskiplimit| parameters \ctsref{\baselineskip}.
%\endconcept
\defterm{行间粘连}（interline glue）是 \TeX\ 在\refterm{竖直列表}的每个盒子%
（第一个盒子除外）之前插入的粘连。
通常指定行间粘连以让各盒子基线间保持相同的距离。
行间粘连的值由 ^|\baselineskip|，^|\lineskip| 和 ^|\lineskiplimit|
这三个参数合起来确定\ctsref{\baselineskip}。
\endconcept


%\conceptindex{items}
%\concept item
\concept 项目

%The term \defterm{item} is often used to refer to a component of
%a horizontal, vertical, or math  list, i.e., a list of items that
%\TeX\ is building while it is in a horizontal, vertical, or math mode.
%\endconcept
\defterm{项目}（item）这个术语常用来表示水平，竖直或数学列表
（即 \TeX\ 在水平，竖直或数学模式中建造的项目列表）的一个组成元素。
\endconcept


\bookmark{2}{以J开头}
%\conceptindex{justification}
%\concept {justified text}
\concept {对齐文本}

%\defterm{Justified text} is text that has been typeset so that both
%margins are even.  Unjustified text, on the other hand, has been typeset
%with ``ragged'' margins on one or both sides.
%Documents typed on old-fashioned typewriters almost always have
%ragged right margins.
%Although documents produced by \TeX\ are
%justified by default, you can if you wish produce documents (or
%sequences of lines) that have ^{ragged right}---or ^{ragged left}---margins.
%You can also get \TeX\ to center a sequence of lines, thus making both
%margins ragged.
%^^{centered text}
%You can use the
%^|\leftskip|, ^|\rightskip|, and  ^|\raggedright| commands
%(\pp \xrefn{\leftskip},~\xrefn{\raggedright}) for these purposes.
\defterm{对齐文本}（justified text）是两边对齐排版的文本。
而非对齐文本是单边或两边“不对齐”排版的文本。
老式打印机排版的文档几乎总是左对齐的。
虽然 \TeX\ 默认生成两边对齐的文档，
如果你需要也可以生成^{左对齐}或^{右对齐}的文档（或一些文本行）。
你也可以让 \TeX\ 将一些文本行居中，从而让两边都不对齐。
^^{居中文本}
用 ^|\leftskip|，^|\rightskip| 和 ^|\raggedright| 命令%
（第 \xrefn{\leftskip}，\xrefn{\raggedright}页）可以达到这些目的.

%When \TeX\ is producing justified text, it usually
%needs to stretch or shrink the glue within each line to make the margins
%come out even.  When \TeX\ is producing unjustified text, on the other
%hand, it usually leaves the glue within each line at its natural width.
%Many typographers prefer unjustified text because its interword
%spacing is more uniform.
%\endconcept
在生成对齐文本时，\TeX\ 通常需要伸缩各行的粘连以让两边对齐。
而在生成非对齐文本时，\TeX\ 通常让各行的粘连保持自然尺寸。
很多排印工更喜欢非对齐文本，因为它的字间距更加一致。
\endconcept


\bookmark{2}{以K开头}
%\conceptindex{kerns}
%\concept kern
\conceptindex{紧排}
\concept 紧排

%^^{spacing//adjusting with kerns}
%A \defterm{kern} indicates a change to the normal spacing between
%the items of a vertical or horizontal list.
%A kern can be either positive or negative.  By
%putting a positive kern between two items, you push them further apart
%by the amount of the kern.  By putting a negative kern between two
%items, you bring them closer together by the amount of the kern.  For
%instance, this text:
%\csdisplay
%11\quad 1\kern1pt 1\quad 1\kern-.75pt 1
%|
%produces letter pairs that look like this:
%\display{11\quad 1\kern1pt 1\quad 1\kern-.75pt 1}
%You can use kerns in vertical mode to adjust the space between
%particular pairs of lines.
^^{间隔//用紧排调整}
\defterm{紧排}（kern）表示对竖直或水平列中的项目间的距离作一定调整。
紧排可正可负。将正紧排放入两个项目间，将以该紧排的大小拉开两个项目。
而将负紧排放入两个项目间，将以该紧排的大小拉近两个项目。
例如，下列文本：
\csdisplay
11\quad 1\kern1pt 1\quad 1\kern-.75pt 1
|
将生成类似下面的几个字符对：
\display{11\quad 1\kern1pt 1\quad 1\kern-.75pt 1}
在竖直模式中可以用紧排改变特定两行的间距。

%A kern of size $d$ is very similar to a \refterm{glue} item that has
%size $d$ and no stretch or shrink.  Both the kern and the glue insert or
%remove space between neighboring items.  The essential difference is
%that \TeX\ considers two boxes with only kerns between them to be tied
%together.  That is, \TeX\ won't break a line or a page at a kern unless
%the kern is immediately followed by glue.  Bear this difference in mind
%when you're deciding whether to use a kern or a glue item for a
%particular purpose.
大小为$d$的紧排与大小为$d$且无伸缩的\refterm{粘连}非常相似。
紧排和粘连两者都在相邻项目间插入或删除一定间距。
本质区别在于，若两盒子间只有紧排，\TeX\ 将认为它们是合在一起的。
\footnote{译注：本书将“kern”翻译为“紧排”正由于这个原因，“紧”应该理解为“紧固”。}
这就是说，\TeX\ 不会在紧排处断行或者分页，除非其后跟着一个粘连。
当你决定用紧排或粘连实现某种目的时，务必记得这两者的区别。

%\TeX\ automatically inserts kerns between particular pairs of adjacent
%letters, thus adjusting the space between those letters and enhancing
%the appearance of your typeset document.
%For instance, the Computer Modern $10$-point roman font contains a kern
%for the pair `To' that brings the left edge of the `o' under the
%`T'.  Without the kern, you'd get \hbox{``T{o}p''} rather than ``Top''---%
%the difference is slight but noticeable.
%The metrics file
%(^{\tfmfile})
%for each \refterm{font} specifies the placement and size of the
%kerns that \TeX\ automatically inserts when it is setting text in that~font.
%\margin{paragraph deleted to save space; most of the material was
%already in this section.}
\TeX\ 在某些相邻的字符对之间自动插入紧排，
从而改变这些字符的间距，使得排版出的文档更加美观。
例如，在计算机现代字体的$10$点罗马字体中，
包含一个字符对`To'的紧排，将字母`o'的左边缘拉到字母`T'下边。
没有这个紧排，你将得到 \hbox{“T{o}p”} 而不是 “Top” ——%
两者的差别是微小的但却是明显的。
\TeX\ 用某个\refterm{字体}排版文本时自动插入的紧排的位置和大小，
是在该字体的度量文件（^{\tfmfile}）中指定的。
\margin{paragraph deleted to save space; most of the material was
already in this section.}

\endconcept


\bookmark{2}{以L开头}
%\concept leaders
\concept 指引线

%You can use \defterm{leaders} to fill a space with copies of
%a pattern, e.g.,
%to put repeated dots between a title and a page number in a table of contents.
%A leader is a single copy of the pattern.
%The specification of leaders contains three pieces of information:
%\olist\compact
%\li what a single leader is
%\li how much space needs to be filled
%\li how the copies of the pattern should be arranged within the space
%\endolist
利用\defterm{指引线}（leaders），你可以用某个模式的复本填充空间，
比如在目录中的用重复的点填充标题和页码之间的空间。
指引体（leader）是模式的单个复本。
要指定一个指引线，你需要给出三方面的信息：
\olist\compact
\li 单个指引体是怎样的
\li 要填充的空间有多大
\li 模式的复本在空间内应该如何组织
\endolist

%\bix^^|\leaders|
%\bix^^|\cleaders|
%\bix^^|\xleaders|
%{\tighten
%\TeX\ has three commands for specifying leaders:
%|\leaders|, \hbox{|\cleaders|}, and |\xleaders| (\xref\leaders).  The
%\refterm{argument} of each command specifies the leader.
%The command must be followed by \refterm{glue}; the size of the glue
%specifies how much space is to be filled.  The choice of command determines
%how the leaders are arranged within the space.}
\bix^^|\leaders|
\bix^^|\cleaders|
\bix^^|\xleaders|
\TeX\ 有三个用于指定指引线的命令：
|\leaders|，\hbox{|\cleaders|} 和 |\xleaders|（\xref\leaders ）。
各命令的\refterm{参量}指定了指引体。
命令之后必须是一个\refterm{粘连}；粘连的大小指定了要填充空间的大小。
命令的选择决定了指引体在空间内如何组织。

%Here's an example showing how |\leaders| works:
%\csdisplay
%\def\dotting{\leaders\hbox to 1em{\hfil.\hfil}\hfil}
%\line{The Political Process\dotting 18}
%\line{Bail Bonds\dotting 26}
%|
%Here we've put the leaders and their associated glue into a \refterm{macro}
%definition so that we can conveniently
%use them in two places. This input produces:
这里有个例子展示了 |\leaders| 的工作方式：
\csdisplay
\def\dotting{\leaders\hbox to 1em{\hfil.\hfil}\hfil}
\line{The Political Process\dotting 18}
\line{Bail Bonds\dotting 26}
|
其中我们将指引线及相关粘连放在一个\refterm{宏}定义中，
以方便我们在两个地方使用它。这个例子的输出结果是：

%\vdisplay{\advance\hsize by -\parindent
%\def\dotting{\leaders\hbox to 1em{\hfil{.}\hfil}\hfill}%
%\line{The Political Process{\dotting}18}
%\line{Bail Bonds{\dotting}26}
%}
\vdisplay{\advance\hsize by -\parindent
\def\dotting{\leaders\hbox to 1em{\hfil{.}\hfil}\hfill}%
\line{The Political Process{\dotting}18}
\line{Bail Bonds{\dotting}26}
}

%The \refterm{hbox} following |\leaders| specifies
%the leader, namely, an hbox 1\em\ wide containing a dot
%at its center.
%The space is filled with copies of this box,
%effectively filling it
%with dots whose centers are 1\em{} apart.
%The following |\hfil| (the one at the
%end of the macro definition) is glue that
%specifies the space to be filled.
%In this case it's whatever space is needed to fill out the line.
%By choosing |\leaders| rather than |\cleaders| or |\xleaders| we've insured
%that the dots on different lines line up with each other.
|\leaders| 之后的\refterm{水平盒子}指定了指引体，即包含居中点的 1\em\ 宽的水平盒子。
空间将用这个盒子的复本填充，实际上是用中心相隔 1\em{} 的点填充。
随后的 |\hfil|（宏定义末尾那个）是一个粘连，它给出所要填充空间的大小。
在这个例子中，它就是填满文本行所需的空间。
我们选择 |\leaders| 而不是 |\cleaders| 或 |\xleaders|，是为了让不同行的点相互对齐。

%In general, the space to be filled acts as a window
%on the repeated copies of the leader.
%\TeX\ inserts as many copies as possible, but some space is
%usually left over---either because of where the leaders fall
%within the window or because
%the width of the window isn't an exact multiple of the width of the
%leader.
%The difference among the three  commands is in how they arrange the leaders
%within the window and how they distribute any leftover space:
一般地，所要填充的空间就作为包含指引体的多个复本的窗体。
\TeX\ 插入尽可能多的复本，但通常会有些空间剩下——%
或者是由于指引体在窗体内的位置问题，或者是由于窗体的宽度不是指引体宽度的整数倍。
这三个命令的差异在于，在窗体内如何安排指引体和分配剩余空间：

%\ulist
%\li For |\leaders|, \TeX\ first produces a row of copies of the leader.
%It then aligns the start of this row with the left end of the innermost
%box $B$ that is to contain the result of the |\leaders| command.
%In the two-line example above, $B$ is a box produced by |\line|.
%Those leaders that fit entirely in the window are placed into $B$,
%and the leftover space at the left and right ends is left empty.
%The picture is like this:
%\vdisplay{%
%\def\dotting{\leaders\hbox to 1em{\hfil{.}\hfil}\hfill}%
%\def\pp{The Political Process}
%\line{\dotting}
%\line{\hphantom\pp\hfil$\Downarrow$\hfil\hphantom{18}}
%\vskip 4pt
%\setbox0 = \hbox{\pp}
%\setbox1 = \hbox{18}
%\dimen0 = \hsize \advance\dimen0 by -\wd0 \advance \dimen0 by -\wd1
%\advance\dimen0 by -0.8pt
%\hbadness=10000
%\line{\pp
%   \vrule\vbox{\hrule width \dimen0\vskip 2pt
%   \hbox to \dimen0{\hfil window\strut\hfil}
%   \vskip 2pt\hrule width \dimen0}%
%   \vrule 18}
%\line{\hphantom\pp\hfil$\Downarrow$\hfil\hphantom{18}}
%\vskip 2pt
%\line{\pp{\dotting}18}
%}
%\vskip\medskipamount
%{\tighten
%\noindent
%This procedure ensures that in the two-line example on the previous page,
%the dots in the two lines
%are vertically aligned (since the \refterm{reference points:reference point}
%of the hboxes produced by |\line| are vertically aligned).
%\par}
\ulist
\li 对于 |\leaders|, \TeX\ 首先生成一行指引体复本。
然后该行复本的起始位置与包含 |\leaders| 命令的最内侧盒子 $B$ 的左侧对齐。
在上面的两行例子中，$B$ 就是由 |\line| 生成的盒子。
整个落入窗体的指引体将被放入 $B$ 中，而左右两边剩下的空间将空着。图形如下：
\vdisplay{%
\def\dotting{\leaders\hbox to 1em{\hfil{.}\hfil}\hfill}%
\def\pp{The Political Process}
\line{\dotting}
\line{\hphantom\pp\hfil$\Downarrow$\hfil\hphantom{18}}
\vskip 4pt
\setbox0 = \hbox{\pp}
\setbox1 = \hbox{18}
\dimen0 = \hsize \advance\dimen0 by -\wd0 \advance \dimen0 by -\wd1
\advance\dimen0 by -0.8pt
\hbadness=10000
\line{\pp
   \vrule\vbox{\hrule width \dimen0\vskip 2pt
   \hbox to \dimen0{\hfil window\strut\hfil}
   \vskip 2pt\hrule width \dimen0}%
   \vrule 18}
\line{\hphantom\pp\hfil$\Downarrow$\hfil\hphantom{18}}
\vskip 2pt
\line{\pp{\dotting}18}
}
\vskip\medskipamount
\noindent
这个过程确保在上面的两行例子中，两行中的各个点是竖直对齐的%
（由于用 |\line| 生成的水平盒子的\refterm{基准点}是竖直对齐的）。

%\li For |\cleaders|, \TeX\ centers the leaders within the window
%by dividing the leftover space between the two ends of the window.
%The leftover space is always less than the width of a single leader.
\li 对于 |\cleaders|，\TeX\ 平分窗体两边的剩余空间以让指引线在窗体中居中。
剩余空间总是小于单个指引体的宽度。

%\li For |\xleaders|, \TeX\ distributes the
%leftover space evenly within the window.
%In other words, if the leftover space is $w$ and the
%leader is repeated  $n$ times,
%\TeX\ puts space of width $w/(n+1)$ between adjacent leaders and
%at the two ends of the leaders.
%The effect is usually to spread out the leaders a little bit.
%The leftover space for |\xleaders|, like that for |\cleaders|,
%is always less than the width of a single leader.
%\endulist
\li 对于 |\xleaders|，\TeX\ 将剩余空间在窗体内均匀分布。
也就是说，如果剩余空间是 $w$，指引体被重复 $n$ 次，
\TeX\ 将在相邻指引体中间及指引线两端填充宽度为 $w/(n+1)$ 的空间。
其效果通常是将指引体散开一点。和 |\cleaders| 类似，
|\xleaders| 的剩余空间也总是小于单个指引体的宽度。
\endulist

%So far we've assumed that the leaders consist of hboxes arranged
%horizontally.  Two variations are possible:
%\olist
%\li You can use a
%rule instead of an hbox for the leader.
%\TeX\ makes the rule as wide as necessary to extend
%across the glue (and the three commands are equivalent).
%\li You
%can produce vertical leaders that run down the page by including them in
%a \refterm{vertical list} rather than a \refterm{horizontal list}. In
%this case you need vertical glue following the leaders.
%\endolist
%\noindent
%See \knuth{pages~223--225} for the precise rules that \TeX\ uses
%in typesetting leaders.
%\eix^^|\leaders|
%\eix^^|\cleaders|
%\eix^^|\xleaders|
%\endconcept
到目前为止，我们都假定指引线由横向排列的水平盒子组成的。实际上指引线还有两个可能的变种：
\olist
\li 你可以用标线代替水平盒子作为指引体。
\TeX\ 将让标线尽可能宽以让它填满该粘连（从而这三个命令是等价的）。
\li 你可以不在\refterm{水平列表}而在\refterm{竖直列表}中使用它，
以在页面中生成向下排列的竖直指引线。在这种情形中指引线后面需要给出竖直粘连。
\endolist
\noindent
请参阅 \knuth{第~223--225~页}
\footnote{译注：或见该书中文翻译版第180--182页。}，
其中给出了 \TeX\ 用于排版指引线的精确规则。
\eix^^|\leaders|
\eix^^|\cleaders|
\eix^^|\xleaders|
\endconcept


%\conceptindex{ligatures}
%\concept ligature
\concept 连写

%A \defterm{ligature} is a single character that replaces a
%particular sequence of adjacent characters in a typeset document.
%For example, the word `|office|' is typeset as \hbox{``office''},
%not \hbox{``of{f}ice''}, by high-quality typesetting systems.
%Knowledge of ligatures is built into the
%\refterm{fonts:font} that you use, so there's nothing explicit you need do
%in order to get \TeX\ to produce them.  (You could defeat the ligature
%in ``office'', as we did just above, by writing `|of{f}ice|' in your input.)
%\TeX\ is also capable of using its ligature mechanism to typeset the
%first or last letter of a word differently than the same letter as it would
%appear in the middle of a word.
%You can defeat this effect (if you ever encounter it) by using the
%^|\noboundary| command (\xref\noboundary).
\defterm{连写}（ligature）是排版的文档中替换特定的相邻字符串的单个字符。
例如，在高质量的排版系统中，
单词 `|office|'将被排版为 \hbox{``office''}，而不是 \hbox{``of{f}ice''}。
连写信息已经嵌入在你使用的\refterm{字体}中，因此什么也不用做你就可以让\TeX\ 生成它们。%
（通过将输入写成 `|of{f}ice|' 可以取消 ``office'' 中的连写，正如我们刚才所做的。）
利用此连写机制，对单词的开头或者末尾字母，\TeX\ 也可以使用与它在单词中间时不同的方式排版。
用 ^|\noboundary| 命令（\xref\noboundary ）你可以取消这种效果（如果你曾经碰到它）。

%Sometimes you may need a ligature from a European language.
%^^{European languages}
%\TeX\ won't
%produce these automatically unless you're using a font designed for that
%language.  A number of these ligatures, e.g., `\AE', are available as
%commands (see ``Letters and ligatures for European alphabets'',
%\xref{fornlets}).
%\endconcept
有时候你会需要欧洲语言的连写。
^^{欧洲语言}
除非你使用一个针对该语言设计的字体，否则 \TeX\ 不会自动生成这些连写。
有一些连写，比如 `\AE'，可以用命令得到（见``欧洲语言字母和连写''，\xref{fornlets}）。
\endconcept


%\conceptindex{line breaks}
%\concept{line break}
\conceptindex{断行}
\concept{断行点}

%A \defterm{line break} is a place in your document where \TeX\ ends
%a line as it typesets a paragraph.
%When \TeX\ processes your document, it collects the contents of each
%paragraph in a \refterm{horizontal list}.
%When it has collected an entire paragraph,
%it analyzes the list to find what it considers to be the best possible
%line breaks.  \TeX\ associates ``^{demerits}'' with various symptoms of
%unattractive line breaks---lines that have too much or too little
%space between words, consecutive lines that end in hyphens, and so forth.  It
%then chooses the line breaks so as to minimize the total number of demerits.
%See \knuth{pages~96--101} for a full description of \TeX's line-breaking rules.
\defterm{断行点}（line break）是文档中 \TeX\ 结束一行并开始新行的位置。
在处理你的文档时，\TeX\ 将一个段落的内容收集到一个\refterm{水平列表}中。
收集完整个段落之后，它分析该列表以找到它认为最佳的断行点。
\TeX\ 附加``^{缺陷}''值给各种形态的丑陋断行点——%
单词间隔太大或太小的行，连续以连字符结尾的行，诸如此类。
然后它选择让总缺陷值最小的断行点。
请参阅\knuth{第~96--101~页}
\footnote{译注：或见该书中文翻译版第73--77页。}
中的 \TeX\ 的断行规则的完整说明。

%You can control \TeX's choice of line breaks in several ways:
%\ulist
你可以用下面几种方式控制 \TeX\ 对断行点的选择：
\ulist

%\li You can insert a \refterm{penalty} (\xref{hpenalty}) somewhere in
%the horizontal list that \TeX\ builds as it forms a paragraph.
%^^{penalties//in horizontal lists}
%A
%positive penalty discourages \TeX\ from breaking the line there, while a
%negative penalty---a bonus, in other words---encourages \TeX\ to break
%the line there.  A penalty of $10000$ or more prevents a line break,
%while a penalty of $-10000$ or less forces a line break.  You can get
%the same effects with the ^|\break| and
%^|\nobreak| commands (\pp\xrefn{hbreak},~\xrefn{hnobreak}).
\li 你可以在 \TeX\ 形成段落时构建的水平列表的某处插入\refterm{惩罚}项（\xref{hpenalty}）。
^^{惩罚//在水平列表中}
正惩罚值阻碍 \TeX\ 在该处断行，而负惩罚值——即奖励值——鼓励 \TeX\ 在该处断行。
大于或等于 $10000$ 的惩罚只阻止断行，而小于或等于 $-10000$ 强制断行。
用 ^|\break| 和 ^|\nobreak| 命令（第~\xrefn{hbreak}，\xrefn{hnobreak}~页）可以达到相同效果。

%\li You can tell \TeX\ to allow a hyphen in a particular place by
%inserting a discretionary hyphen
%^^{discretionary hyphens}
%with the |\-| command \ctsref{\@minus}, or
%otherwise control how \TeX\ hyphenates your document \seeconcept
%{hyphenation}.
%^^|\-//in line breaking|
\li 你可以用 |\-| 命令\ctsref{\@minus}插入自定连字符，以允许 \TeX\ 在特定位置连字化。
^^{自定连字符}
你也可以控制 \TeX\ 在你的文档中如何连字化\seeconcept{连字}。
^^|\-//在断行中|

%\li You can tell \TeX\ to allow a line break after a ^{solidus} (/) between
%two words by inserting ^|\slash| \ctsref{\slash}
%between them, e.g., `|fur!-longs\slash fortnight|'.
\li 你可以在两个单词间用 ^|\slash|\ctsref{\slash}插入^{斜线符号} (/)，
并允许 \TeX\ 在斜线后断行，比如 `|fur!-longs\slash fortnight|'。

%\li You can tell \TeX\ not to break a line between two particular words by
%inserting a ^{tie} (|~|) between those words.
%^^|~//in line breaking|
\li 你可以通过在两个特定单词间插入^{带子} (|~|)，以禁止 \TeX\ 在该处断行。
^^|~//在断行中|

%\li You can adjust the penalties associated with line breaking by
%assigning different values to \TeX's line-breaking
%\refterm{parameters:parameter}.
\li 你可以给 \TeX\ 的断行\refterm{参数}赋予不同的值，以调整断行时附加的惩罚值。

%\li You can enclose a word or sequence of words in an \refterm{hbox},
%thus preventing \TeX\ from breaking the line anywhere within the hbox.
%^^{hboxes//controlling line breaks}
%\endulist
\li 你可以将一个单词或一列单词放在一个\refterm{水平盒子}中，
从而阻止 \TeX\ 盒子里面的任何位置断行。
^^{水平盒子//控制断行}
\endulist

%It's useful to know the places where \TeX\ can break a line:
%\ulist
%\li at glue, provided that:
%\olist
%\li the item preceding the glue is one of the following:
%a box, a discretionary item (e.g., a discretionary hyphen),
%the end of a math formula,
%a whatsit,
%or vertical material produced by |\mark| or |\vadjust|
%or |\insert|
%\li the glue is not part of a math formula
%\endolist
%\noindent
%When \TeX\ breaks a line at glue, it makes the break at the left edge
%of the glue space and forgets about the rest of the glue.
%\li at a kern that's immediately followed by glue,
%provided that this kern isn't within a math formula
%\li at the end of a math formula that's immediately followed by glue
%\li at a penalty, even one within a math formula
%\li at a discretionary break
%\endulist
%When \TeX\ breaks a line, it discards any
%sequence of glue, kerns, and penalty items that follows the break point.
%If such a sequence is followed by the beginning of a math formula, it
%also discards any kern produced by the beginning of the formula.
%\endconcept
知道在什么地方 \TeX\ 可以断行也是有益的：
\ulist
\li 在粘连处，只要：
\olist
\li 粘连之前是下列项目之一：盒子、自定项目（比如自定连字符）、公式结尾、
小玩意或者用|\mark| 或 |\vadjust| 或 |\insert| 生成的竖直素材
\li 粘连不是数学公式的一部分
\endolist
\noindent
在粘连处断行时，\TeX\ 让断行点位于粘连的左边缘，并忽略粘连的其他部分。
\li 在紧排处，只要其后直接跟着粘连，且该紧排不在数学公式中
\li 在数学公式结尾处，只要其后直接跟着粘连
\li 在惩罚项处，即使该惩罚项在数学公式中
\li 在自定可断点处
\endulist
在断行时，\TeX\ 丢弃断点之后的任意多个粘连、紧排和惩罚项。
如果这些项目之后还是一个数学公式起点，它同样丢弃公式起点生成的任何紧排。
\endconcept


%\conceptindex{lists}
%\concept list
\concept 列表

%A \defterm{list} is a sequence of \refterm{items:item}
%(\refterm{boxes:box}, \refterm{glue}, \refterm{kerns:kern}, etc.)
%that comprise the contents of an hbox, a vbox,
%or a math formula.
%See \conceptcit{horizontal list}, \conceptcit{vertical list}.
\defterm{列表}（list）是一列用于组成水平列表、竖直列表或数学公式的\refterm{项目}%
（\refterm{盒子}、\refterm{粘连}、\refterm{紧排}等）。
请参阅\conceptcit{水平列表}，\conceptcit{竖直列表}。

\endconcept


%\concept {log file}
\concept {日志文件}

%See \conceptcit{file}.
%\endconcept
见\conceptcit{文件}。
\endconcept


\bookmark{2}{以M开头}
%\conceptindex{macros}
%\concept macro
\conceptindex{宏}
\concept 宏

%{% Use a brace here so that definitions of explanatory macros remain local.
%% The closing brace is at the end of the concept.
%A \defterm{macro} is a definition that gives a name to a pattern of
%\TeX\ input text.\footnote{More precisely, the definition gives a name
%to a sequence of tokens.} The name can be either a \refterm{control
%sequence} or an \refterm{active character}.  The pattern is called the
%``replacement text''.  The primary command for defining macros is the
%|\def| control sequence.
{% Use a brace here so that definitions of explanatory macros remain local.
% The closing brace is at the end of the concept.
\defterm{宏}（macro）是一个定义，它给出了 \TeX\ 输入文本的一种模式的名称。%
\footnote{更准确地说，该定义给出了一个记号序列的名称。}
这个名称可以是一个\refterm{控制序列}或一个\refterm{活动字符}。
其中的模式称为“替换文本”。
用于定义宏的原始命令是 |\def| 控制序列。

%\def\arctheta{\cos \theta + i \sin \theta}
%As a simple example, suppose that you have a document in which
%the sequence `$\cos \theta + i \sin \theta$' occurs many times.
%Instead of writing it out each time, you can define a macro for it:
%\csdisplay
%\def\arctheta{\cos \theta + i \sin \theta}
%|
%Now whenever you need this sequence, you can just ``call'' the macro
%by writing `|\arctheta|'
%and you'll get it.  For example, `|$e^{\arctheta}$|' will give you
%`$e^{\arctheta}$'.
\def\arctheta{\cos \theta + i \sin \theta}
举个简单例子，假设你有一个文档，
其中多次出现‘$\cos \theta + i \sin \theta$’这串字符。
为避免每次都写一遍，你可以给它定义一个宏：
\csdisplay
\def\arctheta{\cos \theta + i \sin \theta}
|
这样每次需要这串字符时，
用‘|\arctheta|’命令“调用”这个宏就可以得到它。
比如，‘|$e^{\arctheta}$|’将给出‘$e^{\arctheta}$’。

%\bix^^{macros//parameters of}
%But the real power of macros lies in the fact that a macro can have
%parameters.  When you call a macro that has parameters, you provide
%arguments that are substituted for those parameters.  For example, suppose
%you write:
%\pix\indexchar #
%\def\arc#1{\cos #1 + i \sin #1}
%\csdisplay
%\def\arc#1{\cos #1 + i \sin #1}
%|
\bix^^{宏//宏的参数}
但宏的真正威力在于它可以带有参数。
在调用一个带有参数的宏时，你给出用于替换这些参数的参量。
例如，假设你这样写：
\pix\indexchar #
\def\arc#1{\cos #1 + i \sin #1}
\csdisplay
\def\arc#1{\cos #1 + i \sin #1}
|

%The notation |#1| \xrdef{@msharp} indicates the first parameter
%of the macro, which in this case has only one parameter.  You now can
%produce a similar form, such as `$\arc{2t}$', with the macro call `|\arc
%{2t}|'.
记号 |#1| \xrdef{@msharp} 表示宏的第一个参数，
在这个例子中宏只有一个参数。
现在你可以用‘|\arc {2t}|’得到‘$\arc{2t}$’。

%More generally, a macro can have up to nine parameters, which you
%indicate as `|#1|', `|#2|', etc\null. in the macro definition.  \TeX\
%provides two kinds of parameters: delimited parameters and undelimited
%parameters.  Briefly, a delimited parameter has an \refterm{argument}
%that's delimited, or ended, by a
%specified sequence of tokens (the delimiter), while an undelimited
%parameter has an argument that doesn't need a delimiter to end it.
%First we'll explain how macros work when they have only undelimited
%parameters, and then we'll explain how they work when
%they have delimited parameters.
更一般地，一个宏最多可以有九个参数，
在宏定义中它们分别用`|#1|'，`|#2|' 等表示。
\TeX\ 提供两种类型的宏参数：定界参数和非定界参数。
简单来说，
定界参数对应一个由特定记号序列（即定界子）定界（即结束）的\refterm{参量}，
而非定界参数对应一个无需定界子结束的参量。
我们先解释只有非定界参数时宏如何运作，
然后解释包含定界参数时宏如何运作。

%^^{parameters//undelimited}
%If a macro has only undelimited parameters, those parameters must appear
%one after another in the macro definition \emph{with nothing between
%them or between the last parameter and the left brace in front of the
%replacement text}.
%A call on such a macro consists of the macro name followed by
%the arguments of the call, one for each parameter.  Each argument is
%either:
^^{参数//非定界参数}
当宏只有非定界参数时，这些参数必须依次出现在宏定义中，
\emph{在各个参数之间，以及最后一个参数和替换文本前的左花括号之间，不能有任何东西}。
对这种宏的调用由该宏的名称，以及后面跟随的各个参量组成。
每个参量对应一个参数，参量可以是

%\ulist \compact
%\li a single \refterm{token} other than a left or right brace, or
\ulist \compact
\li 不为左或右花括号的单个\refterm{记号}，或者

%\li a sequence of tokens enclosed between a left brace and
%a matching right brace.\footnote{The
%argument can have nested pairs of braces within it, and each of these
%pairs can indicate either a \refterm{group} or a further macro
%argument.}
%\endulist
\li 一个包含在配对的左右花括号之间的记号序列。%
\footnote{参量内部也可以有嵌套的配对花括号，
其中每对花括号表示一个\refterm{编组}，或者表示一个另外的宏参量。}
\endulist

%When \TeX\ encounters a macro, it expands the macro in its gullet
%\seeconcept{\anatomy}
%by substituting each argument for the corresponding
%parameter in the replacement text.  The resulting text may contain other macro
%calls.  When \TeX\ encounters such an embedded macro call, it expands
%that call immediately without looking at what follows the
%call.\footnote{In computer science terminology, the expansion is ``depth
%first'' rather than ``breadth first''.  Note that you can modify the
%order of expansion with commands such as |\expandafter|.} When \TeX's
%gullet gets to a \refterm{primitive} \refterm{command} that
%cannot be further expanded, \TeX\ passes that command to \TeX's stomach.
%The order of expansion is sometimes critical, so in order to help
%you understand it we'll give you an example of \TeX\ at work.
\TeX\ 在食道中展开它所遇到的宏\seeconcept{\anatomy}，
方法是将替换文本中的每个参数替换为它所对应的参量。
宏展开后所得到的文本中可能还包含其他宏。
当 \TeX\ 遇到这种嵌套的宏调用时，
它将立即展开此宏调用，完成后再查看后续内容。%
\footnote{用计算机科学中的术语，
宏展开是“深度优先的”，而不是“广度优先的”。
注意用类似 |\expandafter| 的命令你可以修改宏展开的顺序。}
当 \TeX\ 的食道得到无法再展开的\refterm{原始命令}时，
\TeX\ 就将该命令送入 \TeX\ 的胃。
宏展开的先后顺序有时候是至关重要的，
为帮助你理解这个问题，下面我们将给出一个例子。

%Suppose you provide \TeX\ with the following input:
%\csdisplay
%\def\a#1#2{\b#2#1\kern 2pt #1}
%\def\b{bb}
%\def\c{\char49 cc}
%\def\d{dd}
%\a\c{e\d} % Call on \a.
%|
%Then the argument corresponding to |#1| is |\c|,
%and the argument corresponding to |#2| is |e\d|.
%\TeX\ expands the macro call in the following steps:
假设你给 \TeX\ 提供如下输入：
\csdisplay
\def\a#1#2{\b#2#1\kern 2pt #1}
\def\b{bb}
\def\c{\char49 cc}
\def\d{dd}
\a\c{e\d} % Call on \a.
|
则与 |#1| 对应的参量为 |\c|，与 |#2| 对应的参量为 |e\d|。
\TeX\ 按照如下步骤展开宏调用：

%{\vskip\abovedisplayskip\obeylines % ugly
%|\b e\d\c\kern 2pt \c|
%|bbe\d\c\kern 2pt \c|
%|\d\c\kern 2pt \c|\quad(`|b|', `|b|', `|e|' sent to stomach)
%|dd\c\kern 2pt \c|
%|\c\kern 2pt \c|\quad(`|d|', `|d|' sent to stomach)
%|\char49 cc\kern 2pt \c|
%|\c|\quad(`|\char|', `|4|', `|9|', `|c|', `|c|', %
%`|\kern|', `|2|', `|p|', `|t|' sent to stomach)
%|\char49 cc|
%(`|\char49|', `|c|', `|c|' sent to stomach)
%\vskip\belowdisplayskip}
{\vskip\abovedisplayskip\obeylines % ugly
|\b e\d\c\kern 2pt \c|
|bbe\d\c\kern 2pt \c|
|\d\c\kern 2pt \c|\quad （`|b|'，`|b|'，`|e|' 送到胃里）
|dd\c\kern 2pt \c|
|\c\kern 2pt \c|\quad （`|d|'，`|d|' 送到胃里）
|\char49 cc\kern 2pt \c|
|\c|\quad （`|\char|'，`|4|'，`|9|'，`|c|'，`|c|'，%
`|\kern|'，`|2|'，`|p|'，`|t|' 送到胃里）
|\char49 cc|
（`|\char49|'，`|c|'，`|c|' 送到胃里）
\vskip\belowdisplayskip}

%\noindent Note that the letters `|b|', `|c|', `|d|', and `|e|' and the
%control sequences `|\kern|' and `|\char|' are all primitive
%commands that cannot be expanded further.
\noindent 注意字母 `|b|'，`|c|'，`|d|' 和 `|e|'，
以及控制序列 `|\kern|' 和 `|\char|' 都是无法再展开的原始命令。

%\bix^^{parameters//delimited}
%A macro can also have ``delimited parameters'', which can be mixed with
%the undelimited ones in any combination.  The idea of a delimited
%parameter is that \TeX\ finds the corresponding argument by looking for
%a certain sequence of tokens that marks the end of the argument---the
%delimiter.  That is, when \TeX\ is looking for such an argument, it
%takes the argument to be all the tokens from \TeX's current position up
%to but not including the delimiter.
\bix^^{参数//定界参数}
宏也可以包含“定界参数”，它们可以和非定界参数混合使用。
定界参数的想法是，
\TeX\ 通过寻找标记参量结束的特定记号序列（即定界子）确定对应的参量。
也就是说，在查找这种参量时，
\TeX\ 选取从当前位置到定界子之间的所有记号，不包含该定界子。

%You indicate a delimited parameter by writing `|#|$n$' ($n$
%must be between $0$
%and $9$) followed by one or more tokens that act as the delimiter.  The
%delimiter extends up to the next `|#|' or `|{|'---which makes sense
%since `|#|' starts another parameter and `|{|' starts the replacement text.
要指定一个定界参数，你可以在 `|#|$n$'（$n$ 必须在 $1$ 和 $9$ 之间）%
后面加上一个或多个充当定界子的记号。
定界子一直延续到下一个 `|#|' 或 `|{|' 为止——这是有道理的，
因为 `|#|' 开始另一个参数，而 `|{|' 开始替换文本。

%The delimiter can't be `|#|' or `|{|', so you can tell a delimited
%parameter from an undelimited one by looking at what comes after it.
定界子不能是 `|#|' 或者 `|{|'，
因而你可以从后面的字符辨别出定界参数和非定界参数。

%If the character after the parameter is `|#|' or `|{|', you've got an
%undelimited parameter; otherwise you've got a delimited one.  Note
%the difference in arguments for the two kinds of parameters---an
%undelimited parameter is matched either by a single token or by
%a sequence of tokens enclosed in braces, while a
%delimited parameter is matched by any number of tokens, even zero.
如果参数之后的字符为 `|#|' 或 `|{|'，
你得到一个非定界参数，否则你得到一个定界参数。
注意这两种参数的参量形式不同——
非定界参数匹配单个记号或者围在花括号中的记号序列，
而定界参数匹配任意多个记号，即便是零个也可以。

%An example of a macro that uses two delimited parameters is:
%\def\diet#1 #2.{On #1 we eat #2!}
%\csdisplay
%\def\diet#1 #2.{On #1 we eat #2!!}
%|
%Here the first parameter is delimited by a single space
%and the second parameter is delimited by a period.  If you write:
%\csdisplay
%\diet Tuesday turnips.
%|
%you'll get the text ``\diet Tuesday turnips.''.
%But if the delimiting tokens are enclosed in a group, \TeX\ doesn't consider
%them as delimiting.  So if you write:
%\csdisplay
%\diet {Sunday mornings} pancakes.
%|
%you'll get the text `\diet {Sunday mornings} pancakes.'
%even though there's a space between `|Sunday|' and `|morning|'.
%When you use a space as a delimiter,
%an end-of-line character ordinarily also delimits the argument
%since \TeX\ converts the end-of-line to a space before the macro
%mechanism ever sees it.
%\eix^^{parameters//delimited}
%\eix^^{macros//parameters of}
下面的例子用到了两个定界参数：
\def\diet#1 #2.{On #1 we eat #2!}
\csdisplay
\def\diet#1 #2.{On #1 we eat #2!!}
|
其中第一个参数用单个空格定界，而第二个参数用英文句号定界。
如果你这样写：
\csdisplay
\diet Tuesday turnips.
|
你将得到文本“\diet Tuesday turnips.”。
但若将定界记号放在编组中，\TeX\ 就不会将它们认作定界记号。
因此如果你这样写：
\csdisplay
\diet {Sunday mornings} pancakes.
|
即使在 ‘|Sunday|’ 和 ‘|morning|’ 之间有一个空格，
你也将得到文本‘\diet {Sunday mornings} pancakes.’。
当你将空格符作为定界子时，行尾符一般同样定界了对应的参量；
这是因为 \TeX\ 在宏机制运作之前就将行尾符都转换为空格了。
\eix^^{参数//定界参数}
\eix^^{宏//宏的参数}

%Once in a while you might need to define a macro that has `|#|' as a
%meaningful character within it.
%You're most likely to need to do this when you're defining a macro
%that in turn defines a second macro.
%What then do you do about
%the parameters of the second macro to avoid getting \TeX\ confused?
%The answer is that you write
%two `|#|'s for every one that you want
%when the first macro is expanded.  For example, suppose you
%write the macro definition:
%\def\first#1{\def\second##1{#1/##1}}
%\csdisplay
%\def\first#1{\def\second##1{#1/##1}}
%|
%Then the call `|\first{One}|' defines `|\second|' as:
%\csdisplay
%\def\second#1{One/#1}
%|
%and the subsequent call `|\second{Two}|' produces the text
%\def\second#1{One/#1}%
%`\second {Two}'.
偶尔在你所定义的宏里面需要将`|#|'用做一个有意义的字符。
当你在宏定义中实际上又定义了第二个宏时，你多半需要这样做。
怎样处理第二个宏的参数，以让 \TeX\ 不会混淆它们俩呢？
答案是，在第一个宏展开后需要一个‘|#|’的地方写上两个‘|#|’。
假如你写出下面的宏定义：
\def\first#1{\def\second##1{#1/##1}}
\csdisplay
\def\first#1{\def\second##1{#1/##1}}
|
则对‘|\first{One}|’的调用将把‘|\second|’定义为：
\csdisplay
\def\second#1{One/#1}
|
而随后的调用‘|\second{Two}|’将得到文本
\def\second#1{One/#1}%
`\second {Two}'。

%A number of commands provide additional ways of defining macros
%(see pp.~\xrefn{mac1}--\xrefn{mac2}).
%For the complete rules pertaining to macros, see \knuth{Chapter~20}.
%}% close brace at the start of the `macro' concept.
%\endconcept
还有一些命令提供了宏的其他定义方式（见第~\xrefn{mac1}--\xrefn{mac2}~页）。
在\knuth{第~20~章}中有关于宏的完整规则。
}% close brace at the start of the `macro' concept.
\endconcept


%\concept magnification
\concept 放大率

%When \TeX\ typesets your document, it multiplies all dimensions
%by a
%\refterm{magnification} factor $f/1000$,
%where $f$ is the value of the ^|\mag| parameter \ctsref\mag.
%Since the default value of |\mag| is $1000$, the normal case is that
%your document is typeset just as specified.
%Increasing the magnification is often useful when you're typesetting a document
%that will later be photoreduced.
\TeX\ 排版文档时将把所有尺寸乘以一个放大（magnification）因子 $f/1000$，
其中 $f$ 是 ^|\mag| 参数\ctsref\mag 的值。
由于 |\mag| 的默认值为 $1000$，在一般情形下文档是照常排版的。
若以后需要缩印文档，增加文档的放大率通常就比较有用。

%You can also apply magnification to a single \refterm{font} so as to get
%a smaller or larger version of that font than its ``^{design size}''.  You
%need to provide the device driver with a ^{shape file}
%\seeconcept{font} for
%each magnification of a font that you're using---%
%unless the fonts are built into your printer and your device driver
%knows about them.
%When you're defining a font with
%the |\font| command \ctsref{\font}, you can specify a magnification with
%the word `|scaled|'.  For example:
你也可以缩放一个\refterm{字体}，
以得到比它的“^{设计大小}”更小或更大的字体。
对每个使用的缩放字体，你需要提供它的^{字形文件}给设备驱动程序%
\seeconcept{字体}——
除非该字体已经内嵌在打印机中，而设备驱动程序也知道它。
在用 |\font| 命令\ctsref{\font}定义一个字体时，
你可以用单词‘|scaled|’指定放大率。比如：

%\csdisplay
%\font\largerbold = cmbx10 scaled 2000
%|
%defines `|\largerbold|' as a font that is
%twice as big as |cmbx10| (Computer Modern
%Bold Extended $10$-point) and has the character shapes
%uniformly enlarged by a factor of~$2$.
\csdisplay
\font\largerbold = cmbx10 scaled 2000
|
将 `|\largerbold|' 定义为两倍大小的 |cmbx10| 字体%
（计算机现代粗体扩展的$10$点字体），
它的各个字符形状也统一地放大了两倍。

%Many computer centers find it convenient to provide fonts scaled by a ratio
%of $1.2$, corresponding to magnification values of $1200$, $1440$, etc.
%\TeX\ has special names for these values:
%^^|\magstep|
%`|\magstep1|' for $1200$,
%`|\magstep2|' for $1440$, and so forth up to `|\magstep5|'.  The special
%value `^|\magstephalf|' corresponds to magnification by $\sqrt{1.2}$, which
%is visually halfway between `|\magstep0|' (no magnification) and
%`|\magstep1|'.  For example:
%
%\csdisplay
%\font\bigbold = cmbx10 scaled \magstephalf
%|
为方便起见，很多计算机中心提供了按$1.2$比例放大的字体，
这些字体对应的放大率为 $1200$，$1440$，等等。
在 \TeX\ 中这些放大率有特别的名称：
^^|\magstep|
`|\magstep1|' 表示 $1200$，
`|\magstep2|' 表示 $1440$，依此类推直到 `|\magstep5|'。
特殊值 `^|\magstephalf|' 对应$\sqrt{1.2}$倍的放大率，
它看上去位于`|\magstep0|'（不放大）和
`|\magstep1|' 的正中间。例如：

\csdisplay
\font\bigbold = cmbx10 scaled \magstephalf
|

%You can specify a \refterm{dimension} as it will be
%measured in the final document independent of magnification by putting
%`^|true|' in front of the unit.  For instance, `|\kern 8 true pt|'
%produces a kern of $8$ points whatever the magnification.
若想指定一个最终文档中的\refterm{尺寸}，让它不受放大率影响，
你可以在单位前面加上 `^|true|'。
例如，`|\kern 8 true pt|' 将生成 $8$ 点大小的紧排，不管放大率为多少。

\endconcept

%\concept margins
\concept 边距

%The \refterm{margins}
%of a page define a rectangle that normally
%contains the printed matter on the page.
%You can get \TeX\ to print material outside of this rectangle,
%but only by taking some explicit action that moves the material there.
%\TeX\ considers headers and footers to lie outside the margins.
页面的\refterm{边距}（margin）确定了一个矩形边框，
该边框通常包含页面的印刷内容。
你也可以让 \TeX\ 在这个边框之外印刷内容，
但你必须用某种明确方法将内容移动到那里。
\TeX\ 将页眉和页脚放在边框外面。

%The rectangle is defined in terms of its upper-left corner, its width, and
%its depth.  The location of the upper-left corner is defined by
%the ^|\hoffset|
%and ^|\voffset| parameters
%\ctsref\voffset.  The default is to place that corner one inch from the top
%and one inch from the left side of the page, corresponding to a value of
%zero for both |\hoffset| and |\voffset|.%
%\footnote{This seems to us to be an odd convention.
%It would have been more natural to have the $(0,0)$
%point for |\hoffset| and |\voffset| be at the upper-left corner of the
%paper and to have set their default values to one inch.}
%The width of the rectangle is given by ^|\hsize| and the depth by ^|\vsize|.
这个矩形边框通过它的左上角位置，宽度，以及深度来定义。
左上角位置用 ^|\hoffset| 和 ^|\voffset| \ctsref\voffset 参数来定义。
默认将这个位置放在离页面顶端和左端各一英寸的地方，
这对应于|\hoffset| 和 |\voffset| 都取值为零。%
\footnote{这个约定看起来比较奇怪。
让 |\hoffset| 和 |\voffset| 的 $(0,0)$ 点对应页面的左上角，
而将它们的默认值设置为一英寸，将会更自然一些。}
边框的宽度用 ^|\hsize| 给出，而深度用 ^|\vsize| 给出。

%The implications of these conventions are:
%\ulist\compact
%\li The left margin is given by |\hoffset|\tplus|1in|.
%\li The right margin is given by the width of the paper minus
%    |\hoffset|\tplus|1in|\tplus|\hsize|.
%\li The top margin is given by |\voffset|\tplus|1in|.
%\li The bottom margin is given by the length of the paper minus
%    |\voff!-set|\tplus|1in|\tplus|\vsize|.
%\endulist
%From this information you can see what parameters you need to
%change in order to change the margins.
这些规定给出的结果是：
\ulist\compact
\li 左边距等于 |\hoffset|\tplus|1in|。
\li 右边距等于页面宽度减去 |\hoffset|\tplus|1in|\tplus|\hsize|。
\li 上边距等于 |\voffset|\tplus|1in|。
\li 下边距等于页面长度减去 |\voff!-set|\tplus|1in|\tplus|\vsize|。
\endulist
从这些信息中你可以知道，要改变页面边距应该修改哪些参数。

%Any changes that you make to |\hoffset|, |\voffset|, or |\vsize| become
%effective the next time \TeX\ starts a page.  In other words, if you change
%them within a page, the change will affect only the \emph{following} pages.
%If you change |\hsize|, the change will become effective immediately.
%\endconcept
对 |\hoffset|，|\voffset| 或者 |\vsize| 的修改在 \TeX\ 开始新页面时才生效。
也就是说，如果你在页面中间改变它们，这些改动将只影响\emph{后面的}页面。
然而，对 |\hsize| 的修改却会立即生效。
\endconcept


%\conceptindex{marks}
%\concept mark
\concept 标记

%A \defterm{mark} is an item that you can insert into a
%horizontal, vertical, or math list and later recover from within your
%output routine.  Marks are useful for purposes such as
%keeping track of topics to appear in page headers.
%Each mark has a list of tokens---the ``^{mark text}''---associated with it.
%The ^|\mark| command \ctsref{\mark} expects such a token list as its argument,
%and appends an item containing that token list (after
%expansion) to whatever list \TeX\ is
%currently building.  The ^|\topmark|, ^|\firstmark|, and ^|\botmark| commands
%\ctsref{\topmark} can be used to retrieve various marks on a page.
%These commands are most often used in page headers and footers.
%^^{footers//marks used in}
%^^{headers//marks used in}
\defterm{标记}（mark）是可以插入水平、竖直或者数学列表中，
并在输出例行程序中还原的项目。
标记可用于记录即将出现在页眉中的内容等。
每个标记带有一列记号——即“^{标记文本}”。
^|\mark| 命令\ctsref{\mark}以这样的记号列作为参量，
并将包含这个记号列（在展开之后）的项目添加到 \TeX\ 当前构造的列表中。
^|\topmark|，^|\firstmark| 和 ^|\botmark| 命令 \ctsref{\topmark}
用于取回页面上的各种标记。
这些命令经常在页眉和页脚中用到。
^^{页脚//用于页脚的标记}
^^{页眉//用于页眉的标记}

%\margin{This example of {\tt\\mark} replaces the previous explanatory
%paragraph.}
%Here is a simplified example.
%Suppose you define a section heading macro as follows:
%\csdisplay
%\def\section#1{\medskip{\bf#1}\smallskip\mark{#1}}
%% #1 is the name of the section
%|
%^^|\mark|
%This macro, when called, will produce a section heading in boldface and
%will also record the name of the section as a mark.
%You can now define the header for each printed page
%as follows:
%\csdisplay
%\headline = {\ifodd\pageno \hfil\botmark\quad\folio
%   \else \folio\quad\firstmark\hfil \fi}
%|
%Each even (left-hand) page will now have the page number followed by the
%name of the first section on that page, while each odd (right-hand) page
%will have the page number followed by the name of the last section on
%that page.  Special cases, e.g., no sections starting on a page, will
%generally come out correctly because of how ^|\firstmark|
%and ^|\botmark| work.
\margin{This example of {\tt\\mark} replaces the previous explanatory
paragraph.}
这里有个简化的例子。假设你定义了节标题宏如下：
\csdisplay
\def\section#1{\medskip{\bf#1}\smallskip\mark{#1}}
% #1 is the name of the section
|
^^|\mark|
调用这个宏将生成粗体的节标题，并将标题名记录为一个标记。
现在你可以对每个打印页定义页眉如下：
\csdisplay
\headline = {\ifodd\pageno \hfil\botmark\quad\folio
   \else \folio\quad\firstmark\hfil \fi}
|
这样，每个偶数页（左手页）页眉是页码加上该页第一个标题名，
而每个奇数页（右手页）页眉是该页最后一个标题名加上页码。
特殊情形，比如该页没有节标题，
通常也会按照 ^|\firstmark| 和 ^|\botmark| 的规定正常显示。

%When you split a page using the |\vsplit| command \ctsref{\vsplit} you can
%retrieve the mark texts of the first and last marks of the split-off
%portion with the ^|\splitfirstmark| and ^|\splitbotmark| commands
%\ctsref{\splitfirstmark}.
在用 |\vsplit| 命令\ctsref{\vsplit}分割页面时，
用 |\splitfirstmark| 和 ^|\splitbotmark| 命令\ctsref{\splitfirstmark}%
就可以取得分割的这部分中的第一个和最后一个标记的标记文本。

%See \knuth{pages~258--260} for a more precise explanation of how
%to create and retrieve marks.
%\endconcept
在\knuth{第~258--260~页}
\footnote{译注：或见该书中文翻译版第211--213页。}
中，对如何生成和取回标记作了更准确的解释。
\endconcept


%\concept math mode
\concept 数学模式

%{\tighten
%A \defterm{math mode} is a \refterm{mode} that \TeX\ is in when it is
%building a math formula.  \TeX\ has two different math modes: ^{text
%math mode} for building a formula to be embedded within a line of text,
%and ^{display math mode} for building a formula to appear on a line by
%itself.  You indicate text math mode by enclosing the formula in
%|$|'s, and display math mode by enclosing the formula in
%|$$|'s.
%%\TeX\ will accept most \refterm{commands:command} in
%%math mode. If it encounters a command in math mode that doesn't make
%%sense in a formula, it will complain.
%An important property of both
%math modes is that \emph{input spaces don't count}.  See
%\knuth{pages~290--293} for details on how \TeX\ responds to different
%commands in math mode.
%\par}
\defterm{数学模式}（math mode）是 \TeX\ 构造数学公式时所在的\refterm{模式}。
\TeX\ 有两种数学模式：
^{文内数学模式}用于构造放在文本行中的公式，
而^{陈列数学模式}用于构造单独一行显示的公式。
括在 |$| 里面的公式表示一个文内数学公式，
而括在 |$$| 里面的公式表示一个陈列数学公式。
%\TeX\ will accept most \refterm{commands:command} in
%math mode. If it encounters a command in math mode that doesn't make
%sense in a formula, it will complain.
这两种数学模式有个重要特性，即\emph{其中的输入空格都被忽略}。
\knuth{第~290--293~页}
\footnote{译注：或见该书中文翻译版第239--242页。}
详细介绍了在数学模式中 \TeX\ 如何处理各种不同命令。

\endconcept


%\conceptindex{mathcodes}
%\concept mathcode
\conceptindex{数学码}
\concept 数学码

%A \defterm{mathcode} is a number that \TeX\ uses to identify and
%describe a math character,
%^^{math characters//described by mathcodes}
%i.e., a character that has a
%particular role in a math formula.  A mathcode conveys three pieces of
%information about a character: its \refterm{font} position, its
%\refterm{family}, and its \refterm{class}.
%Each of the $256$ possible
%input characters has a mathcode, which is defined by the \TeX\ program
%but can be changed.
\defterm{数学码}（mathcode）是一个数，\TeX\ 把这个数用来识别和描述一个数学字符，
^^{数学字符//用数学码描述}
即一个在数学公式中有特别作用的字符。
数学码表达了一个字符三个方面的信息：
它的字符位置，它所在的字体\refterm{族}，以及它所属的类。
$256$ 个可能的输入字符中每个字符都有一个数学码，
它们由 \TeX\ 程序定义，但也能被修改。

%^^{family//as part of mathcode}
%\TeX\ has sixteen families of fonts, numbered $0$--$15$.  Each
%family contains three fonts: one for \refterm{text size}, one for
%\refterm{script size}, and one for \refterm{scriptscript size}.  \TeX\
%chooses the size of a particular character, and therefore its font,
%according to the context.  The class of a character specifies its role
%in a formula (see \knuth{page~154}).  For example, the equals sign `|=|'
%is in class $3$ (Relation).  \TeX\ uses its knowledge of character
%classes when it is deciding how much space to put between different
%components of a math formula.
^^{族//作为数学码的一部分}
\TeX\ 有十六个字体族，它们用$0$ 到 $15$ 编号。
每个字体族包含三个字体：一个用于\refterm{文本尺寸}，
一个用于\refterm{标号尺寸}，另一个用于\refterm{小标号尺寸}。
\TeX\ 根据上下文选择特定字符的尺寸，从而选择它的字体。
一个字符的类指定了它在公式中扮演的角色（见\knuth{第~154~页}
\footnote{译注：或见该书中文翻译版第120页。}）。
例如，等号‘|=|’属于第$3$类（关系符号）。
\TeX\ 根据字符所属的类确定数学公式各部分的间距大小。

%The best way to understand what mathcodes are all about is to see how
%\TeX\ uses them. So we'll show you what \TeX\ does with a
%character token $t$ of \refterm{category code}~11 or~12 in a math
%formula:
要全面理解数学码，最好是看 \TeX\ 如何使用它们。
因此我们将说明，对数学公式中\refterm{类别码}为 11 或 12 的字符记号$t$，
\TeX\ 如何处理它：

%\olist\compact
%\li It looks up the character's mathcode.
%\li It determines a family $f$ from the mathcode.
%\li It determines the size $s$ from the context.
%\li It selects a font $F$ by picking the font for size $s$ in family $f$.
%\li It determines a character number $n$ from the mathcode.
%\li It selects as the character $c$ to be typeset the character
%at position $n$ of font $F$.
%\li It adjusts the spacing around $c$ according to the class of $t$ and
%the surrounding context.
%\li It typesets the character $c$.
%\endolist
\olist\compact
\li 它查找这个字符的数学码。
\li 它从数学码确定字体族$f$。
\li 它从上下文确定字符尺寸$s$。
\li 它选择第$f$族的尺寸为$s$的字体$F$.
\li 它从数学码确定字符编号$n$。
\li 它从字体$F$的位置$n$选出字符$c$作为要排版的字符。
\li 它根据$t$所属的类和上下文调整$c$周围的间距。
\li 它排版字符$c$。
\endolist

%The context dependence in
%items (3) and (7) implies that \TeX\ cannot typeset a math character
%until it has seen the entire formula containing the
%math character.  For example, in the formula
%`|$a\over b$|', \TeX\ doesn't know what size the `|a|' should be until it
%has seen the |\over|.
在(3)和(7)中的上下文相关性意味着，
\TeX\ 在排版数学字符时，要先看完该字符所在的整个公式。
比如对于公式‘|$a\over b$|’，\TeX\ 无法确定‘|a|’的尺寸，直到它看到|\over|。

%{\tighten
%The mathcode of a character is encoded according to the formula $4096c
%+ 256f + n$, where $c$ is the class of the character, $f$ is its
%\refterm{family}, and $n$ is its \refterm{\ascii\ character} code within
%the family.  You can change \TeX's interpretation of an input character
%in math mode by assigning a value to the ^|\mathcode|
%table entry \ctsref{\mathcode}
%for that character.  The character must have a
%\refterm{category code} of $11$ (letter) or $12$ (other) for \TeX\ to
%look at its |\mathcode|.
%}\par
{\tighten
字符的数学码由公式$4096c + 256f + n$ 来表示，
其中 $c$ 是字符所属的类，$f$ 是它所在的字体\refterm{族}，
而 $n$ 是它在该字体族中的\refterm{\ascii}编码。
通过对一个输入字符的 ^|\mathcode| 表格项赋值\ctsref{\mathcode}，
你可以改变数学模式中 \TeX\ 对这个字符的解释。
只有\refterm{类别码}为$11$（字母）或者$12$（其它）的字符，
\TeX\ 才会查看它的 |\mathcode|。
}\par

%^^{family//variable}
%You can define a mathematical character to have a ``variable'' family by
%giving it a class of $7$.  Whenever \TeX\ encounters that character in a
%math formula, it takes the family of the character to be the current
%value of the |\fam| parameter \ctsref{\fam}.  A variable family enables
%you to specify the font of ordinary text in a math formula.  For
%instance, if the roman characters are in family $0$, the assignment
%|\fam = 0|
%will cause ordinary text in a math formula to be set in roman type
%rather than in something else like math italic type. If the value of
%|\fam| is not in the range from $0$ to $15$, \TeX\ takes the value to be
%$0$, thus making classes $0$ and $7$ equivalent.
%\TeX\ sets |\fam| to $-1$ whenever it enters math mode.
%\endconcept
^^{族//可变族}
只要将一个数学字符分到第$7$类，你可以将它的族定义为“可变的”。
当 \TeX\ 在数学公式中遇到这种字符时，
它就将该字符的字体族取为 |\fam| 参数\ctsref{\fam}的当前值。
可变的字体族使得你可以指定数学公式中普通文本的字体。
举个例子，如果罗马字符是在第$0$族，
赋值 |\fam = 0| 将让数学公式的普通文本以罗马字体显示，
而不是用其他类似数学意大利体的字体显示。
如果 |\fam| 的值不在 $0$ 到 $15$ 的范围中，
\TeX\ 取它的值为 $0$，从而让第 $0$ 类和第 $7$ 类等价。
每次进入数学模式时 \TeX\ 都设定 |\fam| 为 $-1$。
\endconcept


%\conceptindex{mathematical units}
%\concept{mathematical unit}
\conceptindex{数学单位}
\concept{数学单位}

%A \defterm{mathematical unit}, denoted by `|mu|', is a unit of distance
%that is used to specify \refterm{glue} in math formulas.  See
%\conceptcit{muglue}.
%\endconcept
\defterm{数学单位}（mathematical unit），记为‘|mu|’，
是一个用于设定数学公式中的\refterm{粘连}大小的距离单位。
见\conceptcit{数学粘连}。
\endconcept


%\conceptindex{modes}
%\concept mode
\conceptindex{模式}
\concept 模式

%When \TeX\ is processing your input in its stomach \seeconcept{\anatomy},
%it is in one of six \defterm{modes}:
%\ulist\compact
%\li ^{ordinary horizontal mode} (assembling a paragraph)
%\li ^{restricted horizontal mode} (assembling an \refterm{hbox})
%\li ^{ordinary vertical mode} (assembling a page)
%\li ^{internal vertical mode} (assembling a \refterm{vbox})
%\li ^{text math mode} (assembling a formula that appears in text)
%\li ^{display math mode}
%(assembling a formula that appears on a line by~itself)
%^^{horizontal mode}^^{vertical mode}^^{math mode}
%\endulist
%The mode describes the kind of entity that \TeX\ is putting together.
\TeX\ 在胃中处理你的输入时\seeconcept{\anatomy}，
它总是处于六种\defterm{模式}（mode）的其中一种:
\ulist\compact
\li ^{普通水平模式}（组装段落）
\li ^{受限水平模式}（组装\refterm{水平盒子}）
\li ^{普通竖直模式}（组装页面）
\li ^{内部竖直模式}（组装\refterm{竖直盒子}）
\li ^{文内数学模式}（组装在文本中显示的公式）
\li ^{陈列数学模式}（组装单独一行显示的公式）
^^{水平模式}^^{竖直模式}^^{数学模式}
\endulist
模式描述了 \TeX\ 正在组装的实体的类型。

%Because you can embed one kind of entity within another, e.g., a vbox
%within a math formula, \TeX\ keeps track not just of one mode but of a
%whole list of modes (what computer scientists call a ``stack'').
%Suppose that \TeX\ is in mode $M$ and encounters something that
%puts it into a new mode \Mprimeperiod.  When it finishes its work in
%mode \Mprimecomma, it resumes what it was doing in mode \Mperiod.
由于你可以将某种实体嵌入另一种实体中，比如将一个竖直盒子放入数学公式中，
\TeX\ 记录的不只是一个模式，而是一整列模式（即计算机科学中所说的“栈”）。
假设 \TeX\ 在模式$M$中，然后遇到某些东西而进入新模式$M'$。
当它完成在模式$M'$的工作时，它将继续在模式$M$中的工作。

\endconcept


%\concept muglue
\concept 数学粘连

%\defterm{Muglue} is a kind of \refterm{glue} that you can use only in math
%formulas.  It is measured in ^|mu| (\refterm{mathematical
%units:mathematical unit}).
%^^{mathematical units}^^{glue//mathematical}
%One |mu| is equal to \frac1/{18} em, where
%the size of an em is taken from \refterm{family} 2 of the math fonts.
%\TeX\ automatically adjusts the size of muglue according to the context.
%For instance, a glue size of |2mu| is normally smaller within a
%subscript than it is within ordinary text.
%You must use the ^|\mskip| command to produce muglue.
%For example, `|\mskip 4mu plus 5mu|' produces mathematical glue with
%natural space of four |mu| and \refterm{stretch} of five |mu|.
\defterm{数学粘连}（muglue）是一种仅用于数学公式中的\refterm{粘连}，
它的度量单位是 ^|mu|（\refterm{数学单位}）。
^^{数学单位}^^{粘连//数学粘连}
1 |mu| 的大小与 \frac1/{18} em 相等，
而 1 em 的大小取自第$2$\refterm{族}数学字体。
\TeX\ 根据上下文自动调整 |mu| 的大小。
比如同样是 |2mu| 大小的粘连，在下标中一般就比在普通文本中小一些。
要生成数学粘连，你必须使用 ^|\mskip| 命令。
例如，‘|\mskip 4mu plus 5mu|’生成了一个自然大小为 |4mu|，
\refterm{伸长量}为|5mu| 的数学粘连。
\endconcept


\bookmark{2}{以N开头}
%\conceptindex{numbers}
%\concept number
\conceptindex{数}
\concept 数

%In \TeX, a \defterm{number} is a positive or negative integer.
%You can write a number in \TeX\ in four different ways:
%\olist\compact
%\li as an ordinary decimal integer, e.g., |52|
%\li as an octal number, e.g., |'14| ^^{octal numbers}
%\li as a hexadecimal number, e.g., |"FF0| ^^{hexadecimal numbers}
%\li as the code for an \refterm{\ascii\ character}, e.g., |`)|
%or |`\)|
%\endolist
%\noindent
%Any of these forms can be preceded by `|+|' or `|-|'.
在 \TeX\ 中，\defterm{数}（number）是指正整数或负整数。%
%\footnote{译注：在本书的翻译中，经常直接将“number”称为“整数”。}
\TeX\ 中的数可以用如下四种不同方式表示：
\olist\compact
\li 用通常的十进制整数表示，比如 |52|
\li 用八进制数表示，比如 |'14| ^^{八进制数}
\li 用十六进制数表示，比如 |"FF0| ^^{十六进制数}
\li 用字符的\refterm{\ascii}编码表示，比如 |`)| 或 |`\)|
\endolist
\noindent
上述任何一种形式都可以在前面加上 `|+|' 或者 `|-|' 。

%An octal number can have only the digits |0|--|7|.
%^^{octal numbers}
%A hexadecimal number can have digits |0|--|9| and
%|A|--|F|, representing
%values from $0$ to $15$.
%^^{hexadecimal numbers}
%You can't, alas, use lowercase letters when you write a hexadecimal number.
%If you need an explanation of octal and hexadecimal numbers,
%you'll find one on \knuth{pages~43--44}.
八进制数只能包含数字 |0|--|7|。
^^{八进制数}
而十六进制数可以包含数字 |0|--|9| 以及字母 |A|--|F|，
它们分别表示从 $0$ 到 $15$ 的数值。
^^{十六进制数}
然而，你不能用小写字母来表示十六进制数。
在\knuth{43--44~页}
\footnote{译注：或见该书中文翻译版第33--34页。}
中你可以找到八进制和十六进制数的解释。

%A decimal, octal, or hexadecimal number
%ends at the first character that can't be part of the number.
%Thus a decimal number ends when \TeX\ sees, say, a letter, even though a
%letter between `|A|' and `|F|' would not end a hexadecimal number.
%You can end a number with one or more spaces and
%\TeX\ will ordinarily ignore them.\footnote{
%When you're defining a macro that ends in a number, you should always
%put a space after that number; otherwise \TeX\ may later combine that
%number with something else.}
十进制、八进制或十六进制数都在第一个不能作为该数一部分的字符处结束。
因此，任何字母都会结束一个十进制数，
而`|A|'和`|F|'之间的字母却不能结束一个十六进制数。
你也可以用一个或多个空格结束一个数，
\TeX\ 通常将忽略这些空格。\footnote{%
在定义一个以数结尾的宏时，
你应该始终在该数后面加上空格；
否则到后面 \TeX\ 可能将该数和其他字符结合在一起。}

%The fourth form above specifies a number as the
%\minref{\ascii} code for a character.
%^^{characters//\ascii\ codes for}
%\TeX\ ignores spaces after this form of number also.
%You can write a number in this form either as |`|$c$ or as |`\|$c$.
%The second form, though longer, has the advantage that you can use it
%with \emph{any} character, even `|\|', `|%|', or `|^^M|'.
%It does have one rather technical disadvantage: when \TeX\ is expanding
%a token sequence for a command such as |\edef| or |\write|,
%^^|\edef//expansion of {\tt\\'\it c} in|
%^^|\write//expansion of {\tt\\'\it c} in|
%occurrences of `|\|$c$' within numbers will also be expanded if they can be.
%That's rarely the effect you want.
上述的第四种形式用字符的\minref{\ascii}编码表示一个数。
^^{字符//字符的 \ascii\ 码}
\TeX\ 同样忽略此形式的数后面的空格。
一个数按这种形式可以写成 |`|$c$ 或者 |`\|$c$。
第二种写法虽然长一点，
但优点在于可以用于\emph{任何}字符，
甚至是 `|\|'，`|%|' 或者 `|^^M|'。
不过它确实也有一个技术上的缺点：
比如当 \TeX\ 展开 |\edef| 或 |\write| 命令的记号序列时，
^^|\edef//在其中展开 {\tt\\'\it c}|
^^|\write//在其中展开 {\tt\\'\it c}|
出现在数中间的能展开的`|\|$c$'将同样被展开；
而这多半不是你想要的。

%The following are all valid representations of the decimal number
%$78$:
%\csdisplay
%78   +078   "4E   '116   `N   `\N
%|
下面是十进制数$78$的全部有效的表示方式：
\csdisplay
78   +078   "4E   '116   `N   `\N
|

%You can't use a number in text by itself since a number isn't
%a command.
%However, you can insert the decimal form of a number in text
%by putting a ^|\number| command (\xref\number) in front of it
%or the roman numeral form by putting a ^|\romannumeral| command
%in front of it.
你不能在文本中单独使用一个数，因为它不是命令。
但是，你可以在文本中插入一个数的十进制形式，只要将它放在 ^|\number|
命令（\xref\number ）之后；
或者它的罗马数字形式，只要将它放在 ^|\romannumeral| 命令之后。

%You can also use ^{decimal constant}s, i.e., numbers with a fractional part,
%for specifying dimensions \seeconcept{dimension}.
%A decimal constant has a ^{decimal point}, which
%can be the first character of the constant.
%You can use a comma instead of a period to represent the decimal point.
%A decimal constant can be preceded by a plus or minus sign.
%Thus `|.5in|',
%`|-3.22pt|', and `|+1,5\baselineskip|' are valid dimensions.
%You can't, however, use decimal constants
%in any context \emph{other} than as the ``factor'' part of a dimension,
%i.e., its multiplier.
你也可以用^{小数}，即带有小数部分的数，来指定一个尺寸\seeconcept{尺寸}。
小数包含一个可以在最前面的^{小数点}。
小数点的圆点也可以用逗号代替。小数之前也可以加上正号或负号。
因此 `|.5in|'，`|-3.22pt|' 和 `|+1,5\baselineskip|' 都是有效的尺寸。
但是，除了作为尺寸的“因子”，即乘数，
你不能在\emph{其他}地方使用小数。

\endconcept


\bookmark{2}{以O开头}
%\concept{ordinary mode}
\concept{普通模式}

%An \defterm{ordinary mode} is a \refterm{mode} that \TeX\ is in when it is
%assembling a paragraph into lines or assembling lines
%into a page.  See \conceptcit{horizontal mode}, \conceptcit{vertical mode}.
%\endconcept
\defterm{普通模式}（ordinary mode）是 \TeX\ 分段为行或组行为页时所在的\refterm{模式}。
见\conceptcit{水平模式}，\conceptcit{竖直模式}。
\endconcept


%\concept outer
\concept 外部的

%\bix^^{macros//outer}
%An \defterm{outer} macro is one that you can't use in certain contexts
%where \TeX\ is processing tokens at high speed.
%The purpose of making a command outer is to enable \TeX\ to catch
%errors before it's gone too far.
%When you define a macro, you can make it outer with the
%^|\outer| command \ctsref\outer.
\bix^^{宏//外部宏}
\defterm{外部的}（outer）宏是在某些 \TeX\ 高速处理记号的环境中无法使用的宏。
将一个命令定义为外部的，目的是使 \TeX\ 能够尽早捕获到错误。
在定义宏时，你可以用 ^|\outer| 命令\ctsref\outer 让它成为外部的。

%You cannot use an outer macro in any of the following contexts:
%\ulist\compact
%\li within an argument to a macro
%\li in the parameter text or replacement text of a definition
%\li in the preamble to an alignment
%\li in the unexecuted part of a conditional test
%\endulist
%\noindent
%An outer context is a context in which you can use an outer macro,
%i.e., it's any context other than the ones just listed.
在下列这些环境中，你不可以使用外部宏：
\ulist\compact
\li 在命令的参量中
\li 在宏定义的参数文本或替换文本中
\li 在阵列的导言中
\li 在条件测试的跳过部分中
\endulist
\noindent
外部环境是你可以使用外部宏的环境，即刚才列出的环境除外的环境。

%For example, the following input would be a forbidden use of an
%outer macro:
%\csdisplay
%\leftline{\proclaim Assertion 2. That which is not inner
%   is outer.}
%|
%The |\proclaim| macro (\xref{\@proclaim}) is defined in \plainTeX\
%to be outer, but it's being used here in a macro argument to |\leftline|.
%\eix^^{macros//outer}
例如，下面的输入就是外部宏的禁止用法：
\csdisplay
\leftline{\proclaim Assertion 2. That which is not inner
   is outer.}
|
|\proclaim| 宏（\xref{\@proclaim}）在 \plainTeX\ 中被定义为外部的，
但这里却将它放在 |\leftline| 的宏参量中。
\eix^^{宏//外部宏}

\endconcept


%\concept {output routine}
\concept {输出例行程序}

%When \TeX\ has accumulated
%at least enough material to fill up a page, it chooses a breakpoint
%and places the material before the breakpoint in |\box255|. It then
%calls the
%current \defterm{output routine}, which processes the material and eventually
%sends it to the \dvifile.
%^^{\dvifile//material from output routine}
%The output routine can perform further
%processing, such as inserting headers, footers, and footnotes.
%\refterm{\PlainTeX:\plainTeX} provides
%a default output routine that inserts a centered page number
%at the bottom of each page.
%By providing a different output routine you can achieve such
%effects as double-column output.
%You can think of the output routine as having a single responsibility:
%disposing of the material in |\box255| one way or another.
\TeX\ 收集足够填满页面的素材后，它选择分页点并将分页点之前的素材放在 |\box255| 中。
然后 \TeX\ 调用\defterm{输出例行程序}（output routine）%
以加工素材并最终将它送到 \dvifile 中。
^^{\dvifile//来自输出例行程序的素材}
输出例行程序可以执行进一步的加工，比如插入页眉，页脚和脚注。
\refterm{\PlainTeX:\plainTeX} 提供了一个默认的输出例行程序，
它在每个页面底部插入居中的页码。
通过提供不同的输出例行程序，你可以达到诸如双栏输出的效果。
你可以认为输出例行程序只有一个职责：
以某种方式处理掉放在 |\box255| 中的素材。

%The current output routine is defined by the value of ^|\output|
%\ctsref{\output}, which is a list of \refterm{tokens:token}.  When \TeX\
%is ready to produce a page, it just expands the token list.
当前的输出例行程序由 ^|\output|\ctsref{\output}的值定义，它是一个\refterm{记号}列。
当 \TeX\ 准备好生成页面时，它就展开该记号列。

%You can make some simple changes to the actions of the \plainTeX\
%output routine without actually modifying it.  For example, by assigning
%a list of \refterm{tokens:token} to |\headline| or
%|\footline| \ctsref{\footline} you can have \TeX\ produce a different
%header or footer than it ordinarily would.
实际上不用修改 \plainTeX\ 的输出例行程序，你就能对它的行为做出一些简单改动。
例如，通过赋予一个记号列给 |\headline| 或 |\footline|\ctsref{\footline}，%
你就可以让 \TeX\ 生成和通常情形不同的页眉或页脚。

%The output routine is also
%responsible for collecting any \refterm{insertions:insertion};
%combining those insertions and any
%``decorations'' such as headers and
%footers with the main contents of the page and packaging all
%of this material in a box; and
%eventually sending that box to the \dvifile\
%^^{\dvifile//material from output routine}
%with the ^|\shipout|
%command \ctsref{\shipout}.
%Although this is what an output routine most often does,
%a special-purpose output routine might behave differently.
%\endconcept
输出例行程序也负责收集任何\refterm{插入项}；
它将这些插入项和任何“装饰”（比如页眉页脚）合并到页面主要内容中，
并将所有这些素材包装在一个盒子里；
最后它用 ^|\shipout| 命令\ctsref{\shipout}将这个盒子送到 \dvifile 中。
^^{\dvifile//来自输出例行程序的素材}
虽然输出例行程序大多是这样运行的，但有特定用途的输出例行程序会有不同表现。
\endconcept


%\conceptindex{output streams}
%\concept {output stream}
\concept {输出流}

%\margin{This concept was out of order.}
%See \conceptcit{file}.
%\endconcept
\margin{This concept was out of order.}
见\conceptcit{文件}。
\endconcept


\bookmark{2}{以P开头}
%\conceptindex{pages}
%\concept page
\conceptindex{页面}
\concept 页面

%\TeX\ processes a document by assembling \defterm{pages} one at a time
%and passing them to the output routine.
%As it proceeds through your document, \TeX\ maintains a list of lines
%and other
%items to be placed on the page.  (The lines are actually hboxes.)
%This list is called the ``^{main vertical list}''.
%Periodically \TeX\ goes through a process called ``exercising the
%^{page builder}''.
%The items added to the main vertical list between exercises of the
%page builder are called ``^{recent contributions}''.
\TeX\ 每次一页地将你的文档组装为\defterm{页面}（page），
并将它们送往输入例行程序。
在处理文档时，\TeX\ 维持着一个由文本行和其他要放入页面的项目组成的列表。%
（这些文本行实际上是水平盒子。）
这个列表称为“^{主竖直列}”。
\TeX\ 周期性地执行称为“运行^{页面构建器}”的操作。
在运行页面构建器时添加到主竖直列的项目称为“^{备选内容}”。

%The page builder first examines the main vertical list to see if it's
%necessary to ship out a page yet, either because the items on the main
%vertical list won't all fit on the page or because of an explicit item,
%such as |\eject| \ctsref\eject, that tells \TeX\ to end the page.
%If it's not necessary to ship out a page, then the page builder is done
%for the time being.
页面构建器首先检查主竖直列，看是否有必要输出页面，
这可能由于主竖直列上的项目不能填满页面，
或者有类似 |\eject| \ctsref\eject 的显式项目让 \TeX\ 结束页面。
如果没必要输出页面，页面构建器这回的工作就完成了。

%Otherwise the page builder analyzes the main vertical
%list to find what it considers to be the best possible page break.
%It  associates penalties with various kinds of unattractive page
%breaks---a break that would leave an
%isolated line at the top or bottom of a page, a break just before a
%math display, and so forth.  It then
%chooses the least costly page break,
%where the cost of a break is increased by any penalty associated with that
%break and by the badness of the page that would result
%(see \knuth{page~111} for the cost formula).  If it finds several
%equally costly page breaks, it chooses the last one.
否则，页面构建器分析主竖直列以找到最佳的可能分页点。
它在各种不美观的分页点
——即可能导致单独一行出现在页面顶部或底部的分页点，
或者在陈列公式前的分页点，诸如此类
——添加惩罚项。
然后它选择代价最小的分页点，
其中分页代价由分页点的惩罚值以及所得页面的劣度加起来得到
（代价计算公式可以见\knuth{第~111~页}
\footnote{译注：或见该书中文翻译版第85页。}）。
如果找到多个代价相同的分页点，它选择最后一个。

%{\tighten
%Once the page builder has chosen a page break,
%it places the items on the list that are before that break
%into ^|\box255| and leaves the remaining ones for the next page.
%It then calls the output routine. |\box255| acts as a mailbox, with the
%page builder as the sender and the output routine as the receiver.
%Ordinarily the output routine processes |\box255|, adds
%other items, such as insertions, headers, and footers, to the page, and
%ships out the page to the \dvifile\
%^^{\dvifile//material from output routine}
%with a |\shipout| command.
%(Specialized output routines may behave differently.)
%From \TeX's standpoint, it doesn't matter whether or not the output
%routine ships out a page;
%the only
%responsibility of the output routine is to process |\box255| one way or
%another.
%\par}
{\tighten
一旦页面构建器选定了分页点，它就将列表中位于分页点之前的项目放入 ^|\box255|，
并把剩余项目留给下个页面。接着它调用输出例行程序。
|\box255| 充当了邮箱的角色，页面构建器为发送者，输出例行程序为接收者。
输出例行程序如常处理 |\box255|，添加其他项目比如插入项和页眉页脚到该页面，
然后用 |\shipout| 命令将页面输出到 \dvifile 。%
（有些输出例行程序可能有不同的行为。）
^^{\dvifile//来自输出例行程序的素材}%
从 \TeX\ 的角度看，输出例行程序输出或不输出页面都无所谓；
输出例行程序的惟一职责是以某种方式处理|\box255|。
\par}

%{\tighten
%It's important to realize that the best place to break a page isn't
%necessarily the last possible place to break the page.
%Penalties and other considerations may cause the page break
%to come earlier.
%Furthermore, \TeX\ appends items to the main vertical list in batches,
%not just singly.
%The lines of a paragraph are an example of such a batch.
%For these reasons the page builder usually has items left over when it
%breaks a page.
%These leftover items then form the beginning of the main vertical list
%for the next page (possibly in the middle of a batch).
%Because items are carried over from one page to another,
%you can't assume that as \TeX\ is processing
%input, the current page number accurately reflects the page on which the
%corresponding output will appear.  See \knuth{pages~110--114} for a full
%description of \TeX's page-breaking rules.
%\par}
{\tighten
认识到最佳分页点未必是最后的分页点是非常重要的。
惩罚项和其他考虑可能导致分页点出现在前面。
此外，\TeX\ 是批量地而不是逐个地添加项目到主竖直列的。
段落的各行是批量的例子。
由于这些原因页面构建器分页时通常会剩余一些项目。
这些剩余项目组成了下一页的主竖直列的开始部分
（可能在批量的中间）。
由于项目可能被从一个页面移动到另一个页面，
你无法假定 \TeX\ 处理输入时的当前页码准确表示了对应输出中显示的页码。
在 \knuth{第~110--114~页}
\footnote{译注：或见该书中文翻译版第83--88页。}
中有 \TeX\ 的分页规则的完整说明。
\par}

\endconcept


%\conceptindex{page breaks}
%\concept{page break}
\conceptindex{分页}
\concept{分页点}

%A \defterm{page break} is a place in your document where \TeX\ ends a
%page and (except at the end of the document) starts a new one.
%See \conceptcit{page} for the process that \TeX\ goes through in choosing
%a page break.
\defterm{分页点}（page break）是文档中 \TeX\
结束一个页面并（除非在文档结尾处）开始新页面的位置。
在\conceptcit{页面}中介绍了 \TeX\ 选择分页点的过程。

%You can control \TeX's choice of page breaks in several ways:
%\ulist
%\li You can insert a penalty (\xref{vpenalty})
%^^{penalties//in vertical lists}
%between two items in the main vertical list.  A positive
%penalty discourages \TeX\ from breaking the page
%there, while a negative penalty---a bonus, in other words---%
%encourages \TeX\ to break the page there.  A penalty of $10000$
%or more prevents a
%page break, while a penalty of $-10000$ or less forces a page break.
%You can get the same effects with the |\break| and
%|\nobreak| commands \ctsref{vbreak}.
你可以用以下几种方式控制 \TeX\ 对分页点的选择：
\ulist
\li 你可以插入惩罚项（\xref{vpenalty}）
^^{惩罚//在竖直列表中}
到主竖直列的两个项目之间。
正惩罚值阻碍 \TeX\ 在此处分页，
而负惩罚值——换言之，奖励值——鼓励 \TeX\ 在此处分页。
大于或等于 $10000$ 的惩罚值阻止分页，
而小于或等于 $-10000$ 的惩罚值强制分页。
你可以用 |\break| 和 |\nobreak| \ctsref{vbreak} 命令得到相同的结果。

%\li You can adjust the penalties associated with page breaking
%by assigning different values to \TeX's page-breaking
%\refterm{parameters:parameter}.
\li 你可以通过改变 \TeX\ 的分页\refterm{参数}的值来调整分页惩罚值。

%\li You can enclose a sequence of paragraphs
%or other items in the main vertical list within a \refterm{vbox},
%thus preventing \TeX\ from breaking the page anywhere within the sequence.
%\endulist
\li 你可以将主竖直列的一系列段落或者其他项目放入\refterm{竖直盒子}，
从而阻止 \TeX\ 在它们之间的任何位置分页。
\endulist

%Once \TeX\ has chosen a page break, it places the portion of the main vertical
%list that precedes the break into |\box255|.
%It then calls the current \refterm{output routine}
%to process |\box255| and eventually ships its contents to the \dvifile.
%^^{\dvifile//material from output routine}
%The output routine must
%also handle \refterm{insertions}, such as footnotes, that \TeX\ has accumulated
%while processing the page.
一旦 \TeX\ 选定了分页点，
它就将该主竖直列中位于分页点之前的内容放入 |\box255|。
接着它调用当前的\refterm{输出例行程序}处理 |\box255|，
最终输出页面内容到 \dvifile 。
^^{\dvifile//来自输出例行程序的素材}
输出例行程序还得处理 \TeX\ 加工页面时积累的\refterm{插入项}，比如脚注。

%It's useful to know the places where \TeX\ can break a page:
%\ulist
%\li At glue, provided that the item preceding the glue is
%a box, a whatsit, a mark, or an insertion.
%When \TeX\ breaks a page at glue, it makes the break at the top
%of the glue space and forgets about the rest of the glue.
%\li At a kern that's immediately followed by glue.
%\li At a penalty, possibly between the lines of a paragraph.
%\endulist
%When \TeX\ breaks a page, it discards any
%sequence of glue, kerns, and penalty items that follows the break point.
最好能知道 \TeX\ 在什么地方可以分页：
\ulist
\li 在粘连处，只要在粘连之前的项目是一个盒子，小玩意，标记，或者插入项。
当 \TeX\ 在粘连处分页时，它把分页点放在该粘连间距的顶部，并忽略该粘连的其他值。
\li 在紧排处，只要该紧排之后是一个粘连。
\li 在惩罚处，这可能出现在段落的两行之间。
\endulist
\TeX\ 分页时将丢弃分页点之后的任意多个粘连，紧排和惩罚项。

\endconcept


%\concept page builder
\concept 页面构建器

%See \conceptcit{page}.
%\endconcept
见\conceptcit{页面}。
\endconcept


%\concept {page layout}
\concept {页面布局}

%\bix^^{margins}
%\bix^^{headers}
%\bix^^{footers}
%When you're designing a document, you need to decide on its
%\defterm{page layout}: the page size,
%the margins on all four sides, the headers and footers, if any,
%that appear at the top and bottom of the page,
%and the amount of space between the body of the text and the headers or
%footers.  \TeX\ has defaults for all of these.  It assumes an $8 \frac1/2$-%
%by-$11$-inch page with margins of approximately one inch
%on all four sides, no header,
%and a footer consisting of a centered page number.
\bix^^{边距}
\bix^^{页眉}
\bix^^{页脚}
在设计文档时，你需要决定其\defterm{页面布局}（page layout）：
页面大小，四个方向的边距，页眉和页脚，
若存在的话，还有正文和页眉页脚之间的间隔大小。
对上述这些 \TeX\ 都有默认值：
它设定页面大小为 $8 \frac1/2$英寸乘$11$英寸，四个边距约为一英寸，
没有页眉，页脚是居中的页码。

%The margins are determined jointly by the four parameters
%^|\hoffset|, ^|\voffset|, ^|\hsize|, and ^|\vsize| (see
%``margins'', \xrefpg{margins},
%for advice on how to adjust them).
%\eix^^{margins}
%The header normally consists of a single line that appears at the top of each
%page, within the top margin area.  You can set it by assigning
%a \refterm{token} list to the ^|\headline| parameter (\xref{\headline}).
%Similarly,
%the footer normally consists of a single line that appears at the bottom
%of each
%page, within the bottom margin area.  You can set it by assigning
%a \refterm{token} list to the ^|\footline| parameter (\xref{\footline}).
%For example, the input:
%\csdisplay
%\headline = {Baby's First Document\dotfill Page\folio}
%\footline = {\hfil}
%|
%produces a header line like this on each page:
%\vdisplay{
%\dimen0 = \hsize
%\advance \dimen0 by -\parindent
%\hbox to \dimen0{Baby's First Document\dotfill Page 19}}
%\noindent
%and no footer line.
边距由四个参数 ^|\hoffset|，^|\voffset|，^|\hsize| 和 ^|\vsize| 共同确定
（在\xrefpg{边距}的“边距”概念中有如何调整它们的指南）。
\eix^^{边距}
页眉是在每个页面顶部的一行内容，位于上边距区域中。
通过将一个\refterm{记号}列表赋值给 ^|\headline| 参数（\xref{\headline}），
你就可以设定页眉。类似地，
页脚是在每个页面底部的一行内容，位于下边距区域中。
通过将一个\refterm{记号}列表赋值给 ^|\footline| 参数（\xref{\footline}），
你就可以设定页脚。
例如，下面的输入：
\csdisplay
\headline = {Baby's First Document\dotfill Page\folio}
\footline = {\hfil}
|
将给每个页面生成类似下面的页眉行
\vdisplay{
\dimen0 = \hsize
\advance \dimen0 by -\parindent
\hbox to \dimen0{Baby's First Document\dotfill Page 19}}
\noindent
而页脚行是空白的。

%You can use marks to place the current topic of a section
%of text into the header or footer.
%^^{marks//with headers or footers}
%See \conceptcit{mark} for an explanation of how to do this.
%\eix^^{headers}
%\eix^^{footers}
%\endconcept
利用标记，你可以将当前主题或节标题放入页眉或页脚中。
^^{标记//用于页眉和页脚}
在\conceptcit{标记}这里将详细解释如何做到这些。
\eix^^{页眉}
\eix^^{页脚}
\endconcept

%\conceptindex{paragraphs}
%\concept paragraph
\conceptindex{段落}
\concept 段落

%Intuitively, a \defterm{paragraph} is a sequence of input lines that's
%ended by a blank line, by a ^|\par| command \ctsref{\@par},
%^^|\par//ending a paragraph with|
%or by an intrinsically vertical command, such as |\vskip|.
%More precisely, a paragraph is a sequence of commands that \TeX\ processes
%in ordinary horizontal mode.
%When \TeX\ has collected an entire paragraph, it forms it into a sequence of
%lines by choosing line breaks \seeconcept{line break}.
%The result is a list of hboxes with glue, interline penalties,
%and interspersed vertical material between them.
%Each hbox is a single line, and the glue is the interline glue.
直观地，\defterm{段落}（paragraph）就是一系列输入行，
并用空行或者 ^|\par| 命令\ctsref{\@par}，
或者类似 |\vskip| 的本质上的竖直模式命令结束。
^^|\par//用于结束段落|
更准确地说，段落就是 \TeX\ 在普通水平模式中处理的一系列命令。
\TeX\ 收集整个段落的内容后，就通过选择断行点\seeconcept{断行点}将它分为多行。
得到的结果是一系列水平盒子，以及它们之间的粘连，行间惩罚和穿插的竖直素材。
其中的每个水平盒子就是一个文本行，而这些粘连就是行间粘连。

%\eject
%\TeX\ starts a paragraph when it's in a vertical mode
%and encounters an inherently horizontal command.
%In particular, it's in a vertical mode when it's just finished a paragraph,
%so the horizontal material on the line after a blank input line starts the
%next paragraph in a natural way.
%There are many kinds of inherently horizontal commands, but the most common
%kind is an ordinary character, e.g., a letter.
当 \TeX\ 在竖直模式中碰到本质上为水平模式的命令，它开始一个新段落。
特别地，在刚结束一个段落的时候，它位于竖直模式，
因此在空白输入行之后的水平素材自然就开始下一个段落。
本质上为水平模式的命令有好多种，但最常见的就是普通字符，比如一个字母。

%\looseness = -1
%The ^|\indent| and ^|\noindent| commands
%(\pp\xrefn{\indent},~\xrefn{\noindent})
%are also inherently horizontal commands that tell
%\TeX\ either to indent or not to indent the beginning of a paragraph.
%Any other horizontal command in vertical
%mode causes \TeX\ to do an implicit |\indent|.
%Once \TeX\ has started a paragraph, it's in ordinary horizontal mode.
%It first obeys any commands that are in ^|\everypar|.
%It then proceeds to collect items for the paragraph until it gets a signal
%that the paragraph is ended.
%At the end of the paragraph it
%resets the paragraph shape parameters ^|\parshape|, |\hang!-indent|,
%^^|\hangindent|
%and ^|\looseness|.
\looseness = -1
^|\indent| 和 ^|\noindent| 命令（见\xrefn{\indent},~\xrefn{\noindent}页）
也属于本质上为水平模式的命令，
它们让 \TeX\ 在段落开始缩进或不缩进。
其他水平模式命令出现在竖直模式时都会导致 \TeX\ 隐性执行 |\indent|。
一旦 \TeX\ 开始一个新段落，它就处于普通水平模式中。
它首先执行 ^|\everypar| 中的命令，
然后着手收集该段落的项目，直到它得到段落结束的信号。
在段落结尾处，它重置段落形状参数 ^|\parshape|，
|\hangindent| ^^|\hangindent| 和 ^|\looseness|。

%\TeX\ ordinarily translates a blank line into |\par|.
%It also
%inserts a |\par| into the input whenever it's in horizontal mode and
%sees an intrinsically vertical command.
%So ultimately the thing that ends a paragraph is always a |\par| command.
\TeX\ 一般将一个空行转换为一个 |\par| 命令。
当它在水平模式碰到一个本质上的竖直模式命令时，
它同样插入 |\par| 命令到输入中。
因此结束段落的最终都是一个 |\par| 命令。

%When \TeX\ receives a |\par| command, it first
%fills out\footnote{%
%More precisely, it executes the commands:
%\csdisplay
%\unskip \penalty10000 \hskip\parfillskip
%|
%thus appending items for these commands
%to the end of the current horizontal list.}
%the paragraph it's working on.
%It then breaks the paragraph into lines,
%adds the resulting list of items to the enclosing vertical list,
%and exercises the page builder
%(in the case where the enclosing vertical list is the main vertical list).
%If the paragraph was ended by an intrinsically vertical command,
%\TeX\ then executes that command.
当 \TeX\ 收到一个 |\par| 命令时，它首先填满 \footnote{%
准确地说，它执行下列这些命令：
\csdisplay
\unskip \penalty10000 \hskip\parfillskip
|
并将所得项目添加到当前竖直列的最后面。}
当前段落。接着将该段落分为多行，
并将所得结果添加到所在的竖直列中，
然后执行页面构建器（仅当所在的竖直列就是主竖直列时）。
如果该段落是用本质上为竖直模式的命令结束的，
\TeX\ 接下来将执行该命令。

\endconcept

%\conceptindex{parameters}
%\concept parameter
\conceptindex{参数}
\concept 参数

%The term \defterm{parameter} has two different meanings---it can refer
%either to a \TeX\ parameter or to a macro parameter.
\defterm{参数}（parameter）这个术语有两个不同的含义
——它可以表示 \TeX\ 参数或者表示宏参数。

%A \TeX\ parameter is a \refterm{control sequence} that names
%a value.
%The value of a parameter can be a \refterm{number}, a \refterm{dimension},
%an amount of \refterm{glue} or muglue, or a \refterm{token list}.
%For example, the ^|\parindent| parameter
%specifies the distance that \TeX\ skips at the start of an
%indented  paragraph.
\TeX\ 参数是一个\refterm{控制序列}，它是某个值的名称。
参数的值可以是\refterm{数值}，\refterm{长度}，
一定大小的\refterm{粘连}或数学粘连，或者是一个\refterm{记号列表}.
例如，^|\parindent| 参数指定了 \TeX\ 在缩进段落开头所跳过距离的大小。

%You can use the control sequence for a parameter either to retrieve the value
%of the parameter or to set that value.  \TeX\ interprets the control sequence
%as a request for a value if it appears in a context where a value is expected,
%and as an \refterm{assignment} otherwise.
%^^{assignments}
%For example:
%\csdisplay
%\hskip\parindent
%|
%produces horizontal \refterm{glue} whose natural size is given by |\parindent|,
%while:
%\csdisplay
%\parindent = 2pc  % (or \parindent 2pc)
%|
%sets |\parindent| to a length of two picas.  The assignment:
%\csdisplay
%\parindent = 1.5\parindent
%|
%uses |\parindent| in both ways.  Its effect is to multiply the value of
%|\parindent| by $1.5$.
你可以对 \TeX\ 参数的控制序列取值或赋值。
如果该控制序列出现在需要取值的地方，\TeX\ 将它解释为取值；
否则，解释为\refterm{赋值}。
^^{赋值}
例如：
\csdisplay
\hskip\parindent
|
生成一个自然大小为 |\parindent| 的水平\refterm{粘连}，而
\csdisplay
\parindent = 2pc  % (or \parindent 2pc)
|
设置 |\parindent| 等于两派卡的长度。而下列赋值：
\csdisplay
\parindent = 1.5\parindent
|
用两种方式使用 |\parindent|。其结果是将 |\parindent| 的值乘以 $1.5$ 倍。

%You can think of a parameter as a built-in \refterm{register}.
%^^{registers//parameters as}
%You'll find a complete list of the \TeX\ parameters on \knuth{pages~272--275}.
你可以将 \TeX\ 参数视为内置的\refterm{寄存器}。
^^{寄存器//作为参数}
在\knuth{第~272--275~页}
\footnote{译注：或见该书中文翻译版第223--226页。}
中你可以找到 \TeX\ 参数的完整列表。

%A \refterm{macro} parameter is a placeholder for text that is to be
%plugged into the definition of a macro.  See \conceptcit{macro}
%for more information about this kind of parameter.
\refterm{宏}参数是一个占位符，用于插入文本到宏定义中。
在\conceptcit{宏}这里有这类参数的更多信息。

\endconcept


%\conceptindex{penalties}
%\concept penalty
\conceptindex{惩罚}
\concept 惩罚

%A \defterm{penalty} is an item that you can include in a
%horizontal, vertical, or math list
%in order to discourage \TeX\ from breaking the list
%at that point or encourage \TeX\ to break the list there.
%^^{horizontal lists//penalties in}
%^^{vertical lists//penalties in}
%A positive penalty indicates a bad break point, while
%a negative penalty indicates a good break point.
%Breaking an
%ordinary horizontal
%list produces a \refterm{line break}, while breaking an
%ordinary vertical list produces
%a \refterm{page break}.
%(A penalty has no effect in restricted horizontal or
%internal vertical \refterm{mode}.)
\defterm{惩罚}是一个你可以放在水平、竖直或数学列表中的项目，
用于阻碍或鼓励 \TeX\ 在此处断开该列表。
^^{水平列表//水平列表中的惩罚}
^^{竖直列表//竖直列表中的惩罚}
正惩罚值表示一个糟糕断开点，而负惩罚值表示一个良好断开点。
断开普通水平列生成一个\refterm{断行点}，
而断开普通竖直列生成一个\refterm{分页点}。%
（在限制水平\refterm{模式}或内部竖直模式的惩罚项无效。）

%You can use the
%|\penalty| command (\pp\xrefn{hpenalty},~\xrefn{vpenalty})
%to insert a penalty explicitly.
%A penalty of $10000$ or more prevents a break, while a penalty of
%$-10000$  or less forces a break.
%\endconcept
你可以用 |\penalty| 命令（见\xrefn{hpenalty},~\xrefn{vpenalty}\pp ）
直接插入一个惩罚项。
大于或等于 $10000$ 的惩罚值阻止断开。
而小于或等于 $-10000$ 的惩罚值强制断开。
\endconcept


\concept{\plainTeX}

%\defterm{\PlainTeX} is the form of \TeX\ described in this
%book and in \texbook.  \PlainTeX\ is part of the standard \TeX\
%system, so documents that use only the facilities of \plainTeX\ can
%usually be transferred from one installation to another without
%difficulty.
\defterm{\PlainTeX} 是本书和 \texbook\ 中所描述的 \TeX\ 形式。
\PlainTeX\ 包含在标准 \TeX\ 系统中，
因此仅使用 \plainTeX\ 的文档通常很容易从一个 \TeX\ 系统转移到另一个中。

%\PlainTeX\ consists of the \refterm{primitive} commands together with a
%large collection of macros and
%other definitions.  These additional definitions are given in
%\knuth{Appendix~B}.  They should also be in the file |plain.tex|
%somewhere in your computer system.
%\endconcept
\PlainTeX\ 由\refterm{原始命令}，加上大量的宏和其他定义组成。
在\knuth{附录~B}中给出了这些附加定义。
它们应该同样包含在你的计算机系统的某个 |plain.tex| 文件中。
\endconcept


%\concept{primitive}
\concept{原始的}

%A \defterm{primitive} \refterm{command} is one whose definition is built
%into the \TeX\ computer program.  In contrast, a command that is not
%primitive is defined by a \refterm{macro} or some other form of
%definition written in \TeX\ itself.  The commands in \refterm{\plainTeX}
%consist of the primitive commands together with
%other commands defined in terms of the
%primitive ones.
%\endconcept
\defterm{原始的}（primitive）命令是在 \TeX\ 程序内部就定义好的命令。
作为对比，非原始命令或者是从\refterm{宏}定义得到的，
或者是从 \TeX\ 编写的其他形式的定义得到的。
\refterm{\PlainTeX} 的命令由原始命令加上用原始命令定义的其他命令组成。
\endconcept

\bookmark{2}{以R开头}
%\concept {reference point}
\concept {基准点}

%^^{baselines}
%^^{boxes//reference point of}
%The \defterm{reference point} of a \refterm{box} is the point where the
%left edge of the box intersects its \refterm{baseline}.  When \TeX\ is
%processing a \refterm{horizontal:horizontal list} or \refterm{vertical
%list}, it uses the reference points of the boxes in the list to line up
%those boxes horizontally or vertically \seeconcept{box}.
%\endconcept
^^{基线}
^^{盒子//盒子的基准点}
\refterm{盒子}的\defterm{基准点}（reference point）是盒子左边缘与\refterm{基线}的交点。
在处理\refterm{水平列表}或\refterm{竖直列表}时，
\TeX\ 用列表中各盒子的基准点水平或竖直对齐这些盒子\seeconcept{盒子}。
\endconcept

%\conceptindex{registers}
%\concept register
\concept 寄存器

%A \defterm{register} is a named location for storing a value.
%It is much like a variable in a programming language.
%\TeX\ has five kinds of registers, as shown in the following table:
\defterm{寄存器}（register）是用于存储数值的命名位置。
它很像编程语言中的一个变量。\TeX\ 有五种寄存器，如下表所示：

%\vdisplay{\tabskip 10pt\halign{\tt #\hfil &#\hfil\cr
%{\it Register type}&{\it Contents}\cr
%box&a \refterm{box} \idxref{box registers}\cr
%count&a \refterm{number} \idxref{count registers}\cr
%dimen&a \refterm{dimension} \idxref{dimension registers}\cr
%muskip&\refterm{muglue} \idxref{muglue registers}\cr
%skip&\refterm{glue} \idxref{glue registers}\cr
%toks&a \refterm{token} list\idxref{token registers}\cr}}
\vdisplay{\tabskip 10pt\halign{\tt #\hfil &#\hfil\cr
{\it 寄存器类型}&{\it 存储内容}\cr
box&一个\refterm{盒子} \idxref{盒子寄存器}\cr
count&一个\refterm{数} \idxref{计数寄存器}\cr
dimen&一个\refterm{尺寸} \idxref{尺寸寄存器}\cr
muskip&\refterm{数学粘连} \idxref{数学粘连寄存器}\cr
skip&\refterm{粘连} \idxref{粘连寄存器}\cr
toks&一个\refterm{记号}列 \idxref{记号寄存器}\cr}}

%The registers of each type are numbered from $0$ to $255$.
%You can access register $n$ of category $c$ by using the form `|\|$cn$',
%e.g., |\muskip192|.
%You can use a register
%anywhere that information of the appropriate type is called for.  For
%instance, you can use |\count12|
%in any context calling for a number or |\skip0|
%in any context calling for glue.
每种类型的寄存器都从 $0$ 到 $255$ 编号。
要存取第 $n$ 个类型为 $c$ 的寄存器，你可以用 `|\|$cn$' 这种形式，比如 |\muskip192|。
寄存器可以用在任何需要相应类型信息的地方。例如，
你可以在需要一个数的地方使用 |\count12|，或者在需要粘连的地方使用 |\skip0|。

%You put information into a register by \refterm{assigning:assignment}
%something to it:
要将信息放入寄存器中，你可以给它\refterm{赋值}：

%\csdisplay
%\setbox3 = \hbox{lagomorphs are not mesomorphs}
%\count255 = -1
%|
%The first assignment constructs an hbox and assigns it to
%box register~$3$.
%You can
%subsequently use `|\box3|' wherever a box is called for, and you will
%get just that hbox.\footnote{But note carefully: using a box register
%also empties it so that its contents become void.  The other kinds of
%registers don't behave that way. You can use the |\copy| command
%\ctsref{\copy} to retrieve the contents of a box register without
%emptying it.}
%The second assignment assigns $-1$ to count register~$255$.
\csdisplay
\setbox3 = \hbox{lagomorphs are not mesomorphs}
\count255 = -1
|
第一个赋值构造一个水平盒子并把它分配给 $3$ 号盒子寄存器。
此后你可以在需要盒子的地方用 `|\box3|' 得到该盒子。
\footnote{但是要注意：使用盒子寄存器的同时也清空了该寄存器，
从而它的内容变为空白。其他类型的寄存器不会这样。
你可以用|\copy| 命令\ctsref{\copy}获取盒子寄存器的内容而不清空它。}
第二个赋值将 $-1$ 分配给 $255$ 号计数寄存器。

%A register of a given type, e.g., a glue register, behaves just like
%a parameter of that type.
%^^{parameters//like registers}
%You retrieve its value or assign to it
%just as you would with a \refterm{parameter}.
%Some \TeX\ parameters, e.g., |\pageno|,
%are implemented as registers, in fact.
给定类型的寄存器，比如粘连寄存器，就像该类型的参数一样。
^^{参数//如同寄存器}
你可以如同\refterm{参数}那样获取或赋予它的值。
有些 \TeX\ 参数，比如 |\pageno|，实际上就是作为寄存器实现的。

%\PlainTeX\
%uses many registers for its own purposes, so you should not just
%pick an arbitrary
%register number when you need a register.  Instead you should ask
%\TeX\ to reserve a register by using one of the commands
%^|\newbox|, ^|\newcount|, ^|\newdimen|, ^|\newmuskip|, ^|\newskip|,
%or ^|\newtoks|
%\ctsref{\@newbox}.  These commands are outer, so you can't
%use them in a macro definition.
%If you could,
%you'd use up a register every time the macro was called and probably run out
%of registers before long.
\PlainTeX\ 用了很多寄存器来实现自己的目标，因此在需要寄存器时你不能随意选择一个来用。
你应该用下列这些命令之一让 \TeX\ 给你保留一个寄存器：^|\newbox|、
^|\newcount|、^|\newdimen|、^|\newmuskip|、^|\newskip| 或 ^|\newtoks|\ctsref{\@newbox}。
这些命令是外部的，因此你不能在宏定义中使用它们。
要是可以这样做，每次调用宏时就会用掉一个寄存器，可能很快就用完所有寄存器。

%Nonetheless you can with some caution use any register temporarily
%within a \refterm{group}, even one that \TeX\ is using for something
%else.
%After \TeX\ finishes executing the commands in a group,
%it restores the contents of every register
%to what they were before it started executing the group.
%When you use an explicitly numbered register inside a group,
%you must be sure that the register isn't modified by any
%\refterm{macro}
%that you might call within the group.
%Be especially careful
%about using arbitrary registers in a group that calls macros
%that you didn't write yourself.
即便如此，只需谨慎一点你就可以在\refterm{编组}内部临时使用寄存器，
甚至是 \TeX\ 在其他地方用到的寄存器。
在执行完编组内的命令后，\TeX 将每个寄存器的内容重置为开始执行编组前的内容。
在编组内部使用显式编号的寄存器时，
你必须确保该寄存器不会被你在编组内调用的\refterm{宏}所修改。
如果编组内调用了非你所写的宏，在其中使用任意寄存器时需要特别小心。

%{\tighten
%\TeX\ reserves certain registers for special purposes: |\count0| through
%|\count9| for page numbering information and
%^^{page numbering}
%^|\box255| for the contents
%of a page just before it is offered to the \refterm{output routine}.
%Registers |\dimen0|--|\dimen9|, |\skip0|--|\skip9|,
%|\muskip0|--|\mu!-skip9|, |\box0|--|\box9|,
%and the |255| registers other than |\box255|
%are generally available as ``scratch'' registers.
%Thus \plainTeX\ provides only one scratch register, |\count255|, for
%counts.
%See \knuth{pages~122 and 346} for conventions to follow
%in choosing register numbers.
%\par}
\TeX\ 将某些寄存器保留作特别用途：|\count0| 到
|\count9| 用作页面编号信息，而
^^{页码}
^|\box255| 用作送到\refterm{输出例行程序}之前的页面内容。
寄存器 |\dimen0|--|\dimen9|、|\skip0|--|\skip9|、|\muskip0|--|\mu!-skip9|、
|\box0|--|\box9| 和 |\box255| 除外的 |255| 号寄存器一般用作“临时”寄存器。
也就是说 \plainTeX\ 仅提供一个用于计数的临时寄存器 |\count255|。
请参阅 \knuth{第~122 和 346~页}
\footnote{译注：或见该书中文翻译版第95页。}，
其中有选择寄存器编号时要遵守的约定。

%You can examine the contents of registers during a \TeX\ run with the
%^|\showthe| command \ctsref\showthe, e.g., with `|\showthe\dimen0|'.
%\endconcept
要在 \TeX\ 运行时检查一个寄存器的内容，
你可以用 ^|\showthe| 命令\ctsref\showthe ，比如 `|\showthe\dimen0|'。
\endconcept


%\concept{restricted mode}
\concept{受限模式}

%A \defterm{restricted mode} is a \refterm{mode} that \TeX\ is in when it is
%assembling an \refterm{hbox} or a \refterm{vbox}.
%We follow \texbook\ in using the term ``internal vertical mode''
%for what you might expect to be ``restricted vertical mode''.
%See \conceptcit{horizontal
%mode} and \conceptcit{vertical mode}.\endconcept
\defterm{受限模式}（restricted mode）是 \TeX\ 组装\refterm{水平盒子}%
或\refterm{竖直盒子}时所处的\refterm{模式}。
我们使用 \texbook\ 中的术语``内部竖直模式''来命名我们所认为的``受限竖直模式''。
请参阅\conceptcit{水平模式}和\conceptcit{竖直模式}。\endconcept


%\conceptindex{rules}
%\concept rule
\concept 标线

%A \defterm{rule} is a solid black rectangle.
%A rule, like a \refterm{box},
%has \refterm{width}, \refterm{height}, and \refterm{depth}.
%The vertical dimension of the rectangle
%is the sum of its height and its depth.
%An ordinary horizontal or vertical straight line is a special case of a rule.
\defterm{标线}（rule）是一个黑色实心矩形。
标线和\refterm{盒子}一样也有\refterm{宽度}、\refterm{高度}和\refterm{深度}。
该矩形的竖直尺寸是它的高度和深度之和。
普通的水平或竖直直线是标线的特殊情形。

%\bix^^{horizontal rules}
%\bix^^{vertical rules}
%\bix^^|\hrule|
%\bix^^|\vrule|
%A rule can be either horizontal or vertical.  The distinction between a
%horizontal rule and a vertical one has to do with how you produce the
%rule, since a vertical rule can be short and fat (and therefore look
%like a horizontal line), while a horizontal rule can be tall and skinny
%(and therefore look like a vertical line).  \TeX's notion of a rule is
%more general than that of typographers, who think of a rule as a line
%and would not usually call a square black box a rule.
\bix^^{水平标线}
\bix^^{竖直标线}
\bix^^|\hrule|
\bix^^|\vrule|
标线可以是水平的或者竖直的。水平标线和竖直标线的区别与你如何生成标线有关，
因为竖直标线可以矮而胖（从而看似水平标线），
而水平标线也可以高而瘦（从而看似竖直标线）。\TeX\ 所说的标线比排印工的更一般，
它们认为标线就是一条线而通常不把黑色方块称为标线。

%You can produce a horizontal rule using the
%|\hrule| command and a vertical rule using
%the |\vrule| command \ctsref{\vrule}.
%For example, the control sequence |\hrule| by itself
%produces a thin rule that runs across the page, like this:
你可以用 |\hrule| 命令生成水平标线，用 |\vrule| 命令\ctsref{\vrule}生成竖直标线。
例如，控制序列 |\hrule| 本身就生成一个横跨页面的细标线，如下：

%{\offinterlineskip
%\nobreak\medskip
%\hrule
%\medskip}
{\offinterlineskip
\nobreak\medskip
\hrule
\medskip}

%The command `|\vrule height .25in|' produces a vertical rule
%that runs $.25$~inches down the page like this:
%\nobreak\vskip \abovedisplayskip
%\leftline{\vrule height .25in}
%\vskip \belowdisplayskip
命令 `|\vrule height .25in|' 生成往下 $.25$ 英寸的竖直标线如下：
\nobreak\vskip \abovedisplayskip
\leftline{\vrule height .25in}
\vskip \belowdisplayskip

%There are two differences between horizontal rules and vertical rules:
%\olist
%\li For a horizontal rule, \TeX\ defaults the width to the width of the
%smallest \refterm{box} or \refterm{alignment} that encloses it.  For a
%vertical rule, \TeX\ defaults the height and depth in the same way.  (The
%default is the size that you get if you don't give a size explicitly for that
%dimension.)
水平标线和竖直标线有如下两个区别：
\olist
\li 对于水平标线，\TeX\ 设定将其默认宽度为包含它的最小\refterm{盒子}或\refterm{阵列}的宽度。
对于竖直标线，\TeX\ 用类似方法设定其默认高度和深度。%
（如果你没有显式设定尺寸，默认为内容的尺寸。）

%^^{horizontal lists//rule in}
%^^{vertical lists//rule in}
%\li
%{\tighten
%A horizontal rule is an inherently vertical item that cannot participate in
%a \refterm{horizontal list},
%while a vertical
%rule is an inherently horizontal item
%that cannot participate in a \refterm{vertical list}.  This behavior
%may seem strange at first but there is good reason for it:
%a horizontal rule ordinarily runs visually from left
%to right and thus separates items in a vertical list,
%while a vertical rule ordinarily runs visually from top to bottom
%and thus separates items in a horizontal list.
%%(Look at the rules that are shown above.)
%\par}
%\endolist
^^{水平列表//水平列表中的标线}
^^{竖直列表//竖直列表中的标线}
\li
水平标线是本质上的竖直项目，不能放在\refterm{水平列表}中；
而竖直标线是本质上的水平项目，不能放在\refterm{竖直列表}中；
这种行为初看也许有些奇怪，但却是有合理原因的：
水平标线在外观上通常是从左到右的，因而分开了竖直列表中的项目；
而竖直标线在外观上通常是从上到下的，因而分开了水平列表中的项目；
%(Look at the rules that are shown above.)
\endolist

%{\tighten
%If you construct a rule with three explicit dimensions, it will look the
%same whether you make it a horizontal rule or a vertical rule.
%For example, the command `|\vrule height1pt depth2pt width3in|' produces this
%horizontal-looking rule:
%\par}
如果你构造一个有三个明确尺寸的标线，无论作为水平标线还是竖直标线它看起来都是一样的。
例如，命令 `|\vrule height1pt depth2pt width3in|' 生成如下看似水平方向的标线：

%{\offinterlineskip
%\nobreak\medskip\nobreak\vskip3pt
%\leftline{\vrule height1pt depth2pt width3in}
%\medskip}
{\offinterlineskip
\nobreak\medskip\nobreak\vskip3pt
\leftline{\vrule height1pt depth2pt width3in}
\medskip}

%You'll find a precise statement of \TeX's treatment of rules on
%\knuth{pages~221--222}.
%\eix^^{horizontal rules}
%\eix^^{vertical rules}
%\eix^^|\hrule|
%\eix^^|\vrule|
%\endconcept
在\knuth{第~221--222~页}
\footnote{译注：或见该书中文翻译版第178--179页。}
中，你可以找到对 \TeX\ 如何处理标线的精确表述。
\eix^^{水平标线}
\eix^^{竖直标线}
\eix^^|\hrule|
\eix^^|\vrule|
\endconcept


\bookmark{2}{以S开头}
%\concept {script size}
\concept {标号尺寸}

%\defterm{Script size} describes one of the three related
%\refterm{fonts:font} in a family.
%^^{family//script size in}
%Script size is smaller than \refterm{text size} but larger than
%\refterm{scriptscript size}.  \TeX\ uses script size for subscripts and
%superscripts, as well as for the numerators and denominators of
%fractions in text.
%\endconcept
\defterm{标号尺寸}（script size）描述一族字体中三个相关\refterm{字体}的其中一个。
^^{族//族的标号尺寸}
标号尺寸比\refterm{文本尺寸}小但比\refterm{小标号尺寸}大。
对上标，下标以及文本中分式的分子和分母，\TeX\ 使用标号尺寸。
\endconcept


%\concept {scriptscript size}
\concept {小标号尺寸}

%\defterm{Scriptscript size} describes the smallest of the three related
%\refterm{fonts:font} in a family.
%^^{family//scriptscript size in}
%\TeX\ uses \refterm{scriptscript size} for second-order subscripts,
%superscripts, numerators, and denominators.  For example, \TeX\ will use
%scriptscript size for a subscript on a subscript or for a superscript on
%a scriptsize numerator.
%\endconcept
\defterm{小标号尺寸}（scriptscript size）描述一族字体中三个相关\refterm{字体}的最小一个。
^^{族//族的小标号尺寸}
对第二级的上标、下标、分子和分母，\TeX\ 使用小标号尺寸。
比如，对于下标中的下标，或者标号尺寸分子中的上标，\TeX\ 将使用小标号尺寸。
\endconcept


%\concept shrink
\concept 收缩量

%See \conceptcit{glue}.
%\endconcept
见 \conceptcit{粘连}。
\endconcept


%\concept space
\concept 间隔

%You can cause \TeX\ to put \defterm{space} between two items in
%several~ways:
要让 \TeX\ 在两个项目间留下\defterm{间隔}（space），有如下几种方法：

%\olist
%^^{end of line}
%\li You can write something that \TeX\ treats as a space
%\refterm{token}: one or more blank characters, the end of a line (the
%end-of-line character acts like a space), or any \refterm{command} that
%expands into a space token.  \TeX\ generally treats several consecutive
%spaces as equivalent to a single one, including the case where the
%spaces include a single end-of-line.  (An empty line
%indicates the end of a paragraph; it
%causes \TeX\ to generate a |\par| token.)
%^^|\par//from empty line|
%\TeX\ adjusts the size of
%this kind of space to suit the length required by the context.
\olist
^^{行尾符}
\li 你可以写上某些 \TeX\ 视为空格\refterm{记号}的东西：
一个或多个空格符，行尾符（行尾符作用和空格相似），
或任何能展开为空格记号的\refterm{命令}。
\TeX\ 一般将多个连续空格视为单个空格，包括其中有一个行尾符的情形。%
（一个空行表示段落的结束；它导致 \TeX\ 生成一个 |\par| 记号。）
^^|\par//来自空行|
\TeX\ 调整此种间隔的大小以适应由上下文所需的长度。

%^^{glue//creating space with}
%\li You can write a skip command that produces the glue
%you specify in the command.  The glue can
%\refterm{stretch} or \refterm{shrink},
%producing more or less space.  You can have vertical glue as
%well as horizontal glue.  Glue disappears whenever it is next to a
%line or page break.
^^{粘连//用它生成间距}
\li 你可以写上一个生成指定粘连的间距命令。
粘连有\refterm{伸长量}或\refterm{收缩量}，从而生成或多或少的间隔。
你可以有水平粘连和竖直粘连。在断行或分页位置之后的粘连将会消失。

%^^{kerns//creating space with}
%\li You can write a \refterm{kern}.  A kern produces a fixed amount of
%space that does not stretch or shrink and does not disappear at a line
%or page break (unless it is immediately followed by glue).  The most
%common use of a kern is to establish a fixed spatial relationship
%between two adjacent \refterm{boxes}.
%\endolist
^^{紧排//用它生成间距}
\li 你可以写上一个\refterm{紧排}。紧排生成固定大小的间隔，它不可伸长也不可收缩，
而且在断行或分页时也不会消失（除非其后紧跟着一个粘连）。
紧排常用于给两个相邻\refterm{盒子}建立固定的空间关系。
\endolist

%Glue and kerns can have negative values.  Negative glue or a negative kern
%between adjacent items brings those items closer together.
%\endconcept
粘连和紧排也可以取负值。两个相邻项目间的负粘连或负紧排将拉近它们俩的距离。
\endconcept


%\concept stretch
\concept 伸长量

%See \conceptcit{glue}.
%\endconcept
见 \conceptcit{粘连}。
\endconcept


%\conceptindex{struts}
%\concept strut
\concept 支架

%{\tighten
%A \defterm{strut} is an invisible \refterm{box}
%^^{boxes//invisible}
%whose width is zero and whose height and depth are slightly more than
%those of a ``normal''
%line of type in the context.  Struts are useful for obtaining
%uniform vertical spacing when \TeX's
%usual line spacing is disabled, e.g., within a math formula
%or within a horizontal alignment where you've specified ^|\offinterlineskip|.
%Because a strut is taller and deeper than everything else on its line,
%it determines the height and depth of the line.
%You can produce a strut with
%the ^|\strut| command \ctsref{\strut} or the ^|\mathstrut| command
%\ctsref\mathstrut.
%You can use |\strut| anywhere, but you can only use |\mathstrut| when
%\TeX\ is in math \refterm{mode}.  A strut in \plainTeX\ has height 8.5\pt\ and
%depth 3.5\pt, while a math strut has the height and depth of a left
%parenthesis in the current \refterm{style} (so it's smaller for
%subscripts and superscripts).
%\par}
\defterm{支架}（strut）一个不可见的\refterm{盒子}，
^^{盒子//不可见盒子}
它的宽度为零，而高度和深度比上下文中的“正常”行稍微大一点。
支架常用于在通常行间隔取消时获得一致的竖直间隔，
比如在数学公式中，或者在设定了 ^|\offinterlineskip| 的水平阵列中。
因为支架比该行的其他东西都高和深，它确定了该行的高度和深度。
你可以用 ^|\strut| 命令\ctsref{\strut}或
^|\mathstrut| 命令\ctsref\mathstrut 生成一个支架。
|\strut| 可以在任何地方使用，但 |\mathstrut| 只能在数学\refterm{模式}中使用。
在 \plainTeX\ 中，支架的高度为 8.5\pt ，深度为3.5\pt ，
而数学支架的高度和深度和当前\refterm{样式}的左圆括号的相等%
（因此在上下标中会小一点）。

%Here's an example showing how you might use a strut:
%\csdisplay
%\vbox{\hsize = 3in \raggedright
%   \strut Here is the first of two paragraphs that we're
%   setting in a much narrower line length.\strut}
%\vbox{\hsize = 3in \raggedright
%   \strut Here is the second of two paragraphs that we're
%   setting in a much narrower line length.\strut}
%|
%This input yields:
%\display{\vbox{
%\vbox{\hsize = 3in \raggedright
%\strut Here is the first of two paragraphs that we're setting
%in a much narrower line length.\strut}
%\vbox{\hsize = 3in \raggedright
%\strut Here is the second of two paragraphs that we're setting
%in a much narrower line length.\strut}
%}}
%\noindent
%Without the struts the \refterm{vboxes:vbox} would be too close
%together.  Similarly, in the formula:
%\csdisplay
%$\overline{x\mathstrut} \otimes \overline{t\mathstrut}$
%|
%the math struts cause both bars to be set at the same height even
%though the `$x$' and the `$t$' have different heights:
%\display{
%$\overline{x\mathstrut} \otimes \overline{t\mathstrut}$
%}
%\vskip -\belowdisplayskip
%\endconcept
%\nobreak
这里有个例子给你展示了支架的用法：
\csdisplay
\vbox{\hsize = 3in \raggedright
   \strut Here is the first of two paragraphs that we're
   setting in a much narrower line length.\strut}
\vbox{\hsize = 3in \raggedright
   \strut Here is the second of two paragraphs that we're
   setting in a much narrower line length.\strut}
|
这个输入产生下列输出：
\display{\vbox{
\vbox{\hsize = 3in \raggedright
\strut Here is the first of two paragraphs that we're setting
in a much narrower line length.\strut}
\vbox{\hsize = 3in \raggedright
\strut Here is the second of two paragraphs that we're setting
in a much narrower line length.\strut}
}}
\noindent
要是没有支架，这两个\refterm{盒子}将太过靠近了。
类似地，在数学公式中：
\csdisplay
$\overline{x\mathstrut} \otimes \overline{t\mathstrut}$
|
数学支架让两个横线位于相同的高度，即使 `$x$' 和 `$t$' 有不同的高度：
\display{
$\overline{x\mathstrut} \otimes \overline{t\mathstrut}$
}
\vskip -\belowdisplayskip
\endconcept
%\nobreak


%\conceptindex{styles}
%\concept {style}
\concept {样式}

%Material in a math formula is set in one of eight \defterm{styles},
%depending on the context.  Knowing about styles can be useful if you want to
%set part of a formula in a different size of type than the one
%that \TeX\ has chosen according to its usual rules.
数学公式中的素材依据上下文被设定为八种\defterm{样式}（style）的其中一种。
对样式的了解，将有助于你将某部分公式设为不同类型的大小，
即与 \TeX\ 按照通用法则选择的大小不同。

%\eject
%The four primary styles are:
其中的四种主要样式如下：

%\vdisplay{%
%\halign{\refterm{# style}\hfil&\hskip .25in(for #)\hfil\cr
%display&formulas displayed on a line by themselves\cr
%text&formulas embedded in ordinary text\cr
%script&superscripts and subscripts\cr
%scriptscript&superscripts on superscripts, etc.\cr
%}}
\vdisplay{%
\halign{\refterm{#样式}\hfil&\hskip .25in（用于#）\hfil\cr
陈列&单独一行显示的公式\cr
文本&嵌入普通文本内的公式\cr
标号&上标和下标\cr
小标号&上标中的上标，等等\cr
}}

%The other four styles are so-called ^{cramped variants}.  In these
%variants superscripts aren't raised as high as usual, and so the formula
%needs less vertical space than it otherwise would.  See
%\knuth{pages~140--141} for the details of how \TeX\ selects the style.
另外四种样式被称为^{狭窄变体}。
在这些变体中，上标升高得没那么多，因而公式和原来相比占用更少的竖直间隔。
在\knuth{第~140--141~页}
\footnote{译注：或见该书中文翻译版第108--109页。}
中详细介绍了 \TeX\ 如何选择样式。

%\TeX\ chooses a size of type according to the style:
\TeX\ 依照样式选择尺寸类型：

%\ulist\compact
%^^{display style}^^{text style}
%\li Display style and text style are set in \refterm{text size}, like
%`$\rm this$'.
\ulist\compact
^^{陈列样式}^^{文本样式}
\li 陈列样式和文本样式设定为\refterm{文本尺寸}，就像 `$\rm this$' 这样。

%^^{script style}
%\li Script style is set in \refterm{script size}, like `$\scriptstyle
%\rm this$'.
^^{标号样式}
\li 标号样式设定为\refterm{标号尺寸}，就像 `$\scriptstyle \rm this$' 这样。

%^^{scriptscript style}
%\li Scriptscript style is set in \refterm{scriptscript size}, like
%`$\scriptscriptstyle \rm this$'.
%\endulist
^^{小标号样式}
\li 小标号样式设定为\refterm{小标号尺寸}，就像 `$\scriptscriptstyle \rm this$' 这样。
\endulist

%See \conceptcit{family} for more information about these three sizes.
参考\conceptcit{族}以获得更多关于这三种尺寸的信息。

%\TeX\ doesn't have a ``scriptscriptscript'' style because such a style
%would usually have to be set in a size of type too small to read.  \TeX\
%therefore sets third-order subscripts, superscripts, etc., using the
%scriptscript style.
在 \TeX\ 中没有“小小标号”样式，因为此样式对应的尺寸太小以致无法阅读。
因此 \TeX\ 用小标号样式设定三阶上下标等。

%Once in a while you may find that \TeX\ has set a formula in a different style
%than the one you'd prefer.  You can override \TeX's choice with the
%^|\textstyle|, ^|\displaystyle|, ^|\scriptstyle|, and ^|\scriptscriptstyle|
%commands \ctsref{\textstyle}.
%\endconcept
偶尔你会发现 \TeX\ 给公式设定的样式和你想要的不同。
你可以用 ^|\textstyle|，^|\displaystyle|，^|\scriptstyle| 和 ^|\scriptscriptstyle|
命令\ctsref{\textstyle}改变 \TeX\ 的选择。
\endconcept


\bookmark{2}{以T开头}
\concept {\TeXMeX}

%(a)~A variant of \TeX\  used for mathematical typesetting in
%Central American countries.
%(b)~A spicy cuisine favored by the \TeX\-ni\-cians of ^{El Paso}.
%\endconcept
(a)~一个在中美洲国家用于数学排版的 \TeX\ 变种。
(b)~一种深受^{埃尔帕索}的 \TeX\ 用户欢迎的香辣菜。
\endconcept


%\concept {text math}
\concept {文内公式}

%We use the term \defterm{text math} to refer to a math formula set within a
%line of text, i.e., enclosed in |$|'s.
%\ttidxref{$}
%\TeX\ sets text math in text math \refterm{mode}.
%\endconcept
我们用\defterm{文内公式}（text math）这个术语表示放在一行文本之中的数学公式，
即两边用 |$| 括起来的公式。
\ttidxref{$}
\TeX\ 在文内数学\refterm{模式}中排版文内公式。
\endconcept


%\concept {text size}
\concept {文本尺寸}

%\defterm{Text size} describes the largest of the three related
%\refterm{fonts:font} in a \refterm{family}.
%^^{family//text size in}
%\TeX\ uses text size for ordinary symbols appearing in
%\refterm{math mode}.
%\endconcept
\defterm{文本尺寸}（text size）描述一\refterm{族}字体中%
三个相关\refterm{字体}的最大一个。
^^{族//族的文本尺寸}
对\refterm{数学模式}中的普通符号，\TeX\ 使用文本尺寸。
\endconcept


%\conceptindex{tokens}
%\concept token
\concept 记号

%A \defterm{token} is either a single character tagged with a
%\refterm{category code}, or a \refterm{control sequence}.  \TeX\ reads
%characters from a file using its eyes \seeconcept{\anatomy}
%and groups the characters into tokens using its mouth.  When a token
%reaches \TeX's stomach, \TeX\ interprets it as a \refterm{command}
%unless it's part of an argument of a preceding command.
%\endconcept
一个\defterm{记号}（token）要么是一个标有\refterm{类别码}的字符，
要么是一个\refterm{控制序列}。
\TeX\ 用它的眼睛从文件中读取字符串\seeconcept{\anatomy}，
并用它的嘴将字符串咀嚼成一个个记号。
当一个记号到达\TeX\ 的胃时，\TeX\ 将它解释为一个\refterm{命令}，
除非它是之前命令的参量。
\endconcept


\bookmark{2}{以U开头}
%\conceptindex{units of measure}
%\concept {unit of measure}
\concept {度量单位}

%See \conceptcit{dimension}.
%\endconcept
见 \conceptcit{尺寸}。
\endconcept


\bookmark{2}{以V开头}
%\conceptindex{vboxes}
%\concept vbox
\concept 竖直盒子

%^^{vertical lists//vboxes formed from}
%A \defterm{vbox} (vertical box) is a \refterm{box} that \TeX\ constructs
%by placing the items of a \refterm{vertical list} one after another, top
%to bottom.  A vbox, taken as a unit, is neither inherently horizontal
%nor inherently vertical, i.e., it can appear as an item of either a
%vertical list or a \refterm{horizontal list}.  You can construct a vbox
%with the ^|\vbox| or the ^|\vtop| command
%\ctsref{\vtop}.  The difference is that for |\vbox|,
%the \refterm{reference point}
%of the constructed vbox is derived from that of the last (and
%usually bottommost) constituent list item, but for |\vtop|, it's that of the
%first (and usually topmost) constituent list item.
%\endconcept
^^{竖直列表//组成竖直盒子}
\defterm{竖直盒子}（vbox，vertical box）是 \TeX\
从上到下逐个放置\refterm{竖直列表}的项目而构造出来的\refterm{盒子}。
竖直盒子，作为一个单元，既不是本质上水平的也不是本质上竖直的，
即它可以出现在竖直列表或\refterm{水平列表}中。
你可以用 ^|\vbox| 或 ^|\vtop| 命令\ctsref{\vtop}构造竖直盒子。
两者的区别在于，
对于 |\vbox|，所构造的竖直盒子的\refterm{基准点}来源于%
列表的最后一个（通常是最下面那个）组成项；
而对于 |\vtop|，所构造的竖直盒子的\refterm{基准点}来源于%
列表的第一个（通常是最上面那个）组成项。
\endconcept


%\conceptindex{vertical lists}
%\concept{vertical list}
\concept{竖直列表}

%A \defterm{vertical list} is a list of items
%that \TeX\ has produced while it is
%in one of its vertical modes, i.e.,
%assembling either a
%\refterm{vbox} or a page.  See ``vertical mode'' below.
\defterm{竖直列表}（vertical list）是 \TeX\ 位于某种竖直模式时
（即组装\refterm{竖直盒子}或页面时）生成的一列项目。见下面的``竖直模式''。

\endconcept


%\concept{vertical mode}
\concept{竖直模式}

%^^{vboxes//vertical mode for} When \TeX\ is assembling either a
%\refterm{vbox} or the main vertical list from which pages are derived,
%it is in one of two \defterm{vertical modes}: ^{ordinary
%vertical mode} for assembling the main vertical list, and ^{internal
%vertical mode} for assembling vboxes.  Whenever \TeX\ is in a vertical mode
%its stomach \seeconcept{\anatomy} is constructing a \refterm{vertical
%list} of items (boxes, glue, penalties, etc.).
%\TeX\ typesets the items in the list
%one below another, top to bottom.
^^{竖直盒子//位于竖直模式中}
在组装\refterm{竖直盒子}或者主竖直列（输出的页面来源于此）时，
\TeX\ 位于两种\defterm{竖直模式}（vertical mode）之一:
^{普通竖直模式}用于组装主竖直列，而^{内部竖直模式}用于组装竖直盒子。
只要 \TeX\ 位于竖直模式中，它的胃\seeconcept{\anatomy}就在构造项目%
（盒子、粘连、惩罚等）的\refterm{竖直列表}。
\TeX\ 逐个排版列表中的项目，从上到下。

%A vertical list can't contain any items produced by
%inherently horizontal commands, e.g.,
%^^{vertical lists//can't contain horizontal commands}
%|\hskip| or an ordinary (nonspace) character.
%\footnote{\TeX\ \emph{ignores} any space characters
%that it encounters while it's in a vertical mode.}
竖直列表不能包含任何用本质上的水平命令，
^^{竖直列表//不能包含水平命令}
比如 |\hskip| 或普通的（非空格）字符，生成的项目。
\footnote{在竖直模式中 \TeX\ \emph{忽略}它遇到的任何空格符。}

%\ulist
%\li If \TeX\ is  assembling a vertical list in ordinary vertical mode and
%encounters an inherently horizontal command, it switches to ordinary
%\refterm{horizontal mode}.
%\li If \TeX\ is  assembling a vertical list in internal vertical mode and
%encounters an inherently horizontal command, it complains.
%\endulist
\ulist
\li 如果 \TeX\ 正在普通竖直模式中组装竖直列表，并碰到一个本质上的水平命令，
它将切换到\refterm{水平模式}。
\li 如果 \TeX\ 正在内部水平模式中组装竖直列表，并碰到一个本质上的水平命令，
它将报错。
\endulist

%Two commands that you might at first think are inherently vertical are
%in fact inherently horizontal: |\valign| \ctsref{\valign} and |\vrule|
%\ctsref{\vrule}.
%^^|\valign//inherently horizontal|
%^^|\vrule//inherently horizontal|
%See \knuth{page~283} for a list of the
%inherently horizontal commands.
这两个命令你也许会认为是本质上竖直的，实际上却是本质上水平的：
|\valign|\ctsref{\valign}和 |\vrule|\ctsref{\vrule}。
^^|\valign//本质上水平的|
^^|\vrule//本质上水平的|
在\knuth{第~283~页}
\footnote{译注：或见该书中文翻译版第234页。}
中列出了所有本质上的水平命令。

%It's particularly important to be aware that \TeX\ considers an ordinary
%character other than a space character to be inherently horizontal.  If
%\TeX\ suddenly starts a new paragraph when you weren't expecting it,
%a likely cause is a
%character that \TeX\ encountered while in vertical mode.
%You can convince \TeX\
%not to treat that character as inherently horizontal by enclosing it in
%an \refterm{hbox} since the |\hbox| command, despite its name, is
%neither inherently horizontal nor inherently vertical.
%\endconcept
有个特别重要的事实需要知道，即 \TeX\ 将任何普通的非空格符视为本质上水平的。
如果 \TeX\ 在你预期之外突然开始一个新段落，
这可能是由 \TeX\ 在竖直模式中遇到的字符引起的。
要让 \TeX\ 不把该字符视为本质上水平的，你可以将它放入一个\refterm{水平盒子}中；
这是因为，尽管看名字容易误解，|\hbox| 命令既不是本质上水平的也不是本质上竖直的。
\endconcept


\bookmark{2}{以W开头}
%\concept whatsit
\concept 小玩意

%A \defterm{whatsit} is an item of information that
%tells \TeX\ to carry out some action
%that doesn't fit into its ordinary scheme of things.
%A whatsit can appear in a horizontal or vertical list, just like a box
%or a glue item.
%\TeX\ typesets a whatsit
%as a \refterm{box} having zero width, height, and depth---in other
%words, a box that contains nothing and occupies no space.
\defterm{小玩意}（whatsit）是一个信息项目，
它用于让 \TeX\ 执行某些无法归入普通事物体系中的操作。
小玩意可以出现在水平列表或竖直列表中，就像一个盒子或粘连项那样。
\TeX\ 将小玩意排版为一个宽度、高度和深度都为零的\refterm{盒子}——%
即一个不包含任何东西也不占用任何空间的盒子。

%Three sorts of whatsits are built into \TeX:
%\ulist
%\li The |\openout|, |\closeout|, and |\write| commands
%(\p\xrefn{\openout})
%% (2nd) removed \xref to \write, since it's on the same page
%produce a whatsit for operating on an output file.
%^^|\openout//whatsit produced by|
%^^|\write//whatsit produced by|
%^^|\closeout//whatsit produced by|
%\TeX\ postpones the operation until it next ships out a page
%to the {\dvifile}
%^^{\dvifile//whatsits in}
%(unless the operation is preceded by ^|\immediate|).
%\TeX\ uses a whatsit for these commands because they don't have anything
%to do with what it's typesetting when it encounters them.
%\li The ^|\special| command \ctsref{\special} tells \TeX\ to
%insert certain text directly into the \dvifile.
%As with the |\write| command, \TeX\ postpones the insertion
%until it next ships out a page to the {\dvifile}.
%^^{\dvifile//material inserted by \b\tt\\special\e}
%A typical use of |\special| would be to
%name a graphics file that the device driver should incorporate into
%your final output.
%\li When you change languages with the ^|\language| or ^|\setlanguage|
%commands \ctsref{\language},
%\TeX\ inserts a whatsit that instructs it to use a
%certain set of hyphenation rules later on when it's breaking a paragraph
%into lines.
%\endulist
%\noindent
%A particular implementation of \TeX\ may provide additional whatsits.
%\endconcept
在 \TeX\ 中内建了三种类型的小玩意：
\ulist
\li |\openout|、|\closeout| 和 |\write| 命令（第~\xrefn{\openout}~页）%
% (2nd) removed \xref to \write, since it's on the same page
生成用于操作输出文件的小玩意。
^^|\openout//生成小玩意|
^^|\write//生成小玩意|
^^|\closeout//生成小玩意|
\TeX\ 将此操作推迟到下次送出页面到 \dvifile 时%
^^{\dvifile//其中的小玩意}
（除非在该操作之前加上 ^|\immediate|）。
\TeX\ 用小玩意表示这些命令，因为它们与当时正在排版的内容完全无关。
\li ^|\special| 命令\ctsref{\special}让 \TeX\ 直接插入某些文本到 \dvifile 中。
如同 |\write| 命令，\TeX\ 也将此操作推迟到下次送出页面到 \dvifile 时。
^^{\dvifile//用 \b\tt\\special\e 插入的素材}
|\special| 的典型用法是命名一个图片文件，以让设备驱动文件将它整合到最终输出中。
\li 当你用 ^|\language| 或 ^|\setlanguage| 命令\ctsref{\language}改变语言时，
\TeX\ 插入一个小玩意，以引导它在以后分段为行时使用特定集合的连字规则。
\endulist
\noindent
\TeX\ 的某些特别实现可能提供额外的小玩意。
\endconcept


%\concept width
\concept 宽度

%^^{boxes//width of}
%The \defterm{width} of a \refterm{box} is the amount of horizontal space
%that it occupies, i.e., the distance from its left edge to its
%right edge.  The typeset material in a box can be wider than the box itself.
%\endconcept
^^{盒子//盒子的宽度}
\refterm{盒子}的\defterm{宽度}（width）是它总共占用的水平间隔，
即从它的左边缘到右边缘的距离。盒子内排版的素材可以比盒子本身还宽。
\endconcept

\endconcepts

\ifoldeplain\else\ifcompletebook\else
\vskip4em{\sectionfonts\leftline{本章索引}}
\readindexfile{i}
\fi\fi

\endchapter
\byebye
