% -*- coding: utf-8 -*-
% This is part of the book TeX for the Impatient.
% Copyright (C) 2003 Paul W. Abrahams, Kathryn A. Hargreaves, Karl Berry.
% See file fdl.tex for copying conditions.

\input macros
\chapter {一般操作命令}

\chapterdef{general}

这章介绍 \TeX\ 的^{编程功能}和不适合放入前几章的所有内容.
在 \headcit{命令描述}{cmddesc} 一节中, 给出了这章的惯例.

\begindescriptions

%==========================================================================
\section {命名及修改字体}

\begindesc
\bix^^{fonts//naming and modifying}
\cts font {}
\aux\cts font {\<control sequence> = \<fontname>}
\aux\cts font {\<control sequence> = \<fontname> {\bt scaled} \<number>}
\aux\cts font {\<control sequence> = \<fontname> {\bt at} \<dimen>}
\explain
单独使用时, |\font| 控制序列指代当前的字体.
|\font| 在这个时候并不是一个真正的命令,
它仅仅作为其它命令的一个参数.

其它的三个 |\font| 形式, 字体名 \<font\-name>
用来指代定义一个字体所需要的一系列文件.
在这些形式下, |\font| 是命令.
每种形式都有两个效果:
{\tighten
\olist
\li 它定义了一个名为 \<control sequence> 的控制序列,
用来选择名为 \<font\-name> 的字体, 而且该字体可能被缩放 (见后).
\li 它使 \TeX\ 载入 \<font\-name> 的^{字体信息文件} (^{\tfmfile}).
\endolist
}% end tighten

\noindent
字体的名字往往表示它的设计大小,
比如 |cmr10| 表示设计大写为 $10$ 点的计算机现代字体.
字体的设计大小保存在字体信息文件中.

如果用户既没有指定 |scaled| \<number> 也没有指定 |at| \<dimen>,
那么这个字体载入时, 使用设计大小---设计大小的含意是,
字体在这个大小时, 表示最佳.
否则将会载入一个缩放版的字体:
\ulist
\li 如果指定了 |scaled| \<number>, 则字体将被放大 $\hbox{\<number>}/1000$ 倍.
\li 如果指定了 |at| \<dimen>, 则字体通过缩放大 $\hbox{\<dimen>}/ds$ 倍,
变为 \<dimen> 大小,
其中,  $ds$  是 \<fontname> 的设计大小.
\<dimen>  和 $ds$ 的单位往往使用点.
\endulist
\noindent
放大率可以小于 $1$, 这样做就会使字体缩小尺寸.

你往往需要为载入的字体的每一个使用的放大率提供一个字体轮廓文件 (\xref{shape}).
当然, 一些^{设备驱动}可以使用打印机内置的字体.
^^{resident fonts}这些字体不需要字体轮廓文件.

更多信息请参见 \conceptcit{font} 和 \conceptcit{magnification}.

\example
\font\tentt = cmtt10
\font\bigttfont = cmtt10 scaled \magstep2
\font\eleventtfont = cmtt10 at 11pt
First we use {\tentt regular CM typewriter}.
Then we use {\eleventtfont eleven-point CM typewriter}.
Finally we use {\bigttfont big CM typewriter}.
|
\produces
\font\regttfont = cmtt10
\font\bigttfont = cmtt10 scaled \magstep 2
\font\eleventtfont = cmtt10 at 11pt
First we use {\regttfont regular CM typewriter}.
Then we use {\eleventtfont eleven-point CM typewriter}.
Finally we use {\bigttfont big CM typewriter}.
\endexample
\enddesc

\begindesc
\cts fontdimen {\<number> \<font>\param{dimen}}
\explain
^^{fonts//parameters of}
这些参项可以用来定义控制序列 \<font> (注意, \<font> 和 \<font\-name> 不同, \<font-name> 是用来表示字体文件的文件名的) 所定义的各种尺寸大小.
这些参项的值, 都在 \<font> 所使用的字体信息文件中定义了, 但是你可以在执行 \TeX\ 时得到或改变这些值.
这些参项的数值及其意义为:
\display{\halign{\hfil#\hfil\quad&#\hfil\cr
\it 数值&\it 义意\cr
\noalign{\vskip 1\jot}%
1&字体每点的倾斜程度\cr
2&词间距\cr
3&词间伸长长度\cr
4&词间收缩长度\cr
5&x 字符的高度(|1ex| 的长度)\cr
6&m 字符的宽度 (|1em| 的长度)\cr
7&额外空白长度\cr}}
\noindent
\TeX\ 需要使用字体每点的倾斜程度来计算重音符号的位置.
使用词间距来控制单词间的距离 (见 |\spaceskip|, \xref\spaceskip).
使用额外空白长度来控制句号以后所留的空白 (见 |\spaceskip|, \xref\spaceskip).
在 \knuth{433~页} 中列出了 \plainTeX\ 中字体所使用的这些参项的数值.
数学符号有另外 $15$ 个参项, 不过我们在此不展开讨论.


注意:
这些参项被设定后, 在当前组结束时, 并\emph{不}返回初始值.
如果你只是希望在局部的文本中改变这些值,
你需要将它的原值保存, 以便稍后恢复.
\example
Here's a line printed normally.\par
\fontdimen2\font = 3\fontdimen2\font
% Triple the interword spacing.
\noindent Here's a really spaced-out line.
|
\produces
Here's a line printed normally.\par
\dimen0 = \fontdimen2\font % to undo global assignment
\fontdimen2\font = 3\fontdimen2\font
% triple the interword spacing
\noindent Here's a really spaced-out line.
\fontdimen2\font = \dimen0
\endexample
\enddesc

\begindesc
\cts magnification {{\bt =} \<number>}
\cts mag {\param{number}}
\explain
\margin{合并了 {\tt\\mag} 和 {\tt\\magnification}.}
使用 |\magnification| 可以定义``^{缩放倍率}'' $f$,
缩放倍率决定了你的文档的\minref{放大}率 \seeconcept{放大率}.
|\magni!-fication|必需在文档的第一页被编译出前定义.

这个命令把 $f$ 定义成 \<number> 的同时,
也会定义把 |\hsize| 定义为 |6.5true in|, 把 |\vsize| 义为 |8.9true in|,
^^|\hsize//set by {\tt\\magnification}|
^^|\vsize//set by {\tt\\magnification}|
即 $8 \frac1/2$ 英尺乘 $11$ 英尺的页大小.
缩放倍率 $f$ 值必需间于 $0$ 到 $32768$ 之间.
该文档的 \minref{放大}率 为 $f/1000$.
一个为 $1000$ 的缩放倍率为单位放大率, 也就是说,
这个设置不会使你的文档的尺寸发生任何变化.
习惯上使用 $1.2$ 的次幂值来定义缩放倍率,
因为很多的字体就是基于这种倍率的.
你可以用 ^|\magstep| 和 ^|\magstephalf| 命令来更方便地定义这种倍率.


|\magnification| 不是一个参项, 你不能使用它来得到缩放率.
如果你使用类似 |\dimen0 = \mag!-nifi!-cation| 之类的语句,
\TeX\ 会因此报错.

而 |\mag| 参项则含有缩放倍率.
改变 |\mag| 的值可以对页面的尺寸重新缩放,
当然这一般不是你所想要的.
因此, 一般情况下, 最好是使用 |\magnification| 而不是 |\mag| 来改变页面的放大率.

\example
\magnification = \magstep2
% 把字体放大 1.44 倍 (=1.2x1.2)
|
\endexample
\enddesc

\begindesc
\cts magstep {\<number>}
\explain
这个命令可以展开成为\minref{放大}率,
这个放大率的数为可以把你文档中所有 (除了给定真值尺寸的) 东西的放大 $1.2^r$ 倍.
其中 $r$ 是 \<number> 的值.
\<number> 必需在 $0$ 到 $5$ 之间.
\example
\magnification = \magstep1 % 放大 1.2 倍.
|
\endexample
\enddesc

\begindesc
\cts magstephalf {}
\explain
这个命令可以展开成为\minref{放大}率,
这个放大率的数为可以把你文档中所有 (除了给定真值尺寸的) 东西的放大 $\sqrt{1.2}$ 倍.
也就是 $1$ 和 $1.2$ 的等比中项.
\example
\magnification = \magstephalf
|
\endexample
\eix^^{fonts//naming and modifying}
\enddesc

%==========================================================================
\section {把信息转为标记}

\subsection {数值}

\begindesc
\xrdef{convert}
\bix^^{numbers//converting to characters}
%
\cts number {\<number>}
\explain
这个命令可以把一个\minref{数}表示成字符\minref{标记}序列.
这里的数可以是一个确定的整数, 或是一个 \<number> 参项,
也可以是一个 \<number> 寄存器.
\example
\number 24 \quad \count13 = -10000 \number\count13
|
\produces
\number 24 \quad \count13 = -10000 \number\count13
\endexample
\enddesc

\begindesc
^^{Roman numerals}
\easy\cts romannumeral {\<number>}
\explain
这个命令可以把一个\minref{数}表示成罗马字符\minref{标记}序列.
这里的数可以是一个确定的整数, 或是一个 \<number> 参项,
也可以是一个 \<number> 寄存器.
如果这个数是负的, 则 |\romannumeral| 不产生任何标记.
\example
\romannumeral 24 \quad (\romannumeral -16)\quad
\count13 = 6000 \romannumeral\count13
|
\produces
\romannumeral 24 \quad (\romannumeral -16)\quad
\count13 = 6000 \romannumeral\count13
\endexample

\eix^^{numbers//converting to characters}
\enddesc

%==========================================================================
\subsection {环境信息}

\begindesc
^^{time of day}
\cts time {\param{number}}
\explain
\TeX\ 把这个参项设置为从当日午夜到现在所经过的分钟数.
比如在中午, |\time| 就是 $720$.
这个命令和下面的三个命令使用的是你计算机中所记录的时间.
\TeX\ 只在开始运行的时候向系统获取一次时间,
所以如果你不改变这个值的话,
先前运行的 |\time| 和最后运行的 |\time| 的值是完全相同的.
\enddesc

\bix^^{date}
\begindesc
\cts day {\param{number}}
\explain
\TeX\ 把这个参项设置为今天的日期数.
这是一个介于 $1$ 和 $31$ 之间的数.
|\day| 只在程序开始运行的时候被设定 (见上面 |\time| 的说明).
\enddesc

\begindesc
\cts month {\param{number}}
\explain
\TeX\ 把这个参项设置为当前的月份.
这是一个介于 $1$ 和 $12$ 之间的数.
|\time| 只在程序开始运行的时候被设定 (见上面 |\time| 的说明).
\enddesc

\begindesc
\cts year {\param{number}}
\explain
\TeX\ 把这个参项设置为当前的 ({\sc 公元}) 年份.
这是一个类似 $1991$ 之类的数.
|\year| 只在程序开始运行的时候被设定 (见上面 |\time| 的说明).

\eix^^{date}
\enddesc

\begindesc
^^{version number}
\cts fmtname {}
\cts fmtversion {}
\explain
这个命令会产生当前使用的 \TeX\ 格式 (比如 \minref{\plainTeX} 或 ^{\LaTeX}) 的名字和版本号.
\example
本书使用 \fmtname\ 格式,
版本~\fmtversion.
|
\produces
本书使用 \fmtname\ 格式,
版本~\fmtversion.
\endexample
\enddesc

\begindesc
\cts jobname {}
\explain
这个命令产生调用 \TeX\ 的文件的文件本名.
比如你的输入文件为 |hatter.tex|, |\jobname| 会被展开成 |hatter|.
|\jobname| 在你生成文档的辅助文件时会很管用.
^^{auxiliary files}
\example
\newwrite\indexfile  \openout\indexfile = \jobname.idx
% 打开 `hatter.tex' 的索引文件 `hatter.idx'.
|
\endexample\enddesc

%==========================================================================
\subsection {变量的值}

\begindesc
\cts meaning {\<token>}
\explain
^^{tokens//showing the meaning of}
这个命令会产生 \<token> 的定义.
它对于诊断输出很有用.
你可以用类似的方法使用 ^|the| 命令 (\xref\the) 来得到 \minref{寄存器}和其它 \TeX\ 中的东西的值信息.
\example
[{\tt \meaning\eject}] [\meaning\tenrm] [\meaning Y]
|
\produces
[{\tt \meaning\eject}] [\meaning\entenrm] [\meaning Y]
\endexample\enddesc

\begindesc
\cts string {\<control sequence>}
\explain
^^{control sequences//converting to strings}
这个命令会把 \<control sequence> 表示成其名字的字符串,
包括 \minref{转义符}.
转义符会被表示成当前 ^|\escapechar| 的值.
^^{escape character//represented by \b\tt\\escapechar\e}
\TeX\ 把在此中的所有字符的类码设为 $12$ (其它).

你可以使用 ^|\csname| 命令执行这个命令的反操作 (\xref\csname).
它会把一个字符串转为一个控制序列.
\example
控制序列 {\tt \string\bigbreak}
|
\produces
控制序列 {\tt \string\bigbreak}
\endexample\enddesc

\begindesc
\cts escapechar {\param{number}}
\explain
这个参项在把一个控制序列名转化为一系列字符标记时, 指定 \TeX\ 用来表示\minref{转义符}的字符的 \ascii\ 码\minrefs{ascii}.
^^{escape character//represented by \b\tt\\escapechar\e}
这个转化发生在你使用 |\string|命令时或者 \TeX\ 在产生诊断信息时.
转义符的默认值是 $92$, 即 ^{右斜杠} 的 \ascii\ 码.
如果 |\escapechar| 不在 $0$--$255$ 之间, \TeX\ 则在转换时不包括转义符.
\example
\escapechar = `!!
控制序列 {\tt \string\bigbreak}
|
\produces
\escapechar = `!
控制序列 {\tt \string\bigbreak}
\endexample
\enddesc

\begindesc
\cts fontname {\<font>}
\explain
^^{fonts//names of}
这个命令产生 \<font> 的字体文件名.
该字体名就是定义 \<font> 时所的 \<font\-name>.
\example
\font\myfive=cmr5 [\fontname\myfive]
|
\produces
\font\myfive=cmr5 [\fontname\myfive]
\endexample
\enddesc


%==========================================================================
\section {组}

\begindesc
\bix^^{groups}
%
\cts begingroup {}
\cts endgroup {}
\explain
这两个命令开始或结束一个\minref{组}.
|\begingroup| 不会和右括孤匹配, |\endgroup| 也不会和左括孤匹配.


\TeX\ 把 |\begingroup| 和 |\endgroup| 当作和其它的\minref{控制序列}一样对待.
尤其体现在, 你可以定义一个包括 |\begingroup| 但不包括 |\endgroup| 的宏,
或者与之相反.
^^{macros//using \b\tt\\begingroup\e\ and \b\tt\\endgroup\e\ in}
这个技巧往往在你定义一对宏时会非常有用, 一个用来开始一个环境,
另一个用来结束这个环境.
但是你不可以使用 |\begingroup| 和 |\endgroup|
来替换除了用来括起一个组以外功能的括孤.
\example
\def\a{一 \begingroup \it 二 }
\def\enda{\endgroup 四}
\a 三 \enda
|
\produces
\def\a{一 \begingroup \it 二 }
\def\enda{\endgroup 四}
\a 三 \enda
\endexample
\enddesc

\begindesc
\makecolumns 4/2:
\easy%
\ctsact { \xrdef{@lbrace}
\cts bgroup {}
\ctsact } \xrdef{@rbrace}
\cts egroup {}
\explain
左括孤和右括孤命令的作用是用来开始或结束一个\minref{组}.
|\bgroup| 和 |\egroup| \minref{控制序列}和 `|{|' and `|}|'
除了 \TeX\ 在扫描输入时会把 |\bgroup| 和 |\egroup|
像其它\minref{控制序列}一样对待以外, 都是等价的.

当你定义一个成对的宏时, |\bgroup| 和 |\egroup| 会非常有用.
成对的宏可以由一个宏开始一个由括孤分割的结构 (不一定是一个组),
并由另一个宏结束该组.
^^{macros//using \b\tt\\bgroup\e\ and \b\tt\\egroup\e\ in}
你不能使用常规的括孤来定义这样的宏, 否则你的宏定义会包含没有匹配的括孤,
而这样的定义是不被 \TeX\ 所接受的.
一般情况下你需要在你没有办法使用括孤时使用这些命令.

\example
一个组的 {\it 边界\/} 可由括孤定义.
|
\produces
一个组的 {\it 边界\/} 可由括孤定义.
\nextexample
\def\a{一 \vbox\bgroup}
% 在这里你不能使用一个 { 来代替 \bgroup,
% 否则 TeX 不会识别这个宏
\def\enda#1{{#1\egroup} 二}
% 这有点技巧性, 因为 \egroup 事实上和左括孤匹配,
% 而它右边的右边的括孤和 \bgroup 匹配.
% 不过这个歪门邪道行得通!!
\a \enda{\hrule width 1in}
|
\produces
\def\a{一 \vbox\bgroup}
% 在这里你不能使用一个 { 来代替 \bgroup,
% 否则 TeX 不会识别这个宏
\def\enda#1{{#1\egroup} 二}
% 这有点技巧性, 因为 \egroup 事实上和左括孤匹配,
% 而它右边的右边的括孤和 \bgroup 匹配.
% 不过这花招能用!!
\a \enda{\hrule width 1in}
\endexample
\enddesc

\begindesc
\cts global {}
\explain
这个命令使它随后的定义或\minref{赋值}成为\minref{全局}性的
\seeconcept{global}, 而不是仅局限在所处的\minref{组}之中生效.
你可以把 |\global| 放在
包括宏定义和\minref{寄存器}赋值在内的任意的定义或\minref{赋值}前,
\example
{\global\let\la = \leftarrow}
$a \la b$
|
\produces
% for safety's sake we fake this one!
\let\la = \leftarrow
$a \la b$
\endexample
\enddesc

\begindesc
\cts globaldefs {\param{number}}
\explain
这个参项控制 \TeX\ 是否把定义和其它的赋值作为\minref{全局}的:
\ulist
\li 如 |\globaldefs| 是 (默认值) 零,
当且仅当一个定义是由直接或者间接的 |\global| 命令指定的.
(^|\gdef| 和 ^|\xdef| 命令 (\xref\gdef) 间接地在定义前面加了 |\global| 命令).
\li 如果 |\globaldefs| 大于零, 所有的定义和赋值都会间接地在前面加上 ^|global|.
\li 如果 |\globaldefs| 小于零, 所有的 ^|\global| 都被忽略.
\endulist
\enddesc

\begindesc
\margin{改变了 {\tt\\aftergroup} 和 {\tt\\afterassignment} 顺序.}
\cts aftergroup {\<token>}
\explain
当 \TeX\ 在读取输入时遇到了这个命令, 它就把 \<token> 保存下来.
并在在当前\minref{组}后插入展开后的 \<token>.
如果一个组有好几个 |\aftergroup|, 则每个标记\emph{全}都会依次插入这个组的最后.

下面的例子向你展示了如何用 |\aftergroup| 来延迟处理一个在\minref{条件测试}中产生的标记.
\example
\def\neg{负} \def\pos{正}
% 因为一个 \aftergroup 只能作用到一个标记上,
% 而不是到一系列的标记上, 甚至不能是一个用括号定界的文本,
% 所以下面的代码是必需的.
\def\arith#1{是否 $#1>0$? \begingroup
   \ifnum #1>-1 是\aftergroup\pos
   \else 否\aftergroup\neg\fi
   , 它是\endgroup. }
\arith 2
\arith {-1}
|
\produces
\def\neg{负} \def\pos{正}
% 因为一个 \aftergroup 只能作用到一个标记上,
% 而不是到一系列的标记上, 甚至不能是一个用括号定界的文本,
% 所以下面的代码是必需的.
\def\arith#1{是否 $#1>0$? \begingroup
   \ifnum #1>-1 是\aftergroup\pos
   \else 否\aftergroup\neg\fi
   , 它是\endgroup. }
\arith 2
\arith {-1}
\endexample
\eix^^{groups}
\enddesc

\begindesc
\cts afterassignment {\<token>}
\explain
当 \TeX\ 遇到这个命令, 它会把 \<token> 保存在一个特殊的地方.
当它接下来执行一个赋值时, 它会把展关后的 \<token> 放到其后.
如果你调用了几次 |\afterassignment|, 那仅有最后一次是生效的.
|\afterassignment| 命令的一个用处是可以写定义形式的\minref{宏}命令,
例子如下.

精确的 |\afterassignment| 行为定义请参见 \knuth{page~279}.
\example
\def\setme{\afterassignment\setmeA\count255}
\def\setmeA{$\number\count255\advance\count255 by 10
   +10=\number\count255$}
算术式: \setme = 27
% 在展开 \setme 以后, TeX 把 \count255
% 设为 27, 然后调用 \setmeA.
|
\produces
\def\setme{\afterassignment\setmeA\count255}
\def\setmeA{$\number\count255\advance\count255 by 10
   +10=\number\count255$}
算术式: \setme = 27
% 在展开 \setme 以后, TeX 把 \count255
% 设为 27, 然后调用 \setmeA.
\endexample
\enddesc


%==========================================================================
\section {宏}

%==========================================================================
\subsection {定义宏}

\begindesc
\bix^^{macros}
\bix^^{macros//defining}
\xrdef{mac1}% begin the section on macros
%
\cts def {\<control sequence> \<parameter text> \rqbraces{\<replacement text>}}
\explain
这个命定根据 \<parameter text> 和 \<replacement text> 把 \<control sequence> 定义为一个\minref{宏}.
请参阅  \xrefpg{macro} 获取关于如何定义宏的完整信息.
\example
\def\add#1+#2=?{#1+#2&=
   \count255=#1 \advance\count255 by #2 \number\count255\cr}
$$\eqalign{
   \add 27+9=?
   \add -5+-8=?}$$
|
\dproduces
\def\add#1+#2=?{#1+#2&=
   \count255=#1 \advance\count255 by #2 \number\count255\cr}
$$\eqalign{
   \add 27+9=?
   \add -5+-8=?}$$
\endexample
\enddesc

\begindesc
\cts edef {\<control sequence> \<parameter text> \rqbraces{\<replacement text>}}
\explain
这个命令和 |\def| 一样可以定义宏.
唯一的区别在于, \TeX\ 会把 |\edef| 的 \<replacement text> 立即展开 (但是不会执行它).
因此, 任何在 \<replacement text> 中的内容会被展开, 但那些产生盒子或粘连的排列或命令依然保持原来的样子.
比如 \TeX\ 在处理这个定义时, 在由 |\edef| 的定义中的 \<replacement text> 中的 |\hbox| 命令依然会保持命令竹的格式, 而不会变成一个盒子.
一般情况下, 并不能明显看出什么会被展开, 什么不会, 但你可以在 \knuth{页~212-215} 找到一张可被展开的控制序列列表.

你可以使用 |\no!-expand| 命令 (\xref\noexpand) 来阻止一个控制序列的展开.
^^|\noexpand|
你可以使用 ^|\expandafter| (\xref\expandafter) 命令来延迟一个控制序列的展开.


|\write|, |\message|, |\errmessage|, |\wlog| 和 |\csname| 命令会把它们的标记使用和 |\edef| 替换文本相同的法则进行展开.

^^|\write//expanded by {\tt\\edef} rules|
^^|\message//expanded by {\tt\\edef} rules|
^^|\errmessage//expanded by {\tt\\edef} rules|
^^|\wlog//expanded by {\tt\\edef} rules|
^^|\csname//expanded by {\tt\\edef} rules|
\example
\def\aa{xy} \count255 = 1
\edef\bb{w\ifnum \count255 > 0\aa\fi z}
% 和 \def\bb{wxyz} 等价
\def\aa{} \count255 = 0 % 不影响 \bb
\bb
|
\produces
\def\aa{xy} \count255 = 1
\edef\bb{w\ifnum \count255 > 0\aa\fi z}
% 和 \def\bb{wxyz} 等价
\def\aa{} \count255 = 0 % 不影响 \bb
\bb
\endexample
\enddesc

\begindesc
\cts gdef {\<control sequence> \<parameter text> \rqbraces{\<replacement text>}}
\explain
这个命令等价于 |\global\def|.
\enddesc

\begindesc
\cts xdef {\<control sequence> \<parameter text> \rqbraces{\<replacement text>}}
\explain
这个命令等价于 |\global\edef|.
\enddesc

\begindesc
\cts long {}
\explain
这个命令加在\minref{宏}定义前面.
它告诉 \TeX\ 该宏的参数可以包括 |\par| 标记 (\xref{\@par}),
该标记一般表示一个段的结束.
^^|\par//in macro arguments|
如果 \TeX\ 尝试把一个没有 |\long| 的宏定义展开,
而该宏的任意一部分的参数包括了一个 |\par| 标记,
\TeX\ 就会报错错这是一个失控的参数.
这个行为的目的, 是为了确保宏参数的完整结束.
而 |\long| 就给你提供了一个回避这个行为的方法.
\example
\long\def\aa#1{\par\hrule\smallskip#1\par\smallskip\hrule}
\aa{这是第一行.\par
这是第二行.}
% 没有 \long, TeX 会报错
|
\produces
\medskip
\long\def\aa#1{\par\hrule\smallskip#1\par\smallskip\hrule}
\aa{这是第一行.\par
这是第二行.}
% 没有 \long, TeX 会报错
\endexample
\enddesc

\begindesc
\cts outer {}
\explain
\null ^^{outer}
这个命令加前\minref{宏}定义前.
它告诉 \TeX\ 这个宏是一个外部的 (\xref{outer}) 宏,
所以不能在某些情况中使用.
如果这个宏出现在那些被禁止的情下, \TeX\ 会报错.

\example
\outer\def\chapterhead#1{%
   \eject\topglue 2in \centerline{\bf #1}\bigskip}
% 在一个被禁止的情况下使用 \chapterhead
% 会出现错误信息.
|
\endexample
\enddesc

\begindesc
\cts chardef {\<control sequence>=\<charcode>}
\explain
^^{characters//defined by \b\tt\\chardef\e}
上面的命令把 \<charcode> 定义为 \<control sequence>.
虽然 |\chardef| 常在定义字符时用到,
你也可以使用它来给 $0$--$255$ 之间的任何一个数定义一个名字,
即使你没用以字符码的形式使用该数.
\example
\chardef\percent = `\% 21\percent, {\it 19\percent}
% 排印出正体和意大利体的百分号
|
\produces
\chardef\percent = `\%
21\percent, {\it 19\percent}
% 排印出正体和意大利体的百分号
\endexample
\enddesc

\begindesc
^^{math characters}
^^{mathcodes}
\cts mathchardef {\<control sequence>=\<mathcode>}
\explain
这个命令把 \<control sequence> 定义为一个给定\minref{数学字符码}的数学字符.
这个控制序列仅在数学模式下有效
\example
\mathchardef\alphachar = "010B % 类似 plain TeX 的定义
$\alphachar$
|
\produces
\mathchardef\alphachar = "010B % 类似 plain TeX 的定义
$\alphachar$
\endexample
\eix^^{macros//defining}
\enddesc

%==========================================================================
\subsection {其它定义方法}

\begindesc
\cts let {\<control sequence> = \<token>}
\explain
^^{control sequences//defining with \b\tt\\let\e}
\minrefs{token}
这个命令会使得 \<control sequence> 去获取当前 \<token> 的含义.
即使你对 \<token> 重新定义,  \<control sequence> 的含义仍然不变.
虽然 \<token> 一般情况下都是一个控制序列,
它其实也可以是一个\minref{字符}标记.
\enddesc

\begindesc
\cts futurelet {\<control sequence> \<token$_1$> \<token$_2$>}
\explain
这个命令告诉 \TeX\ 把 \<token$_2$> 的设为 \<control sequence> 的定义
(可以由 |\let| 完成),
然后按正常的方式来处理 \<token$_1$> 和 \<token$_2$>.
在宏定义的最后 |\futurelet| 很有用, 因为它可以给你提供一个
在 \TeX\ 处理未处理的标记前, 查看它后面的标记的方法.
\example
\def\predict#1{\toks0={#1}\futurelet\next\printer}
% \next 会获取 \predict 后的标点符号.
\def\printer#1{一个 \punc\ 放在 \the\toks0 前. }
\def\punc{%
   \ifx\next;分号\else
      \ifx\next,逗号\else
         ``\next''\fi\fi}
\predict{三月}; \predict{四月}, \predict{七月}/
|
\produces
\def\predict#1{\toks0={#1}\futurelet\next\printer}
% \next 会获取 \predict 后的标点符号.
\def\printer#1{一个 \punc\ 放在 \the\toks0 前. }
\def\punc{%
   \ifx\next;分号\else
      \ifx\next,逗号\else
         ``\next''\fi\fi
   }
\predict{三月}; \predict{四月}, \predict{七月}/
\endexample
\enddesc

\begindesc
\cts csname {\<token list> {\bt \\endcsname}}
\xrdef{\endcsname}
\explain
这个命令可以由 \<token list> 产生一个控制序列.
它提供了一种把标记合并成控制序列的方式,
包括一些你一般情况下不能直接写的形式.
|\csname| 命令会把它们的标记使用和 |\edef| 替换文本相同的法则进行展开 (\xref\edef).
如果最后的展开会产生不是字符的东西, \TeX\ 会报错.
|\csname| 把一系列的标记转为一个控制序列;
你可以用 ^|\string| \ctsref\string 的方法做相反的事情.
\example
\def\capTe{Te}
本书关于 \csname\capTe X\endcsname.
|
\produces
\def\capTe{Te}
本书关于 \csname\capTe X\endcsname.
\endexample
\enddesc

%==========================================================================
\subsection {控制展开}

\begindesc
\bix^^{macros//controlling expansion of}
\cts expandafter {\<token$_1$> \<token$_2$>}
\explain
这个命令会让 \TeX\ 在展开一层 \<token$_2$> 后把 \<token$_1$> 根据\minref{宏}展开法则进行展开.
有时你想展开 \<token$_2$>,
而它前面有类似 `|{|' 或 ^|\string| 的东西阻止它的展开,
^^|{//with {\tt\\expandafter}|
这时这个命令会非常有用.
\example
\def\aa{xyz}
\tt % Use this font so `\' prints that way.
[\string\aa]  [\expandafter\string\aa]
[\expandafter\string\csname TeX\endcsname]
|
\produces
\def\aa{xyz}
\tt
[\string\aa]  [\expandafter\string\aa]
[\expandafter\string\csname TeX\endcsname]
\endexample
\enddesc

\begindesc
\cts noexpand {\<token>}
\explain
这个命令让 \TeX\ 跳过一个可以展开的标记 \<token> 的展开.
如果 \<token> 不能被展开, 比如它是一个字符,
\TeX\ 则不会理会 |\noexpand|, 而把 \<token> 按一般的方法处理.
\example
\def\bunny{免子}
\edef\magic{把 \noexpand\bunny\ 从帽子中取出!! }
% 如果没有 \noexpand, \bunny 会永远替换为 `免子'
\let\oldbunny=\bunny \def\bunny{免} \magic
\let\bunny=\oldbunny \magic
|
\produces
\def\bunny{免子}
\edef\magic{把 \noexpand\bunny\ 从帽子中取出!! }
% 如果没有 \noexpand, \bunny 会永远替换为 `免子'
\let\oldbunny=\bunny \def\bunny{免} \magic
\let\bunny=\oldbunny \magic
\endexample
\enddesc

\begindesc
\cts the {\<token>}
\explain
这个命令一般会把 \<token> 展开, 表示成一个\minref{字符}串.
其中 \<token>  可以是以下的任何形式:

\ulist\compact
\li \TeX\ \minref{参数}, 比如, |\parindent| 或者 |\deadcycles|
^^{parameters//using \b\tt\\the\e\ with}
\li \minref{寄存器}, 比如, |\count0|
^^{registers//with \b\tt\\the\e}
\margin{去除了特殊寄存器的那项}
\li 输入字符的字符码, 比如, |\catcode`(|
\li 字符参数, 比如, |\fontdimen3\sevenbf|
\li 字体的 ^|\hyphenchar| 或 ^|\skewchar|, 比如, |\skewchar\teni|
\li ^|\lastpenalty|, ^|\lastskip|, 或者 ^|\lastkern|
(当前的水平\minrefs{水平列表}或\minref{垂直列表}的最后一项的数值).
\li ^|\chardef| 或 ^|\mathchardef| 定义的控制序列
\endulist

\noindent
此外, |\the| 可以在下面两种情况下, 展开成非字符标记:
\ulist\compact
\li |\the| \<font>, 会展开成当前定义的控制序列,
这个控制序列和控制序列 \<font> 所选择的字体相同.
\li |\the| \<token variable>, 会复制变量的值, 并且对复本进行展开,
比如 |\the\everypar|
\endulist

请参阅 \knuth{页~214--215} 来获取 |\the| 在各种情况下行为的更详细描述.
\example
目前页面的竪直长度为 \the\vsize.
`(' 字符的类码是 \the\catcode `(.
|
\produces
目前页面的竪直长度为 \the\vsize.
`(' 字符的类码是 \the\catcode `(.
\endexample
\enddesc

{\tighten
\see \headcit{把信息改为标记}{convert},
|\showthe| (\xref\showthe).
\par}

\eix^^{macros//controlling expansion of}

%==========================================================================
\subsection {Conditional tests}

\begindesc
\xrdef{conds}
\bix^^{conditional tests}
%
\ctspecial if {\<token$_1$> \<token$_2$>}\ctsxrdef{@if}
\explain
{\emergencystretch=1em
This command tests if \<token$_1$> and \<token$_2$>
have the same \minref{character} code, independent of their
\minref{category code}s.
Before performing the test, \TeX\ expands tokens following the |\if|
until it obtains two tokens that can't be expanded further.
These two tokens become \<token$_1$> and \<token$_2$>.
The expansion
includes replacing  a control sequence |\let| equal to a character token
by that character token.
A \minref{control sequence} that can't be further expanded is
considered to have character code $256$.\par}
\example
\def\first{abc}
\if\first true\else false\fi;
% ``c'' is left over from the expansion of \first.
% It lands in the unexecuted ``true'' part.
\if a\first\ true\else false\fi;
% Here ``bc'' is left over from the expansion of \first
\if \hbox\relax true\else false\fi
% Unexpandable control sequences test equal with ``if''
|
\produces
\def\first{abc}
\if\first true\else false\fi;
% ``c'' is left over from the expansion of \first.
% It lands in the unexecuted ``true'' part.
\if a\first\ true\else false\fi;
% Here ``bc'' is left over from the expansion of \first
\if \hbox\relax true\else false\fi
% Unexpandable control sequences test equal with ``if''
\endexample
\enddesc

\begindesc
\ctspecial ifcat {\<token$_1$> \<token$_2$>}\ctsxrdef{@ifcat}
\explain
^^{category codes//testing}
This command tests if \<token$_1$> and \<token$_2$>
have the same \minref{category code}.
Before performing the test, \TeX\ expands tokens following the |\ifcat|
until it obtains two tokens that can't be expanded further.
These two tokens become \<token$_1$> and \<token$_2$>.
The expansion
includes replacing  a control sequence |\let| equal to a character token
by that character token.
A \minref{control sequence} that can't be further expanded is
considered to have category code $16$.
\example
\ifcat axtrue\else false\fi;
\ifcat ]}true\else false\fi;
\ifcat \hbox\day true\else false\fi;
\def\first{12345}
\ifcat (\first true\else false\fi
% ``2345'' lands in the true branch of the test
|
\produces
\ifcat axtrue\else false\fi;
\ifcat ]}true\else false\fi;
\ifcat \hbox\day true\else false\fi;
\def\first{12345}
\ifcat (\first true\else false\fi
% ``2345'' lands in the true branch of the test
\endexample
\enddesc

\begindesc
\ctspecial ifx {\<token$_1$> \<token$_2$>}\ctsxrdef{@ifx}
\explain
This command tests if \<token$_1$> and \<token$_2$> agree.
Unlike |\if| and |\ifcat|, |\ifx| does \emph{not} expand the tokens
following |\ifx|, so \<token$_1$> and \<token$_2$> are the two
tokens immediately after |\ifx|.
There are three cases:
\olist
\li If one token is a \minref{macro} and the other one isn't,
the tokens don't agree.
\li If neither token is a macro, the tokens agree if:
\olist
\li both tokens are characters (or control sequences denoting characters) and
their \minref{character} codes and \minref{category code}s agree, or
\li both tokens refer to the same \TeX\ command,
font, etc.
\endolist
\li If both tokens are macros, the tokens agree if:
\olist\compact
\li their ``first level'' expansions, i.e.,
their replacement texts, are identical, and
\li they have the same status with respect to ^|\long| (\xref\long)
and ^|\outer| (\xref\outer).
\endolist
Note in particular that \emph{any two undefined control
sequences agree}.
\endolist
\noindent
This test is generally more useful than |\if|.
\example
\ifx\alice\rabbit true\else false\fi;
% true since neither \rabbit nor \alice is defined
\def\a{a}%
\ifx a\a true\else false\fi;
% false since one token is a macro and the other isn't
\def\first{\a}\def\second{\aa}\def\aa{a}%
\ifx \first\second true\else false\fi;
% false since top level expansions aren't the same
\def\third#1:{(#1)}\def\fourth#1?{(#1)}%
\ifx\third\fourth true\else false\fi
% false since parameter texts differ
|
\produces
\ifx\alice\rabbit true\else false\fi;
% true since neither \rabbit nor \alice is defined
\def\a{a}%
\ifx a\a true\else false\fi;
% false since one token is a macro and the other isn't
\def\first{\a}\def\second{\aa}\def\aa{a}%
\ifx \first\second true\else false\fi;
% false since top level expansions aren't the same
\def\third#1:{(#1)}\def\fourth#1?{(#1)}%
\ifx\third\fourth true\else false\fi
% false since parameter texts differ
\endexample
\enddesc

\begindesc
\ctspecial ifnum {\<number$_1$> \<relation> \<number$_2$>}\ctsxrdef{@ifnum}
\explain
^^{numbers//comparing}
This command tests if \<number$_1$> and \<number$_2$>
satisfy \<relation>, which must be either `|<|', `|=|', or `|>|'.
The numbers can be constants such as |127|, count registers such as
|\pageno| or |\count22|, or numerical parameters such as |\hbadness|.
Before performing the test, \TeX\ expands tokens following the |\ifnum|
until it obtains a sequence of tokens having
the form \<number$_1$> \<relation> \<number$_2$>, followed by a token
that can't be part of \<number$_2$>.
\example
\count255 = 19 \ifnum \count255 > 12 true\else false\fi
|
\produces
\count255 = 19 \ifnum \count255 > 12 true\else false\fi
\endexample
\enddesc

\begindesc
\ctspecial ifodd {\<number>}\ctsxrdef{@ifodd}
\explain
^^{numbers//testing for odd/even}
This command tests if \<number> is odd.
Before performing the test, \TeX\ expands tokens following the |\ifodd|
until it obtains a sequence of tokens having the form \<number>,
followed by a token that can't be part of \<number>.
\example
\count255 = 19
\ifodd 5 true\else false\fi
|
\produces
\ifodd 5 true\else false\fi
\endexample
\enddesc

\begindesc
\ctspecial ifdim {\<dimen$_1$> \<relation> \<dimen$_2$>}\ctsxrdef{@ifdim}
\explain
^^{dimensions//comparing}
This command tests if \<dimen$_1$> and \<dimen$_2$>
satisfy \<relation>, which must be either `|<|', `|=|', or `|>|'.
The dimensions can be constants such as |1in|, dimension registers
such as |\dimen6|, or dimension parameters such as |\parindent|.
Before performing the test, \TeX\ expands tokens following the |\ifdim|
until it obtains a sequence of tokens having
the form \<dimen$_1$> \<relation> \<dimen$_2$>, followed by a token
that can't be part of \<dimen$_2$>.

\example
\dimen0 = 1000pt \ifdim \dimen0 > 3in true\else false\fi
|
\produces
\dimen0 = 1000pt \ifdim \dimen0 > 3in true\else false\fi
\endexample
\enddesc

\begindesc
\ctspecial ifhmode {}\ctsxrdef{@ifhmode}
\ctspecial ifvmode {}\ctsxrdef{@ifvmode}
\ctspecial ifmmode {}\ctsxrdef{@ifmmode}
\ctspecial ifinner {}\ctsxrdef{@ifinner}
\explain
^^{horizontal mode//testing for}
^^{vertical mode//testing for}
^^{math mode//testing for}
^^{internal mode//testing for}
These commands test what \minref{mode} \TeX\ is in:
\ulist
\li |\ifhmode| is true if \TeX\ is in ordinary or restricted horizontal mode.
\li |\ifvmode| is true if \TeX\ is in ordinary or internal vertical mode.
\li |\ifmmode| is true if \TeX\ is in text math or display math mode.
\li |\ifinner| is true if \TeX\ is in an ``internal'' mode:
restricted horizontal, internal vertical, or text math.
\endulist
\example
\def\modes{{\bf
   \ifhmode
      \ifinner IH\else H\fi
   \else\ifvmode
      \ifinner \hbox{IV}\else \hbox{V}\fi
   \else\ifmmode \hbox{M}\else
      error\fi\fi\fi}}
Formula $\modes$; then \modes,
   \hbox{next \modes\ and \vbox{\modes}}.
\par\modes
|
\produces
\def\modes{{\bf
   \ifhmode
      \ifinner IH\else H\fi
   \else\ifvmode
      \ifinner \hbox{IV}\fi
   \else\ifmmode \hbox{M}\else
      error\fi\fi\fi}}
Formula $\modes$; then \modes,
   \hbox{next \modes\ and \vbox{\modes}}.
\par\noindent{\bf V} % sorry folks, we have to fake this one
\endexample
\enddesc

\begindesc
\ctspecial ifhbox {\<register>}\ctsxrdef{@ifhbox}
\ctspecial ifvbox {\<register>}\ctsxrdef{@ifvbox}
\ctspecial ifvoid {\<register>}\ctsxrdef{@ifvoid}
\explain
^^{hboxes//testing for}
^^{vboxes//testing for}
^^{boxes//testing if void}
These commands test the contents of
the box register numbered \<reg\-ister>.
Let \<register> be $n$.  Then:
\ulist
\li |\ifhbox| is true if |\box|$\,n$ is an \minref{hbox}.
\li |\ifvbox| is true if |\box|$\,n$ is an \minref{vbox}.
\li |\ifvoid| is true if |\box|$\,n$ is void, i.e, doesn't have
a box in it.
\endulist
\example
\setbox0 = \vbox{} % empty but not void
\setbox1 = \hbox{a}
\setbox2 = \box1 % makes box1 void
\ifvbox0 true\else false\fi;
\ifhbox2 true\else false\fi;
\ifvoid1 true\else false\fi
|
\produces
\setbox0 = \vbox{}
\setbox1 = \hbox{a}
\setbox2 = \box1 % empties box1
\ifvbox0 true\else false\fi;
\ifhbox2 true\else false\fi;
\ifvoid1 true\else false\fi
\endexample
\enddesc

\begindesc
\ctspecial ifeof {\<number>}\ctsxrdef{@ifeof}
\explain
^^{end of file, testing for}
\minrefs{file}
This command tests an input stream for end of file.
It is true if input stream \<number> has not been opened,
or has been opened and the associated file has been entirely read in
(or doesn't exist).
\enddesc

\begindesc
\ctspecial ifcase
{\<number>\<case$_0$ text> {\bt \\or }\<case$_1$ text> {\bt \\or}
   $\ldots$ {\bt \\or} \<case$_n$ text>\hfil\break
\hglue 3pc{\bt \\else} \<otherwise text> {\bt \\fi}}
\ctsxrdef{@ifcase}
\ctsxrdef{@or}
\explain
^^{case testing}
This command introduces a test with numbered multiple cases.
If \<num\-ber> has the value $k$, \TeX\ will expand \<case$_k$ text> if
it exists, and \<other\-wise text> if it doesn't.  You can omit the |\else|---%
in this case, \TeX\ won't expand anything if none of the cases are satisfied.
\example
\def\whichday#1{\ifcase #1<day 0>\or Sunday\or Monday%
   \or Tuesday\or Wednesday\or Thursday\or Friday%
   \or Saturday\else Nonday\fi
   \ is day \##1. }
\whichday2 \whichday3 \whichday9
|
\produces
\def\whichday#1{\ifcase #1<day 0>\or Sunday\or Monday%
   \or Tuesday\or Wednesday\or Thursday\or Friday%
   \or Saturday\else Nonday\fi
   \ is day \##1. }
\whichday2 \whichday3 \whichday9
\endexample
\enddesc

\begindesc
\ctspecial iftrue {}\ctsxrdef{@iftrue}
\ctspecial iffalse {}\ctsxrdef{@iffalse}
\explain
These commands are equivalent to tests that are always true or always
false.  The main use of these commands is in defining macros that keep
track of the result of a test.
\example
\def\isbigger{\let\bigger=\iftrue}
\def\isnotbigger{\let\bigger=\iffalse}
% These \let's MUST be buried in macros!!  If they aren't,
% TeX erroneously tries to match them with \fi.
\def\test#1#2{\ifnum #1>#2 \isbigger\else\isnotbigger\fi}
\test{3}{6}
\bigger$3>6$\else$3\le6$\fi
|
\produces
\def\isbigger{\let\bigger=\iftrue}
\def\isnotbigger{\let\bigger=\iffalse}
% These \let's MUST be buried in macros!
% If they aren't, TeX erroneously tries to match them with \fi
\def\test#1#2{\ifnum #1>#2 \isbigger\else\isnotbigger\fi}
\test{3}{6}
\bigger$3>6$\else$3\le6$\fi
\endexample
\enddesc

\begindesc
\ctspecial else {} \ctsxrdef{@else}
\explain
This command introduces the ``false'' alternative of a conditional test.
\enddesc

\begindesc
\ctspecial fi {} \ctsxrdef{@fi}
\explain
This command ends the text of a conditional test.
\enddesc

\begindesc
\ctspecial newif {{\bt \\if}\<test name>}\ctsxrdef{@newif}
\explain
This command names a trio of control sequences with names |\alpha!-true|,
|\alphafalse|,
and |\ifalpha|, where |alpha| is \<test name>.
You can use them to define your own tests by
creating a logical variable that records
true\slash false information:
\ulist\compact
\li |\alphatrue| sets the  logical variable |alpha| true.
\li |\alphafalse| sets the logical variable |alpha| false
\li |\ifalpha| is a conditional test that is true if the logical
variable |alpha| is true and false otherwise.
\endulist
The logical variable |alpha| doesn't really exist, but \TeX\ behaves as
though it did.  After |\newif\ifalpha|, the logical variable is initially
false.

|\newif| is an outer command, so you can't use it inside a macro
definition.
\example
\newif\iflong  \longtrue
\iflong Rabbits have long ears.
\else Rabbits don't have long ears.\fi
|
\produces
\newif\iflong
\longtrue
\iflong Rabbits have long ears.\else Rabbits don't have long ears.\fi
\endexample
\eix^^{conditional tests}
\enddesc


%==========================================================================
\subsection {Repeated actions}

{\def\test{{\bt \\if}$\Omega$}%
\begindesc
\bix^^{repeated actions}
\bix^^{loops}
\cts loop {$\alpha$ {\test} $\beta$ {\bt \\repeat}}
\ctspecial repeat {}\ctsxrdef{@repeat}
\explain
These commands provide a looping construct for \TeX.
Here $\alpha$ and $\beta$ are arbitrary sequences of commands
and \test\ is any of the conditional tests described in
\headcit{Conditional tests}{conds}.
The |\repeat| replaces the |\fi| corresponding to the test,
so you must not write an explicit |\fi| to terminate the test.
Nor, unfortunately, can you associate an |\else| with the test.
If you want to use the test in the opposite sense, you need to
rearrange the test or
define an auxiliary test with |\newif| (see above) and use that
test in the sense you want (see the second example below).

\TeX\ expands |\loop| as follows:
\olist
\li $\alpha$ is expanded.
\li {\test} is performed.  If the result is false, the loop is terminated.
\li $\beta$ is expanded.
\li The cycle is repeated.
\endolist
\example
\count255 = 6
\loop
   \number\count255\
   \ifnum\count255 > 0
      \advance\count255 by -1
\repeat
|
\produces
\count255 = 6
\loop
   \number\count255\
   \ifnum\count255 > 0
      \advance\count255 by -1
\repeat
\nextexample
\newif\ifnotdone % \newif uses \count255 in its definition
\count255=6
\loop
   \number\count255\
   \ifnum\count255 < 1 \notdonefalse\else\notdonetrue\fi
   \ifnotdone
      \advance\count255 by -1
\repeat
|
\produces
\newif\ifnotdone
\count255=6
\loop
   \number\count255\
   \ifnum\count255 < 1 \notdonefalse\else\notdonetrue\fi
   \ifnotdone
      \advance\count255 by -1
\repeat
%
\eix^^{repeated actions}
\eix^^{loops}
%
\endexample
\enddesc
} % end scope of definition of \test

%==========================================================================
\subsection {Doing nothing}

\begindesc
\cts relax {}
\explain
This command tells \TeX\ to do nothing.  It's useful in a context where
you need to provide a command but there's nothing that you want \TeX\ to do.
\example
\def\medspace{\hskip 12pt\relax}
% The \relax guards against the possibility that
% The next tokens are `plus' or `minus'.
|

\endexample
\enddesc

\begindesc
\cts empty {}
\explain
This command expands to no tokens at all.
It differs from |\relax| in that it disappears after macro expansion.
%
\xrdef{mac2}% end the section on macros
\eix^^{macros}
\enddesc

%==========================================================================
\section {Registers}

%==========================================================================
\subsection {Using registers}

\begindesc
\bix^^{registers}
\makecolumns 11/2:
\cts count {\<register> {\bt =} \<number>}
\cts dimen {\<register> {\bt =} \<dimen>}
\cts skip {\<register> {\bt =} \<glue>}
\cts muskip {\<register> {\bt =} \<muglue>}
\cts toks {\<register> {\bt =} \<token variable>}
\aux\cts toks {\<register> {\bt =} \rqbraces{\<token list>}}
\aux\cts count {\<register>}
\aux\cts dimen {\<register>}
\aux\cts skip {\<register>}
\aux\cts muskip {\<register>}
\aux\cts toks {\<register>}
\explain
^^{assignments//of registers}
The first six commands listed here assign something to a register.
The |=|'s in the assignments are optional.
The remaining five control sequences are not true commands
because they can only appear as part of an argument.
They yield the contents of the specified register.
Although you can't use these control sequences by themselves as commands
in text,  you can use ^|\the| to convert them to text so that
you can typeset their values.

You can name and reserve registers
with the ^|\newcount| command and its relatives
(\xref{\@newcount}).
Using these commands is a safe way to obtain registers that
are known not to have any conflicting usage.

^^{count registers}
A |\count| register contains an integer, which can be either positive or
negative.
Integers can be as large as you're ever likely to need them to be.\footnote
{Here's the only exercise in this book: find out what's the largest
integer that \TeX\ will accept.}
\TeX\ uses count registers $0$--$9$ to keep track of the
page number (see \knuth{page~119}).
|\count255| is the only count register available for use
without a reservation.
\example
\count255 = 17 \number\count255
|
\produces
\count255 = 17 \number\count255
\endexample

\medskip\noindent
^^{dimension registers}
A |\dimen| register contains a dimension.
Registers |\dimen0| through |\dimen9| and |\dimen255| are available
for scratch use.

\example
\dimen0 = 2.5in
\hbox to \dimen0{$\Leftarrow$\hfil$\Rightarrow$}
|
\produces
\dimen0 = 2.5in
\hbox to \dimen0{$\Leftarrow$\hfil$\Rightarrow$}
\doruler{\8\8\8}3{in}
\endexample

\medskip\noindent
^^{skip registers}
A |\skip| register contains the dimensions of glue.
Unlike a |\dimen| register, it
records an amount of shrink and stretch as well as a natural size.
Registers |\skip0| through |\skip9| and |\skip255| are available
for use without a reservation.

\example
\skip2 = 2in
$\Rightarrow$\hskip \skip2 $\Leftarrow$
|
\produces
\skip2 = 2in
$\Rightarrow$\hskip \skip2 $\Leftarrow$\par
\noindent\hphantom{$\Rightarrow$}\ruler{\8\8}2{in}
\endexample

\medskip\noindent
^^{muskip registers}
A |\muskip| register is like a |\skip| register,
but the glue in it is always measured in ^|mu|
\seeconcept{mathematical unit}.
The size of a |mu| depends on the current font.
For example, it's usually a little
smaller in a subscript than in ordinary text.
Registers |\muskip0| through |\muskip9| and |\muskip255| are available
for use without a reservation.

\example
\muskip0 = 24mu % An em and a half, no stretch or shrink.
$\mathop{a \mskip\muskip0 b}\limits^{a \mskip\muskip0 b}$
% Note the difference in spacing.
|
\produces
\muskip0 = 24mu % an em and a half
$\mathop{a \mskip\muskip0 b}\limits^{a \mskip\muskip0 b}$
% Note the difference in spacing
\endexample

\medskip\noindent
^^{token registers}
You can assign either a token variable
(a register or a parameter) or a token list
to a |\toks| register.
When you assign a token list to a token register,
the tokens in the token list are \emph{not} expanded.

Once the tokens in a token list have been inserted into text
using ^|\the|, they are
expanded just like tokens that were read in directly.
They have the category codes that they received when \TeX\ first
saw them in the~\hbox{input}.

\example
\toks0 = {the \oystereaters\ were at the seashore}
% This assignment doesn't expand \oystereaters.
\def\oystereaters{Walrus and Carpenter}
\toks1 = \toks0
% the same tokens are now in \toks0 and \toks1
Alice inquired as to whether \the\toks1.
|
\produces
\toks0 = {the \oystereaters\ were at the seashore}
% This assignment doesn't expand \oystereaters
\def\oystereaters{Walrus and Carpenter}
\toks1 = \toks0
% the same tokens are now in \toks0 and \toks1
Alice inquired as to whether \the\toks1.
\endexample
\enddesc

\begindesc
\cts maxdimen {}
\explain
^^{dimensions//maximum}
This control sequence yields a \<dimen> that is the
largest dimension acceptable to \TeX\ (nearly 18 feet).
It is not a true command because it can only appear as part of an argument
to another command.
\example
\maxdepth = \maxdimen % Remove restrictions on \maxdepth.
|
\endexample
\enddesc

\see |\advance| (\xref\advance), |\multiply|,
|\divide| (\xref\divide), |\set!-box|, |\box| (\xref\box).

%==========================================================================
\subsection {Naming and reserving registers, etc.}

\begindesc
\bix^^{registers//reserving}
\makecolumns 11/2:
\ctspecial newcount \ctsxrdef{@newcount}
\ctspecial newdimen \ctsxrdef{@newdimen}
\ctspecial newskip \ctsxrdef{@newskip}
\ctspecial newmuskip \ctsxrdef{@newmuskip}
\ctspecial newtoks \ctsxrdef{@newtoks}
\ctspecial newbox \ctsxrdef{@newbox}
\ctspecial newread \ctsxrdef{@newread}
\ctspecial newwrite \ctsxrdef{@newwrite}
\ctspecial newfam \ctsxrdef{@newfam}
\ctspecial newinsert \ctsxrdef{@newinsert}
\ctspecial newlanguage \ctsxrdef{@newlanguage}
\explain
These commands
reserve and name an entity of the indicated type:
\ulist
{\tolerance = 5000
\fontdimen3\the\font = 2\fontdimen3\the\font % allow spaces to stretch more
\li |\new!-count|, |\newdimen|, |\newskip|, |\new!-mu!-skip|, |\new!-toks|,
and |\new!-box| each reserve a \minref{register} of the indicated type.
}
^^{count registers//reserved by \b\tt\\newcount\e}
^^{dimension registers//reserved by \b\tt\\newdimen\e}
^^{skip registers//reserved by \b\tt\\newskip\e}
^^{muskip registers//reserved by \b\tt\\newmuskip\e}
^^{token registers//reserved by \b\tt\\newtoks\e}
^^{box registers//reserved by \b\tt\\newbox\e}
\li |\newread| and |\newwrite| reserve an input stream and
an output stream \minrefs{input stream}\minrefs{output stream}
respectively.
^^{input streams//reserved by \b\tt\\newread\e}
^^{output streams//reserved by \b\tt\\newwrite\e}
\li |\newfam| reserves a \minref{family} of math fonts.
^^{family//reserved by \b\tt\\newfam\e}
\li |\newinsert| reserves an insertion type.
(Reserving an insertion type involves reserving several different registers.)
^^{insertions//numbers reserved by \b\tt\\newinsert\e}
\li |\newlanguage| reserves a set of hyphenation patterns.
\endulist
You should use these commands whenever you need one of these entities,
other than in a very local region,
in order to avoid numbering conflicts.

There's an important difference among these commands:
\ulist
\li The control sequences defined by
|\newcount|, |\newdimen|, |\newskip|, |\newmuskip|, and |\newtoks|
each designate an entity of the appropriate type.
For instance, after the command:
\csdisplay
\newdimen\listdimen
|
the control sequence |\listdimen| can be used as a dimension.
\li The control sequences defined by
|\newbox|, |\newread|, |\newwrite|, |\newfam|, |\newinsert|,
and |\newlanguage|  each
evaluate to the \emph{number} of an entity of the appropriate type.
For instance, after the command:
\csdisplay
\newbox\figbox
|
the control sequence |\figbox| must be used in conjunction with
a |\box|-like command, e.g.:
\csdisplay
\setbox\figbox = \vbox{!dots}
|
\endulist
\enddesc

\begindesc
\cts countdef {\<control sequence> {\bt =} \<register>}
\cts dimendef {\<control sequence> {\bt =} \<register>}
\cts skipdef {\<control sequence> {\bt =} \<register>}
\cts muskipdef {\<control sequence> {\bt =} \<register>}
\cts toksdef {\<control sequence> {\bt =} \<register>}
\explain
These commands define \<control sequence> to refer to the
\minref{register} of the indicated category whose number is \<register>.
Normally you should use the commands in the previous group
(|\newcount|, etc.) in preference to these commands in order to avoid
numbering conflicts.  The commands in the previous group are
defined in terms of the commands \hbox{in this group}.
\example
\countdef\hatters = 19 % \hatters now refers to \count19
\toksdef\hares = 200 % \hares now refers to \toks200
|
\endexample
\enddesc

\see |\newif| (\xref{\@newif}), |\newhelp| (\xref{\@newhelp}).
\eix^^{registers//reserving}

%==========================================================================
\subsection {Doing arithmetic in registers}

\begindesc
\bix^^{arithmetic}
\bix^^{registers//arithmetic in}
%
\cts advance {\<count register> {\bt by} \<number>}
\aux\cts advance {\<dimen register> {\bt by} \<dimen>}
\aux\cts advance {\<skip register> {\bt by} \<glue>}
\aux\cts advance {\<muskip register> {\bt by} \<muglue>}
\explain
This command adds a compatible quantity to a register.  For \<glue>
or \<muglue> all three components (natural value, stretch, and shrink)
\minrefs{glue} are added.
Any of the quantities can be negative.  For purposes of these calculations
(and other assignments as well), \<glue> can be converted to a
\<dimen> by dropping the stretch and shrink, and a \<dimen> can be converted
to a \<number> by taking its value in scaled points
\seeconcept{dimension}.
You can omit the word |by| in these commands---\TeX\ will understand them
anyway.
\example
\count0 = 18 \advance\count0 by -1 \number\count0\par
\skip0 = .5in \advance\skip0 by 0in plus 1in % add stretch
\hbox to 2in{a\hskip\skip0 b}
|
\produces
\count0 = 18 \advance\count0 by -1 \number\count0\par
\skip0 = .5in \advance\skip0 by 0in plus 1in % add stretch
\hbox to 2in{a\hskip\skip0 b}
\doruler{\8\8}2{in}
\endexample
\enddesc

\begindesc
\cts multiply {\<register> {\bt by} \<number>}
\cts divide {\<register> {\bt by} \<number>}
\explain
These commands multiply and divide the value in \<register>
by \<number> (which can be negative).
The register can be a ^|\count|, ^|\dimen|, ^|\skip|, or ^|\muskip|
register.
For a ^|\skip| or ^|\muskip| register (\xref\skip),
all three components of the \minref{glue} in the register are modified.
You can omit the word |by| in these commands---\TeX\ will understand them
anyway.

You can also obtain a multiple of a \<dimen> by preceding it by a \<number>
\minrefs{number}
or decimal constant, e.g.,
|-2.5\dimen2|.
You can also use this notation for \<glue>, but watch out---the result
is a \<dimen>, not \<glue>.
Thus |2\baselineskip| yields a \<dimen> that is twice the natural size
of |\baselineskip|, with no stretch or shrink.
\example
\count0 = 9\multiply \count0 by 8 \number\count0 ;
\divide \count0 by 12 \number\count0 \par
\skip0 = 20pt plus 2pt minus 3pt \multiply \skip0 by 3
Multiplied value of skip0 is \the\skip0.\par
\dimen0 = .5in \multiply\dimen0 by 6
\hbox to \dimen0{a\hfil b}
|
\produces
\count0 = 9\multiply \count0 by 8 \number\count0 ;
\divide \count0 by 12 \number\count0 \par
\skip0 = 20pt plus 2pt minus 3pt \multiply \skip0 by 3
Multiplied value of skip0 is \the\skip0.\par
\dimen0 = .5in \multiply\dimen0 by 6
\hbox to \dimen0{a\hfil b}
\doruler{\8\8\8}3{in}
\endexample

\eix^^{arithmetic}
\eix^^{registers//arithmetic in}
\eix^^{registers}
\enddesc

%==========================================================================
\section {Ending the job}

\begindesc
^^{ending the job}
\easy\ctspecial bye \ctsxrdef{@bye}
\explain
This command tells \TeX\ to fill out and produce the last page, print
any held-over \minref{insertion}s, and end the job.
It is the usual way to end your input file.
\enddesc

\begindesc
\cts end {}
\explain
This command tells \TeX\ to produce the last page and end the job.
It does not fill out the page, however,
so it's usually better to use |\bye| rather than |\end|.
\enddesc

%==========================================================================
\section {Input and output}

%==========================================================================
\subsection {Operations on input files}

\begindesc
\bix^^{files}
\bix^^{input files}
\easy\cts input {\<filename>}
\explain
\minrefs{file}\minrefs{file name}
This command tells \TeX\ to read its input from file \<filename>.
When that file is exhausted, \TeX\ returns to reading from its previous
input source.  You can nest input files to any level you like
(within reason).

When you're typesetting a large document, it's usually a good idea to
structure your main file as a sequence of |\input| commands that refer
to the subsidiary parts of the document.  That way you can process the
individual parts easily as you're working on drafts.  It's also a good
practice to put all of your \minref{macro} definitions into a separate file and
summon that file with an |\input| command as the first action in your
main file.

\TeX\ uses different rules for scanning file names than it does for scanning
\minref{token}s in general (see \xref{file name}).
If your implementation expects file names to have extensions (usually
indicated by a preceding dot), then \TeX\ provides a default extension
of |.tex|.
\example
\input macros.tex
\input chap1 % equivalent to chap1.tex
|
\endexample
\enddesc

\begindesc
\cts endinput {}
\explain
This command tells \TeX\ to stop reading input from the current file when it
next reaches the end of a line.
\enddesc

\begindesc
\cts inputlineno {}
\explain
This command yields a number (not a string) giving the line number of the
current line, defined to be the number that would appear in an error message
if an error occurred at this point.
\enddesc

\begindesc
\cts openin {\<number> {\bt =} \<filename>}
\explain
This command tells \TeX\ to open the file named \<filename>
and make it available for reading  via the input stream
designated by \<number>.
^^{input streams//opening}
\<number> must be between $0$ and $15$.
Once you've opened a file and connected it to an input stream,
you can read from the file using the |\read| command
with the input stream's number.

You can associate more than one input stream with the same
file.  You can then read from several different positions within
the file, one for each input stream.

You should allocate stream numbers for |\openin| using
|\new!-read| (\xref{\@newread}).
\example
\newread\auxfile  \openin\auxfile = addenda.aux
% \auxfile now denotes the number of this opening
% of addenda.aux.
|
\endexample
\enddesc

\begindesc\secondprinting{\vglue-.5\baselineskip\vskip0pt}
\cts closein {\<number>}
\explain
This command tells \TeX\ to close the \minref{input stream} numbered
\<number>, i.e.,
end the association between the input stream and its file.
The input stream with this number then becomes available for use with a
different file.
You should close an input stream once you're finished using its file.
\example
\closein\auxfile
|
\endexample
\enddesc

\begindesc\secondprinting{\vglue-.5\baselineskip\vskip0pt}
\cts read {\<number> {\bt to} \<control sequence>}
\explain
^^{input streams//reading with \b\tt\\read\e}
^^{reading a file}
This command tells \TeX\ to read a line from the file
associated with the \minref{input stream}
designated by \<number> and assign the tokens on that line to
\<control sequence>.  The \minref{control sequence} then becomes a
parameterless \minref{macro}.  No macro expansion takes place
during the reading operation.  If the line contains any unmatched
left braces, \TeX\ will read additional lines until the braces are
all matched.  If \TeX\ reaches the end of the file without matching all the
braces, it will complain.

If \<number> is greater than $15$ or hasn't been associated with a file
using ^|\openin|, \TeX\ prompts you with `\<control sequence> |=|'
on your terminal and waits for you to type a line of input.
It then assigns the input line to \<control sequence>.
If \<number> is less than zero, it reads a line of input from your
terminal but omits the prompt.
\example
\read\auxfile to \holder
% Expanding \holder will produce the line just read.
|
\endexample
\eix^^{input files}
\enddesc

\secondprinting{\vfill\eject}


%==========================================================================
\subsection {Operations on output files}

\bix^^{output files}
\begindesc
\cts openout {\<number> {\bt =} \<filename>}
\explain
^^{output streams//opening}
This command tells \TeX\ to open the file named \<filename>
and make it available for writing  via the \minref{output stream}
designated by \<number>.
\<number> must be between $0$ and $15$.
Once you've opened a file and connected it to an output stream,
you can write to the file using the |\write| command
with the output stream's number.

An |\openout| generates a whatsit that becomes part of a box.
The |\openout| does not take effect until \TeX\ ships out that box
to the \dvifile,
unless you've preceded the |\openout| with ^|\immediate|.

\TeX\ won't complain if you associate more than one output stream with the
same file, but you'll get garbage in the file if you try it!

You should allocate stream numbers for |\openout| using
|\newwrite| (\xref{\@newwrite}).
\example
\newwrite\auxfile  \openout\auxfile = addenda.aux
% \auxfile now denotes the number of this opening
% of addenda.aux.
|
\endexample
\enddesc

\begindesc
\cts closeout {\<number>}
\explain
^^{output streams//closing}
This command tells \TeX\ to close the \minref{output stream} numbered
\<number>. i.e.,
end the association between the output stream and its file.
The output stream with this number then becomes available for use with a
different file.
You should close an output stream once you're finished using its file.

A |\closeout| generates a whatsit that becomes part of a box.
The |\closeout| does not take effect until \TeX\ ships out that box
to the \dvifile,
unless you've preceded the |\closeout| with ^|\immediate|.
\example
\closeout\auxfile
|
\endexample
\enddesc

\begindesc
\cts write {\<number> \rqbraces{\<token list>}}
\explain
^^{output streams//writing}
^^{writing a file}
This command tells \TeX\ to write \<token list> to the file
associated with the \minref{output stream}
designated by \<number>.
It generates a whatsit that becomes part of a box.
The actual writing does not take place until \TeX\ ships out that box
to the \dvifile,
unless you've preceded the |\write| with ^|\immediate|.

For a |\write| that is not immediate, \TeX\ does not expand macros in
\<token list> until the token list is actually written to the file.
The macro expansions follow the same rules as |\edef| (\xref\edef).
In particular, any control sequence that is not
the name of a macro is written as
^|\escapechar| followed by the control sequence name
and a space.  Any `|#|' tokens
in \<token list> are doubled, i.e., written as `|##|'.

If \<number> is not in the range from $0$ to $15$, \TeX\ writes
\<token list> to the log file.
^^{log file//written by \b\tt\\write\e}
If \<number> is greater than $15$ or isn't associated with an output
stream, \TeX\ also writes \<token list> to the terminal.
\example
\def\aa{a a}
\write\auxfile{\hbox{$x#y$} \aa}
% Writes the string `\hbox {$x##y$} a a' to \auxfile.
|
\endexample
\enddesc

\begindesc
\cts immediate {}
\explain
This command should precede an |\openout|, |\closeout|, or |\write|.
^^|\write//with {\tt\\immediate}|
^^|\openout//with {\tt\\immediate}|
^^|\closeout//with {\tt\\immediate}|
It tells \TeX\ to perform the specified file operation without delay.
\example
\immediate\write 16{I'm stuck!!}
% has the same effect as \message
|
\endexample\enddesc

\begindesc
\cts special {\rqbraces{\<token list>}}
\explain
This command tells \TeX\ to
write \<token list> directly to the \dvifile\ when it next
ships out a page.
A typical use of |\special| would be to tell the device driver to incorporate
the contents of a named graphics file into the output page.
^^{device drivers//instructions from \b\tt\\special\e}
The |\special| command produces a whatsit that associates
\<token list> with a particular position on the page, namely,
the position that a zero-size box would have had if such a box
had appeared instead of the |\special| command.
Any use you might make of |\special| depends strictly on
the ^{device drivers} that you have available.
\example
\special{graphic expic}
% Display the graphics file `expic' here.
|
\endexample
\enddesc

\begindesc
\cts newlinechar {\param{number}}
\explain
This parameter contains a character that indicates a new line on
output.  When \TeX\ encounters this character
while reading the argument of
a |\write|, |\message|, or
|\errmessage| command, it starts a new line.
If |\newlinechar| is not in the range $0$--$255$,
there is no character that indicates
a new line on output.
\PlainTeX\ sets |\newlinechar| to $-1$.
\example
\newlinechar = `\^^J
\message{This message appears^^Jon two lines.}
|
\logproduces
This message appears
on two lines.
|
\endexample
\enddesc

\see |\newread|, |\newwrite| (\xref{\@newwrite}).
\eix^^{files}
\eix^^{output files}

%==========================================================================
\subsection {Interpreting input characters}

\begindesc
\cts catcode {\<charcode> \tblentry{number}}
\explain
^^{category codes//in \b\tt\\catcode\e\ table}
This table entry contains the \minref{category code} of the character
whose \ascii\ code is \<charcode>.
The category codes are listed on \xrefpg{catcodes}.
By changing the category code of a character you can get \TeX\ to treat
that character differently.
\example
\catcode `\[ = 1 \catcode `\] = 2
% Make [ and ] act like left and right braces.
|
\endexample
\enddesc

\begindesc
\cts active {}
\explain
This command contains the
category code for an active character, namely, the number $13$.
\example
\catcode `\@ = \active % Make @ an active character.
|
\endexample
\enddesc

\begindesc
\cts mathcode {\<charcode> \tblentry{number}}
\explain
This table entry contains the \minref{mathcode} of the character
whose \ascii\ code is \<charcode> \seeconcept{mathcode}.
The mathcode specifies that character's interpretation in math mode.
\example
\mathcode\> = "313E % as in plain TeX
% The > character has class 3 (relation), family 1 (math
% italic), and character code "3E
|
\endexample
\enddesc

\begindesc
\margin{{\tt\\delcode} was explained in two places.  This explanation
combines them.  (The other place was in the math section.)}
\cts delcode {\<charcode>\tblentry{number}}
\explain
^^{delimiter codes}
This table entry specifies the \minref{delimiter} code for the input character
whose \ascii\ code is \<charcode>.
The delimiter code tells \TeX\ how to find the best output character to use
for typesetting the indicated input character as a delimiter.

\<number> is normally written in hexadecimal notation.
Suppose that \<number> is the hexadecimal number $s_1s_2s_3\,
l_1l_2l_3$.  Then when the character is used as a delimiter,
\TeX\ takes the character to have small variant
$s_1s_2s_3$ and large variant $l_1l_2l_3$.  Here $s_1s_2s_3$ indicates
the math character found in position $s_2s_3$ of family $s_1$, and
similarly for $l_1l_2l_3$.  This is the same convention as the one
used for ^|\mathcode| (\xref \mathcode),
except that |\mathcode| also specifies a class.
\example
\delcode `( = "028300  % As in plain TeX.
|
\endexample
\enddesc

\begindesc
\cts endlinechar {\param{number}}
\explain
This parameter
contains the character code for the  character that
\TeX\ appends to the end of each input line.
^^{input lines}
A value not in the range $0$--$255$
indicates that no character should be appended.
\PlainTeX\ leaves |\end!-line!-char| at
|`\^^M| (the {\ascii} code for \asciichar{return}).
\enddesc

\begindesc
\cts ignorespaces {}
\explain
This command tells \TeX\ to read and expand tokens until it finds one that
is not a space \minref{token}, ignoring any space tokens
that it finds on the way.
|\ignorespaces| is often useful at the end of a \minref{macro} as a way
of making the macro insensitive to any spaces or ends of line
that might follow calls on it.
(An empty line after |\ignorespaces| still produces a |\par| token,
however.)
\example
\def\aa#1{yes #1\ignorespaces}
\aa{may}
be
|
\produces
\def\aa#1{yes #1\ignorespaces}
\aa{may}
be
\endexample
\enddesc

%==========================================================================
\section {Controlling interaction with \TeX}

\begindesc
\bix^^{controlling \TeX}
\bix^^{running \TeX}
\cts errorstopmode {}
\explain
This command tells \TeX\
to stop for interaction whenever it finds an error.
This is the normal mode of operation.
\enddesc

\begindesc
\cts scrollmode {}
\explain
This command tells \TeX\
not to stop for most errors,
but to continue displaying the error messages on your terminal.
Typing `|S|' or `|s|' in response to an error message puts you
into scroll mode.
\enddesc

\begindesc
\cts nonstopmode {}
\explain
This command tells \TeX\
not to stop for errors, even those pertaining to files that
it can't find, but to continue displaying the error messages on your terminal.
Typing `|R|' or `|r|' in response to an error message puts you
into nonstop mode.
\enddesc

\begindesc
\cts batchmode {}
\explain
This command tells \TeX\
not to stop for errors and to suppress all further output to your terminal.
Typing `|Q|' or `|q|' in response to an error message puts you
into batch mode.
\enddesc

\begindesc
\cts pausing {\param{number}}
\explain
If this parameter is greater than zero, \TeX\ will pause
at each line of input to give you an opportunity to
replace it with a different line.  If you type in a replacement,
\TeX\ will use that line instead of the original one; if you respond
with \asciichar{return}, \TeX\ will use the original line.

Setting |\pausing| to $1$ can be useful as a way of patching a document as
\TeX\ is processing it.  For example,
you can use this facility to insert ^|\show| commands (see below).
\eix^^{running \TeX}
\eix^^{controlling \TeX}
\enddesc

%==========================================================================
\section {Diagnostic aids}

\subsection{Displaying internal data}

\begindesc
\bix^^{tracing}
\bix^^{debugging}
\bix^^{diagnostic aids}
\cts show {\<token>}
\cts showthe {\<argument>}
\cts showbox {\<number>}
\cts showlists {}
\explain
These commands record information in the log of your \TeX\ run:
\ulist
\li |\show| records the meaning of \<token>.\minrefs{token}
^^{tokens//displayed by \b\tt\\show\e}
\li |\showthe| records
 whatever tokens would be produced by
|\the| \<arg\-u\-ment> (see \xref \the).
\li |\showbox| records the contents of the \minref{box}
\minref{register} numbered \<num\-ber>.
The number of
leading dots in the log indicates the number of
levels of nesting of inner boxes.
\li |\showlists| records
the contents of each list that \TeX\ is currently constructing.
(These lists are nested one within another.)
See \knuth{pages~88--89} for further information about interpreting
the output of |\showlists|.
\endulist
For |\show| and |\showthe|, \TeX\ also displays the information at your
^{terminal}.
For |\showbox| and |\showlists|, \TeX\ displays the information at your
terminal only
if ^|\tracingonline| (\xref \tracingonline) is greater than zero;
if ^|\tracingonline| is zero or less (the default case),
the information is not displayed.

Whenever \TeX\ encounters a |\show|-type command it
stops for interaction.  The request for interaction does \emph{not}
indicate an error, but it does give you an opportunity to ask \TeX\ to
show you something else.  If you don't want to see anything else, just
press \asciichar{return}.

You can control the amount of output produced by |\showbox| by setting
|\show!-box!-breadth| and |\show!-box!-depth| (\xref\showboxbreadth).
^^|\showboxbreadth| ^^|\showboxdepth|
These parameters respectively have default values of $5$
and $3$, which is why
just five items appear for each box described
in the log output below.  (The `|..etc.|' indicates additional items
within the boxes that aren't displayed.)
\example
\show a
\show \hbox
\show \medskip
\show &
|
\logproduces
> the letter a.
> \hbox=\hbox.
> \medskip=macro:
->\vskip \medskipamount .
> alignment tab character &.
|
\nextexample
\showthe\medskipamount
\toks27={\hbox{Joe's\quad\ Diner}}
\showthe\toks27
|
\logproduces
> 6.0pt plus 2.0pt minus 2.0pt.
> \hbox {Joe's\quad \ Diner}.
|
\nextexample
\setbox 3=\vbox{\hbox{A red dog.}\hrule A black cat.}
\showbox 3
|
\logproduces
> \box3=
\vbox(16.23332+0.0)x53.05565
.\hbox(6.94444+1.94444)x46.41675
..\tenrm A
..\glue 3.33333 plus 1.66498 minus 1.11221
..\tenrm r
..\tenrm e
..\tenrm d
..etc.
.\rule(0.4+0.0)x*
.\hbox(6.94444+0.0)x53.05565
..\tenrm A
..\glue 3.33333 plus 1.66498 minus 1.11221
..\tenrm b
..\tenrm l
..\tenrm a
..etc.
|
\endexample
\vfil\eject
\example
\vbox{A \hbox
   {formula
       $x \over y\showlists$}}
|
\logproduces
### math mode entered at line 3
\mathord
.\fam1 y
this will be denominator of:
\fraction, thickness = default
\\mathord
\.\fam1 x
### restricted horizontal mode entered at line 2
\tenrm f
\tenrm o
\tenrm r
\tenrm m
\kern-0.27779
\tenrm u
\tenrm l
\tenrm a
\glue 3.33333 plus 1.66666 minus 1.11111
spacefactor 1000
### horizontal mode entered at line 1
\hbox(0.0+0.0)x20.0
\tenrm A
\glue 3.33333 plus 1.66498 minus 1.11221
spacefactor 999
### internal vertical mode entered at line 1
prevdepth ignored
### vertical mode entered at line 0
prevdepth ignored
|
\endexample
\enddesc

\see |\showboxbreadth|, |\showboxdepth| \ctsref\showboxbreadth.

\subsection{Specifying what is traced}

\begindesc
\cts tracingonline {\param{number}}
\explain
If this parameter is greater than zero,
\TeX\ will display the results of tracing
(including ^|\showbox| and ^|\showlists|)
at your terminal in addition to recording them in the log file.
\enddesc

\begindesc
\cts tracingcommands {\param{number}}
\explain
If this parameter is $1$ or greater,
\TeX\ will record in the log file most commands that it executes.
If ^|\tracingonline| is greater than zero, this information will also appear
at your terminal.
Typesetting the first character of a word counts as a command,
but (for the purposes of the trace only)
the actions of typesetting the subsequent characters
and any punctuation following them
do not count as commands.
If |\tracingcommands| is $2$ or greater,
\TeX\ will also record commands that are expanded
rather than executed, e.g., conditional tests and their outcomes.
\example
\tracingcommands = 1 If $x+y>0$ we quit.\par
On the other hand, \tracingcommands = 0
|
\logproduces
{vertical mode: the letter I}
{horizontal mode: the letter I}
{blank space  }
{math shift character $}
{math mode: the letter x}
{the character +}
{the letter y}
{the character >}
{the character 0}
{math shift character $}
{horizontal mode: blank space  }
{the letter w}
{blank space  }
{the letter q}
{blank space  }
{\par}
{vertical mode: the letter O}
{horizontal mode: the letter O}
{blank space  }
{the letter t}
{blank space  }
{the letter o}
{blank space  }
{the letter h}
{blank space  }
{\tracingcommands}
|
\endexample
\enddesc

\begindesc
\cts tracinglostchars {\param{number}}
\explain
If this parameter is greater than zero,
\TeX\ will record an indication in the log file of each time
that it drops an output character because that character does not exist
in the current font.
If ^|\tracingonline| is greater than zero, this information will also appear
at your terminal.
\PlainTeX\ defaults it to $1$ (unlike the others).
\example
\tracinglostchars = 1
A {\nullfont few} characters.
|
\logproduces
Missing character: There is no f in font nullfont!!
Missing character: There is no e in font nullfont!!
Missing character: There is no w in font nullfont!!
|
\endexample
\enddesc

\begindesc
\cts tracingmacros {\param{number}}
\explain
If this parameter is $1$ or greater,
\TeX\ will record in the log file the expansion and arguments
of every macro that it executes.
^^{macros//tracing}
If |\tracingmacros| is $2$ or greater,
\TeX\ will record, in addition,
every expansion of a \minref{token} list such as
|\output| or |\everycr|.
If ^|\tracingonline| is greater than zero, this information will also appear
at your terminal.
\example
\def\a{first \b, then \c}
\def\b{b} \def\c{c}
\tracingmacros = 2
Call \a once.
|
\logproduces
\a ->first \b , then \c

\b ->b

\c ->c
|
\endexample
\enddesc

\begindesc
\cts tracingoutput {\param{number}}
\explain
If this parameter is greater than zero,
\TeX\ will record in the log file the contents of every box that
it sends to the \dvifile.
^^{\dvifile//boxes recorded in log file}
If ^|\tracingonline| is greater than zero, this information will also appear
at your terminal.
The number of leading dots in each line of the trace output indicates
the nesting level of the box at that line.
You can control the amount of tracing by setting
^|\showboxbreadth| and ^|\showboxdepth| (\xref\showboxbreadth).

Setting |\tracingoutput| to $1$ can be particularly helpful when you're trying
to determine why you've gotten ^{extra space} on a page.

\example
% This is the entire file.
\tracingoutput = 1 \nopagenumbers
One-line page. \bye
|
\logproduces
Completed box being shipped out [1]
\vbox(667.20255+0.0)x469.75499
.\vbox(0.0+0.0)x469.75499, glue set 13.99998fil
..\glue -22.5
..\hbox(8.5+0.0)x469.75499, glue set 469.75499fil
...\vbox(8.5+0.0)x0.0
...\glue 0.0 plus 1.0fil
..\glue 0.0 plus 1.0fil minus 1.0fil
.\vbox(643.20255+0.0)x469.75499, glue set 631.2581fill
..\glue(\topskip) 3.05556
..\hbox(6.94444+1.94444)x469.75499, glue set 386.9771fil
...\hbox(0.0+0.0)x20.0
...\tenrm O
...\tenrm n
...\tenrm e
...\tenrm -
...etc.
..\glue 0.0 plus 1.0fil
..\glue 0.0 plus 1.0fill
.\glue(\baselineskip) 24.0
.\hbox(0.0+0.0)x469.75499, glue set 469.75499fil
..\glue 0.0 plus 1.0fil
|
\endexample
\enddesc

\begindesc
\cts tracingpages {\param{number}}
\explain
If this parameter is greater than zero,
\TeX\ will record in the log file its calculations of the cost of
various page breaks that it tries.
^^{page breaks//tracing}
If |\tracing!-online| ^^|\tracingonline|
is greater than zero, this information will also appear
at your terminal.
\TeX\ produces a line of this output
whenever it first places a box or \minref{insertion}
on the current page list, and also whenever it processes a potential
break point for the page.
Examining this output can be helpful when you're trying to determine
the cause of a bad page break.
See \knuth{pages~112--114} for an illustration and explanation of
this output.

Some production forms of \TeX\ ignore the value of |\tracingpages|
so that they can run faster.
If you need to use this parameter, be sure to use a form that
responds to it.
\enddesc

\begindesc
\cts tracingparagraphs {\param{number}}
\explain
If this parameter is greater than zero,
\TeX\ will record in the log file its calculations of the cost of
various line breaks that it tries.
^^{line breaking//tracing}
If ^|\tracingonline| is greater than zero, this information will also appear
at your terminal.
\TeX\  produces this output when it reaches the end of each paragraph.
See \knuth{pages~98--99} for an illustration and explanation of
this output.

Some production forms of \TeX\ ignore the value of |\tracing!-para!-graphs|
so that they can run faster.
If you need to use this parameter, be sure to use a form that
responds to it.
\enddesc

\begindesc
\cts tracingrestores {\param{number}}
\explain
If this parameter is greater than zero,
\TeX\ will record in the log file
the values that it restores when it encounters the end of a \minref{group}.
If ^|\tracingonline| is greater than zero, this information will also appear
at your terminal.

Some production forms of \TeX\ ignore the value of |\tracing!-restores|
so that they can run faster.
If you need to use this parameter, be sure to use a form that
responds to it.
\enddesc

\begindesc
\cts tracingstats {\param{number}}
\explain
If this parameter is $1$ or greater, \TeX\ will
include a report on the resources that it used to run your job
(see \knuth{page~300} for a list and explanation of these resources).
Moreover, if |\tracingstats| is $2$ or greater,
\TeX\ will report on its memory usage whenever it does a
^|\shipout| (\xref \shipout) for a page.
The report appears at the end of the log file.
^^{log file//tracing statistics in}
If ^|\tracingonline| is greater than zero, the information will also appear
at your terminal.
If you're having trouble with \TeX\ exceeding one of its
capacities, the information provided by |\tracingstats| may help you
pinpoint the cause of the difficulty.

Some production forms of \TeX\ ignore the value of |\tracingstats|
so that they can run faster.
If you need to use this parameter, be sure to use a form that
responds to it.

The following example shows a sample of
the tracing output you'd get on one implementation
of \TeX.  It may be different on other implementations.
{\codefuzz = 1in
\example
\tracingstats=1
|
\logproduces
Here is how much of TeX's memory you used:
 4 strings out of 5540
 60 string characters out of 72328
 5956 words of memory out of 262141
 921 multiletter control sequences out of 9500
 14794 words of font info for 50 fonts, out of 72000 for 255
 14 hyphenation exceptions out of 607
 7i,4n,1p,68b,22s stack positions out of 300i,40n,60p,3000b,4000s
|
\endexample
}% end scope of codefuzz
\enddesc

\begindesc
\cts tracingall {}
\explain
This command tells \TeX\ to
turn on every available form of tracing.
It also sets ^|\tracingonline| to $1$ so that the trace output will appear
at your terminal.
\enddesc

\begindesc
\cts showboxbreadth {\param{number}}
\explain
This parameter specifies the maximum number of list items
that \TeX\ displays for one level of one box when it is producing
the output for ^|\showbox| or ^|\tracingoutput|.
\PlainTeX\ sets |\showboxbreadth| to $5$.
\enddesc

\begindesc
\cts showboxdepth {\param{number}}
\explain
This parameter specifies the
level of the deepest list that \TeX\ displays when
it is producing the output for ^|\showbox| or ^|\showlists|.
\PlainTeX\ sets |\showboxdepth| is $3$.
\eix^^{tracing}
\eix^^{debugging}
\eix^^{diagnostic aids}
\enddesc

%==========================================================================
\subsection {Sending messages}

\begindesc
\bix^^{messages, sending}
\bix^^{error messages}
\cts message {\rqbraces{\<token list>}}
\cts errmessage {\rqbraces{\<token list>}}
\explain
These commands display the message given by \<token list> on your
terminal and also enter it into the log.  Any \minref{macro}s in the
message are expanded, but no commands are executed.  This is the same rule
that \TeX\ uses for |\edef| (\xref \edef).

For |\errmessage|, \TeX\ pauses
in the same way that it does for one of its own error messages
and displays the |\errhelp| tokens if you ask for help.

You can generate multiline messages by using the ^|\newlinechar|
character (\xref \newlinechar).
\example
\message{Starting a new section.}
|
\endexample
\enddesc

\begindesc
\cts wlog {\rqbraces{\<token list>}}
\explain
This command writes \<token list> on the log file.
^^{log file//written by \b\tt\\wlog\e}
\minrefs{log file}
\TeX\ expands \<token list> according to the same rules that it uses
for |\edef| (\xref\edef).
\example
\wlog{Take two aspirins and call me in the morning.}
|
\logproduces
Take two aspirins and call me in the morning.
|
\endexample
\enddesc

\begindesc
\cts errhelp {\param{token list}}
\explain
This parameter contains the token list that \TeX\ displays
when you ask for help in response to an |\errmessage| command.
We recommend that when
you're generating an error message with |\errmessage|, you
set |\errhelp| to a string that describes the nature of the
error and use |\newhelp| to produce that string.
You can use the ^|\newlinechar| character to produce multiline messages.
\enddesc

\begindesc
\ctspecial newhelp \ctsxrdef{@newhelp} {\<control sequence>
   \rqbraces{\<help text>}}
\explain
This command assigns the ^{help message} given by \<help text> to
\<control sequence>.  It provides an efficient way of defining
the ^{help text} that further explains an error message.
Before issuing the error message with the |\errmessage| command,
you should assign \<control sequence> to ^|\errhelp|.  The help text
will then appear if the user types `|H|'
or `|h|' in response to the error message.
\example
\newhelp\pain{Your input includes a token that I find^^J
   to be offensive. Don't bother me again with this^^J
   document until you've removed it.}
\errhelp = \pain \newlinechar = `\^^J
% ^^J will start a new line
\errmessage{I do not appreciate receiving this token}
|
\logproduces
!! I do not appreciate receiving this token.
l.8 ...t appreciate receiving this token.}

? H
\Your input includes a token that I find
 to be offensive. Don't bother me again with this
 document until you've removed it.
|
\endexample
\enddesc

\begindesc
\cts errorcontextlines {\param{number}}
\explain
This parameter determines the number of pairs of context lines,
not counting the top and bottom pairs, that \TeX\ prints when it
encounters an error.  By setting it to $0$ you can get rid of long
error messages.
You can still force out the full context by typing something like:
\csdisplay
I\errorcontextlines=100\oops
|
in response to an error,
since the undefined control sequence |\oops| will cause another error.
\PlainTeX\ sets |\error!-context!-lines| to $5$.
\enddesc

\see |\write| (\xref \write), |\escapechar| (\xref \escapechar).
\eix^^{messages, sending}
\eix^^{error messages}

%==========================================================================
\section {初始化 \TeX}

\begindesc
\cts dump {}
\explain
这个命令不能使用在组中, 它可以把 \TeX\ 记录的内容导出成一个^{格式文件}
(\xref{format file}).
如果使用的是^|virtex| (这是一种 \TeX\ 形式\footnote{译者注, |virtex| 和 |initex| 在现代的 \TeX\ 系统中不再被使用. 在远古时代, 人们必需使用 |initex| 命令来导出格式文件, 用 |virtex| 命令载入格式文件, 而 |tex| 程序不能导出或载入格式文件. 而在现代的发行版中, |tex| 命令可以处理这一切},
你可以使用很快的速度载入这个格式文件,
载入后的 \TeX\ 状态和你当初导出格式文件时的状态并无二致.
|\dump| 命令会同时结束本次运行.
由于 |\dump| 只能在 ^|initex| 中运行,
而不是生产版本的 \TeX, 所以它仅仅在你安装 \TeX\ 时会用到.
\enddesc

\begindesc
\cts everyjob {\param{token list}}
\explain
This parameter contains a \minref{token} list that \TeX\ expands at the
start of every job.  Because an assignment to |\everyjob| cannot affect
the current run (by the time you've done the assignment it's already too
late), it is only useful to people who are preparing format files.
\enddesc


\enddescriptions \endchapter \byebye
