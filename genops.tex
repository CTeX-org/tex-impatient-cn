% -*- coding: utf-8 -*-
% This is part of the book TeX for the Impatient.
% Copyright (C) 2003 Paul W. Abrahams, Kathryn A. Hargreaves, Karl Berry.
% See file fdl.tex for copying conditions.

\input macros
%\chapter {Commands for \linebreak general operations}
\chapter {一般操作命令}

\chapterdef{general}

%This section covers
%\TeX's ^{programming features} and
%everything else that doesn't fit into the categories
%of commands in the previous chapters.
%For an explanation of the conventions used in this section,
%see \headcit{Descriptions of the commands}{cmddesc}.
这章介绍 \TeX\ 的^{编程功能}和不适合放入前几章的所有内容.
在 \headcit{命令描述}{cmddesc} 一节中, 给出了这章的惯例.

\begindescriptions

%==========================================================================
%\section {Naming and modifying fonts}
\section {命名及修改字体}

%\begindesc
%\bix^^{fonts//naming and modifying}
%\cts font {}
%\aux\cts font {\<control sequence> = \<fontname>}
%\aux\cts font {\<control sequence> = \<fontname> {\bt scaled} \<number>}
%\aux\cts font {\<control sequence> = \<fontname> {\bt at} \<dimen>}
%\explain
%Used alone, the |\font| control sequence designates the current font.
%|\font| isn't a true command when it's used alone,
%since it then can appear only as an argument to another command.
\begindesc
\bix^^{字体//命名及修改字体}
\cts font {}
\aux\cts font {\<control sequence> = \<fontname>}
\aux\cts font {\<control sequence> = \<fontname> {\bt scaled} \<number>}
\aux\cts font {\<control sequence> = \<fontname> {\bt at} \<dimen>}
\explain
单独使用时, |\font| 控制序列指代当前的字体.
|\font| 在这个时候并不是一个真正的命令,
它仅仅作为其它命令的一个参数.

%For the other three forms of |\font|,
%\<font\-name> names a set of files that define a font.
%These forms of |\font|  are commands.  Each of these forms has two effects:
%{\tighten
%\olist
%\li It defines \<control sequence> as a name that selects
%the font \<font\-name>, possibly magnified (see below).
%\li It causes \TeX\ to load the font ^{metrics file}
%(^{\tfmfile}) for \<fontname>.
%\endolist
%}% end tighten
其它的三个 |\font| 形式, 字体名 \<font\-name>
用来指代定义一个字体所需要的一系列文件.
在这些形式下, |\font| 是命令.
每种形式都有两个效果:
{\tighten
\olist
\li 它定义了一个名为 \<control sequence> 的控制序列,
用来选择名为 \<font\-name> 的字体, 而且该字体可能被缩放 (见后).
\li 它使 \TeX\ 载入 \<font\-name> 的^{字体信息文件} (^{\tfmfile}).
\endolist
}% end tighten

%\noindent
%The name of a font file usually indicates its design size.
%For example, |cmr10| indicates Computer Modern roman with a
%design size of $10$ points.
%The design size of a font is recorded in its metrics file.
\noindent
字体的名字往往表示它的设计大小,
比如 |cmr10| 表示设计大写为 $10$ 点的计算机现代字体.
字体的设计大小保存在字体信息文件中.

%If neither |scaled| \<number> nor |at| \<dimen>
%is present, the font is used
%at its design size---the size at which it usually looks best.
%Otherwise, a magnified version of the font is loaded:
%\ulist
%\li If |scaled| \<number>
%is present, the font is magnified by a factor of $\hbox{\<number>}/1000$.
%\li If |at| \<dimen> is present, the font is scaled to \<dimen> by magnifying
%it by $\hbox{\<dimen>}/ds$, where $ds$ is the design size of
%\<fontname>.
%\<dimen> and $ds$ are nearly always given in points.
%\endulist
%\noindent
%Magnifications of less than $1$ are possible; they reduce the size.
如果用户既没有指定 |scaled| \<number> 也没有指定 |at| \<dimen>,
那么这个字体载入时, 使用设计大小---设计大小的含意是,
字体在这个大小时, 表示最佳.
否则将会载入一个缩放版的字体:
\ulist
\li 如果指定了 |scaled| \<number>, 则字体将被放大 $\hbox{\<number>}/1000$ 倍.
\li 如果指定了 |at| \<dimen>, 则字体通过缩放大 $\hbox{\<dimen>}/ds$ 倍,
变为 \<dimen> 大小,
其中,  $ds$  是 \<fontname> 的设计大小.
\<dimen>  和 $ds$ 的单位往往使用点.
\endulist
\noindent
放大率可以小于 $1$, 这样做就会使字体缩小尺寸.

%You usually need to provide a shape file (\xref{shape}) for each
%magnification of a font that you load.
%However, some ^{device drivers} can utilize fonts that are resident
%in a printer. ^^{resident fonts}
%Such fonts don't need shape files.
你往往需要为载入的字体的每一个使用的放大率提供一个字体轮廓文件 (\xref{shape}).
当然, 一些^{设备驱动}可以使用打印机内置的字体.
^^{内置字体}这些字体不需要字体轮廓文件.

%See \conceptcit{font} and
%\conceptcit{magnification} for further information.
更多信息请参见\conceptcit{字体}和\conceptcit{放大率}.

%\example
%\font\tentt = cmtt10
%\font\bigttfont = cmtt10 scaled \magstep2
%\font\eleventtfont = cmtt10 at 11pt
%First we use {\tentt regular CM typewriter}.
%Then we use {\eleventtfont eleven-point CM typewriter}.
%Finally we use {\bigttfont big CM typewriter}.
%|
%\produces
%\font\regttfont = cmtt10
%\font\bigttfont = cmtt10 scaled \magstep 2
%\font\eleventtfont = cmtt10 at 11pt
%First we use {\regttfont regular CM typewriter}.
%Then we use {\eleventtfont eleven-point CM typewriter}.
%Finally we use {\bigttfont big CM typewriter}.
%\endexample
%\enddesc
\example
\font\tentt = cmtt10
\font\bigttfont = cmtt10 scaled \magstep2
\font\eleventtfont = cmtt10 at 11pt
First we use {\tentt regular CM typewriter}.
Then we use {\eleventtfont eleven-point CM typewriter}.
Finally we use {\bigttfont big CM typewriter}.
|
\produces
\font\regttfont = cmtt10
\font\bigttfont = cmtt10 scaled \magstep 2
\font\eleventtfont = cmtt10 at 11pt
First we use {\regttfont regular CM typewriter}.
Then we use {\eleventtfont eleven-point CM typewriter}.
Finally we use {\bigttfont big CM typewriter}.
\endexample
\enddesc

%\begindesc
%\cts fontdimen {\<number> \<font>\param{dimen}}
%\explain
%^^{fonts//parameters of}
%These parameters specify various dimensions associated with
%the font named by the control sequence \<font>
%(as distinguished from the \<font\-name> that names the font files).
%Values of these parameters are specified in the metrics
%file for \<font>, but you can
%retrieve or change their values during a \TeX\ run.
%The numbers and meanings of the parameters are:
%\display{\halign{\hfil#\hfil\quad&#\hfil\cr
%\it Number&\it Meaning\cr
%\noalign{\vskip 1\jot}%
%1&slant per point\cr
%2&interword space\cr
%3&interword stretch\cr
%4&interword shrink\cr
%5&x-height (size of |1ex|)\cr
%6&quad width (size of |1em|)\cr
%7&extra space\cr}}
%\noindent
%\TeX\ uses the slant per point for positioning accents.
%It uses the interword parameters for producing interword spaces
%(see |\spaceskip|, \xref\spaceskip) and the extra space parameter
%for the additional space after a period (see |\xspaceskip|,
%\xref\xspaceskip).
%The values of these parameters for the
%\plainTeX\ fonts are enumerated on \knuth{page~433}.
%Math symbol fonts have $15$ additional parameters, which we won't discuss here.
\begindesc
\cts fontdimen {\<number> \<font>\param{dimen}}
\explain
^^{字体//字体参数}
这些参数可以用来定义控制序列 \<font> (注意, \<font> 和 \<font\-name> 不同, \<font-name> 是用来表示字体文件的文件名的) 所定义的各种尺寸大小.
这些参数的值, 都在 \<font> 所使用的字体信息文件中定义了, 但是你可以在执行 \TeX\ 时得到或改变这些值.
这些参数的数值及其意义为:
\display{\halign{\hfil#\hfil\quad&#\hfil\cr
\it 数值&\it 意义\cr
\noalign{\vskip 1\jot}%
1&字体每点的倾斜程度\cr
2&词间距\cr
3&词间伸长长度\cr
4&词间收缩长度\cr
5&x 字符的高度(|1ex| 的长度)\cr
6&m 字符的宽度 (|1em| 的长度)\cr
7&额外空白长度\cr}}
\noindent
\TeX\ 需要使用字体每点的倾斜程度来计算重音符号的位置.
使用词间距来控制单词间的距离 (见 |\spaceskip|, \xref\spaceskip).
使用额外空白长度来控制句号以后所留的空白 (见 |\spaceskip|, \xref\spaceskip).
在 \knuth{433~页} 中列出了 \plainTeX\ 中字体所使用的这些参数的数值.
数学符号有另外 $15$ 个参数, 不过我们在此不展开讨论.

%Beware:
%assignments to these parameters are \emph{not} undone at the end
%of a group.
%If you want to change these parameters locally, you'll need to
%save and restore their original settings explicitly.
%\example
%Here's a line printed normally.\par
%\fontdimen2\font = 3\fontdimen2\font
%% Triple the interword spacing.
%\noindent Here's a really spaced-out line.
%|
%\produces
%Here's a line printed normally.\par
%\dimen0 = \fontdimen2\font % to undo global assignment
%\fontdimen2\font = 3\fontdimen2\font
%% triple the interword spacing
%\noindent Here's a really spaced-out line.
%\fontdimen2\font = \dimen0
%\endexample
%\enddesc
注意:
这些参数被设定后, 在当前组结束时, 并\emph{不}返回初始值.
如果你只是希望在局部的文本中改变这些值,
你需要将它的原值保存, 以便稍后恢复.
\example
Here's a line printed normally.\par
\fontdimen2\font = 3\fontdimen2\font
% Triple the interword spacing.
\noindent Here's a really spaced-out line.
|
\produces
Here's a line printed normally.\par
\dimen0 = \fontdimen2\font % to undo global assignment
\fontdimen2\font = 3\fontdimen2\font
% triple the interword spacing
\noindent Here's a really spaced-out line.
\fontdimen2\font = \dimen0
\endexample
\enddesc

%\begindesc
%\cts magnification {{\bt =} \<number>}
%\cts mag {\param{number}}
%\explain
%\margin{{\tt\\mag} and {\tt\\magnification} combined.}
%An assignment to |\magnification| establishes
%the ``^{scale factor}'' $f$ that determines
%the \minref{magnification} ratio of your document \seeconcept{magnification}.
%The assignment to |\magni!-fication| must occur before the first page
%of your document has been shipped out.
\begindesc
\cts magnification {{\bt =} \<number>}
\cts mag {\param{number}}
\explain
\margin{合并了 {\tt\\mag} 和 {\tt\\magnification}.}
使用 |\magnification| 可以定义“^{缩放因子}”$f$，
缩放因子决定了你的文档的\minref{放大率}\seeconcept{放大率}。
|\magni!-fication|必须在文档的第一页被编译出前定义。

%The assignment sets $f$ to \<number> and also
%sets |\hsize| and |\vsize|
%^^|\hsize//set by {\tt\\magnification}|
%^^|\vsize//set by {\tt\\magnification}|
%respectively to |6.5true in| and |8.9true in|,
%the values appropriate for an $8 \frac1/2$-%
%by-$11$-inch page.
%$f$ must be between $0$ and $32768$.
%The \minref{magnification} ratio of the
%document is $f/1000$.
%A scale factor
%of $1000$ provides unit magnification, i.e., it leaves the size of your
%document
%unchanged.  It's customary to use powers of $1.2$ as scale factors, and
%most libraries of fonts are based on such factors.  You can use the
%^|\magstep| and ^|\magstephalf| commands to specify magnifications by
%these factors.
这个命令把 $f$ 定义成 \<number> 的同时，
也会定义 |\hsize| 为 |6.5true in|，|\vsize| 为 |8.9true in|，
^^|\hsize//用 {\tt\\magnification} 设定|
^^|\vsize//用 {\tt\\magnification} 设定|
即适合 $8 \frac1/2$ 英尺乘 $11$ 英尺的页面的大小。
缩放因子 $f$ 的值必需介于 $0$ 到 $32768$ 之间，
它确定了该文档的\minref{放大率}为 $f/1000$。
因此缩放因子为 $1000$ 就给出了单位放大率，也就是说，它不改变文档的尺寸。
我们习惯使用 $1.2$ 的幂次值来定义缩放因子，
因为很多的字体就是基于这种因子的。
用 ^|\magstep| 和 ^|\magstephalf| 命令你可以更方便地定义这种因子。

%|\magnification| is not a parameter. You can't use it
%to \emph{retrieve} the scale factor.  If you write something like
%|\dimen0 = \mag!-nifi!-cation|, \TeX\ will complain about it.
|\magnification| 不是一个参数，你不能使用它来得到缩放因子。
如果你使用类似 |\dimen0 = \mag!-nifi!-cation| 之类的语句，
\TeX\ 将会报错。

%The |\mag| parameter contains the scale factor.
%Changing the value of |\mag| rescales the page dimensions, which is not
%usually what you want.
%Therefore it's usually better to change the magnification by
%assigning to |\magnification| rather than to |\mag|.
而 |\mag| 参数则包含缩放因子。
改变 |\mag| 的值也缩放了页面尺寸，而这一般不是你所想要的。
因此，一般情况下，
最好是使用 |\magnification| 而不是 |\mag| 来改变页面的放大率。%
\footnote{译注：|\mag| 是 \TeX\ 的原始命令，
而 |\magnification| 是 \plainTeX\ 中定义的命令。
|\magnification| 依赖于 |\mag|，
它用 |\mag| 设置放大率后恢复了默认的页面尺寸。
在 LaTeX 中没有 |\magnification| 命令，
一般也不建议使用 |\mag| 命令，因为这与 LaTeX 的设计原则相悖。
}

%\example
%\magnification = \magstep2
%% magnify fonts by 1.44 (=1.2x1.2)
%|
%\endexample
%\enddesc
\example
\magnification = \magstep2
% 把字体放大 1.44 倍 (=1.2x1.2)
|
\endexample
\enddesc

%\begindesc
%\cts magstep {\<number>}
%\explain
%This command expands to the \minref{magnification} ratio needed to
%magnify everything in your document
%(other than |true| dimensions)
%by $1.2^r$, where $r$ is
%the value of \<number>. \<number> must be between $0$ and $5$.
%\example
%\magnification = \magstep1 % Magnify by ratio of 1.2.
%|
%\endexample
%\enddesc
\begindesc
\cts magstep {\<number>}
\explain
这个命令展开为一个\minref{放大率}因子，
这个因子可以把你文档中所有（除了给定 |true| 尺寸的）东西放大 $1.2^r$ 倍，
其中 $r$ 是 \<number> 的值。
\<number> 必须在 $0$ 到 $5$ 之间。%
\footnote{译注：即在 \plainTeX\ 中定义 |\magstep1| 为 1200，|\magstep2| 为 1440，等等。}
\example
\magnification = \magstep1 % 放大 1.2 倍.
|
\endexample
\enddesc

%\begindesc
%\cts magstephalf {}
%\explain
%This command expands to the \minref{magnification} ratio needed to
%magnify everything in your document
%(other than |true| dimensions)
%by $\sqrt{1.2}$,
%i.e., halfway between $1$ and $1.2$.
%\example
%\magnification = \magstephalf
%|
%\endexample
%\eix^^{fonts//naming and modifying}
%\enddesc
\begindesc
\cts magstephalf {}
\explain
这个命令展开为一个\minref{放大率}因子，
这个因子可以把你文档中所有（除了给定 |true| 尺寸的）东西放大 $\sqrt{1.2}$ 倍，
也就是 $1$ 和 $1.2$ 的等比中项。%
\footnote{译注：即在 \plainTeX\ 中定义 |\magstephalf| 为 1095。}
\example
\magnification = \magstephalf
|
\endexample
\eix^^{字体//命名及修改字体}
\enddesc

%==========================================================================
%\section {Converting information to tokens}
\section {把信息转为记号}

%\subsection {Numbers}
\subsection {数值}

%\begindesc
%\xrdef{convert}
%\bix^^{numbers//converting to characters}
%%
%\cts number {\<number>}
%\explain
%This command produces the representation of a \minref{number}
%as a sequence of
%character \minref{token}s.  The number can be either an explicit integer,
%a \<number> parameter, or a \<number> register.
%\example
%\number 24 \quad \count13 = -10000 \number\count13
%|
%\produces
%\number 24 \quad \count13 = -10000 \number\count13
%\endexample
%\enddesc
\begindesc
\xrdef{convert}
\bix^^{数值//转换为字符}
%
\cts number {\<number>}
\explain
这个命令可以把一个\minref{数}表示成字符\minref{记号}序列。
这里的数可以是一个确定的整数，或是一个 \<number> 参数，
也可以是一个 \<number> 寄存器。
\example
\number 24 \quad \count13 = -10000 \number\count13
|
\produces
\number 24 \quad \count13 = -10000 \number\count13
\endexample
\enddesc

%\begindesc
%^^{Roman numerals}
%\easy\cts romannumeral {\<number>}
%\explain
%This command produces the roman numeral representation of a \minref{number}
%as a sequence of
%character \minref{token}s.  The number can be either an explicit integer,
%a \<number> parameter, or a \<number> register.
%If the number is zero or negative, |\romannumeral| produces
%no tokens.
%\example
%\romannumeral 24 \quad (\romannumeral -16)\quad
%\count13 = 6000 \romannumeral\count13
%|
%\produces
%\romannumeral 24 \quad (\romannumeral -16)\quad
%\count13 = 6000 \romannumeral\count13
%\endexample
%
%\eix^^{numbers//converting to characters}
%\enddesc
\begindesc
^^{罗马数字}
\easy\cts romannumeral {\<number>}
\explain
这个命令可以把一个\minref{数}表示成罗马字符\minref{记号}序列.
这里的数可以是一个确定的整数，或是一个 \<number> 参数，
也可以是一个 \<number> 寄存器。
如果这个数是负的，则 |\romannumeral| 不产生任何记号。
\example
\romannumeral 24 \quad (\romannumeral -16)\quad
\count13 = 6000 \romannumeral\count13
|
\produces
\romannumeral 24 \quad (\romannumeral -16)\quad
\count13 = 6000 \romannumeral\count13
\endexample

\eix^^{数值//转换为字符}
\enddesc

%==========================================================================
%\subsection {Environmental information}
\subsection {环境信息}

%\begindesc
%^^{time of day}
%\cts time {\param{number}}
%\explain
%\TeX\ sets this parameter to the
%number of minutes that have elapsed since midnight (of the current day).
%At noon, for instance, |\time| is $720$.
%This command and the next three make use of the time and date as
%recorded in your computer.
%\TeX\ retrieves them just once, at the beginning of your run, so |\time|
%at the end of the run always has the same value as |\time| at the
%beginning of the run (unless you've explicitly changed it).
%\enddesc
\begindesc
^^{日期时间}
\cts time {\param{number}}
\explain
\TeX\ 把这个参数设置为从当日午夜到现在所经过的分钟数.
比如在中午, |\time| 就是 $720$.
这个命令和下面的三个命令使用的是你计算机中所记录的时间.
\TeX\ 只在开始运行的时候向系统获取一次时间,
所以如果你不改变这个值的话,
先前运行的 |\time| 和最后运行的 |\time| 的值是完全相同的.
\enddesc

%\bix^^{date}
%\begindesc
%\cts day {\param{number}}
%\explain
%\TeX\ sets this parameter to the current day of the month.  It is
%a number between $1$ and $31$.
%|\day| is set at the beginning of your run (see the comments on
%|\time| above).
%\enddesc
\bix^^{日期}
\begindesc
\cts day {\param{number}}
\explain
\TeX\ 把这个参数设置为今天的日期数.
这是一个介于 $1$ 和 $31$ 之间的数.
|\day| 只在程序开始运行的时候被设定 (见上面 |\time| 的说明).
\enddesc

%\begindesc
%\cts month {\param{number}}
%\explain
%\TeX\ sets this parameter to the current month.  It is
%a number between $1$ and $12$.
%|\month| is set at the beginning of your run (see the comments on
%|\time| above).
%\enddesc
\begindesc
\cts month {\param{number}}
\explain
\TeX\ 把这个参数设置为当前的月份.
这是一个介于 $1$ 和 $12$ 之间的数.
|\time| 只在程序开始运行的时候被设定 (见上面 |\time| 的说明).
\enddesc

%\begindesc
%\cts year {\param{number}}
%\explain
%\TeX\ sets this parameter to the current year ({\sc A.D.}).
%It is a number such as $1991$.
%|\year| is set at the beginning of your run (see the comments on
%|\time| above)
\begindesc
\cts year {\param{number}}
\explain
\TeX\ 把这个参数设置为当前的 ({\sc 公元}) 年份.
这是一个类似 $1991$ 之类的数.
|\year| 只在程序开始运行的时候被设定 (见上面 |\time| 的说明).

%\eix^^{date}
%\enddesc
\eix^^{日期}
\enddesc

%\begindesc
%^^{version number}
%\cts fmtname {}
%\cts fmtversion {}
%\explain
%These commands produce the name and version number
%of the \TeX\ format,
%e.g., \minref{\plainTeX} or ^{\LaTeX}, that you're using.
%\example
%This book was produced with the \fmtname\ format,
%version~\fmtversion.
%|
%\produces
%This book was produced with the \fmtname\ format,
%version~\fmtversion.
%\endexample
%\enddesc
\begindesc
^^{版本号}
\cts fmtname {}
\cts fmtversion {}
\explain
这个命令会产生当前使用的 \TeX\ 格式（比如 \minref{\plainTeX} 或 ^{\LaTeX}）的名字和版本号。
\example
本书使用 \fmtname\ 格式，版本~\fmtversion 。
|
\produces
本书使用 \fmtname\ 格式，版本~1.9: 26 April 1991 (and plain 3.141592653)。
\endexample
\enddesc

%\begindesc
%\cts jobname {}
%\explain
%This command produces the base
%name of the file with which \TeX\ was invoked.
%For example, if your main input file is |hatter.tex|,
%|\jobname| will expand to |hatter|.
%|\jobname| is most useful when you're
%creating an auxiliary file to be associated with a document.
%^^{auxiliary files}
%\example
%\newwrite\indexfile  \openout\indexfile = \jobname.idx
%% For input file `hatter.tex', open index file `hatter.idx'.
%|
%\endexample\enddesc
\begindesc
\cts jobname {}
\explain
这个命令产生调用 \TeX\ 的文件的文件本名.
比如你的输入文件为 |hatter.tex|, |\jobname| 会被展开成 |hatter|.
|\jobname| 在你生成文档的辅助文件时会很管用.
^^{辅助文件}
\example
\newwrite\indexfile  \openout\indexfile = \jobname.idx
% 打开 `hatter.tex' 的索引文件 `hatter.idx'.
|
\endexample\enddesc

%==========================================================================
\subsection {变量的值}

\begindesc
\cts meaning {\<token>}
\explain
^^{记号//显示记号的含义}
这个命令会产生 \<token> 的定义.
它对于诊断输出很有用.
你可以用类似的方法使用 ^|the| 命令 (\xref\the) 来得到 \minref{寄存器}和其它 \TeX\ 中的东西的值信息.
\example
[{\tt \meaning\eject}] [\meaning\tenrm] [\meaning Y]
|
\produces
[{\tt \meaning\eject}] [\meaning\entenrm] [\meaning Y]
\endexample\enddesc

\begindesc
\cts string {\<control sequence>}
\explain
^^{控制序列//转换为字符串}
这个命令会把 \<control sequence> 表示成其名字的字符串,
包括 \minref{转义符}.
转义符会被表示成当前 ^|\escapechar| 的值.
^^{转义符//用 \b\tt\\escapechar\e 表示}
\TeX\ 把在此中的所有字符的类码设为 $12$ (其它).

你可以使用 ^|\csname| 命令执行这个命令的反操作 (\xref\csname).
它会把一个字符串转为一个控制序列.
\example
控制序列 {\tt \string\bigbreak}
|
\produces
控制序列 {\tt \string\bigbreak}
\endexample\enddesc

\begindesc
\cts escapechar {\param{number}}
\explain
这个参数在把一个控制序列名转化为一系列字符标记时, 指定 \TeX\ 用来表示\minref{转义符}的字符的 \ascii\ 码\minrefs{ascii}.
^^{转义符//用 \b\tt\\escapechar\e 表示}
这个转化发生在你使用 |\string|命令时或者 \TeX\ 在产生诊断信息时.
转义符的默认值是 $92$, 即 ^{右斜杠} 的 \ascii\ 码.
如果 |\escapechar| 不在 $0$--$255$ 之间, \TeX\ 则在转换时不包括转义符.
\example
\escapechar = `!!
控制序列 {\tt \string\bigbreak}
|
\produces
\escapechar = `!
控制序列 {\tt \string\bigbreak}
\endexample
\enddesc

\begindesc
\cts fontname {\<font>}
\explain
^^{字体名称}
这个命令产生 \<font> 的字体文件名.
该字体名就是定义 \<font> 时所的 \<font\-name>.
\example
\font\myfive=cmr5 [\fontname\myfive]
|
\produces
\font\myfive=cmr5 [\fontname\myfive]
\endexample
\enddesc


%==========================================================================
%\section {Grouping}
\section {编组}

%\begindesc
%\bix^^{groups}
\begindesc
\bix^^{编组}
%
%\cts begingroup {}
%\cts endgroup {}
%\explain
%These two commands begin and end a \minref{group}.
%A |\begingroup| does not match up with a right brace,
%nor an |\endgroup| with a left brace.
\cts begingroup {}
\cts endgroup {}
\explain
这两个命令开始或结束一个\minref{编组}。
|\begingroup| 不会和右花括号匹配，|\endgroup| 也不会和左花括号匹配。

%\TeX\ treats |\begingroup| and |\endgroup| like any other
%\minref{control sequence} when it's scanning its input.  In particular,
%you can define a \minref{macro} that contains a |\begingroup|
%but not an |\endgroup|, and conversely.
%^^{macros//using \b\tt\\begingroup\e\ and \b\tt\\endgroup\e\ in}
%This technique is often useful
%when you're defining paired macros, one of which establishes
%an environment and the other of which terminates that environment.
%You can't, however, use |\begingroup| and |\endgroup| as substitutes for
%braces other than the ones that surround a group.
%\example
%\def\a{One \begingroup \it two }
%\def\enda{\endgroup four}
%\a three \enda
%|
%\produces
%\def\a{One \begingroup \it two }
%\def\enda{\endgroup four}
%\a three \enda
%\endexample
%\enddesc
在扫描输入时，\TeX\ 如同其它\minref{控制序列}一样对待 |\begingroup| 和 |\endgroup|。
尤其体现在，你可以定义一个包括 |\begingroup| 但不包括 |\endgroup| 的宏，
或者与之相反。
^^{宏//使用 \b\tt\\begingroup\e\ 和 \b\tt\\endgroup\e}
这个技巧往往在你定义一对宏时会非常有用，一个用来开始一个环境，
另一个用来结束这个环境。
但是你不可以使用 |\begingroup| 和 |\endgroup|
来替换除了用来括起一个组以外功能的花括号。
\example
\def\a{一 \begingroup \it 二 }
\def\enda{\endgroup 四}
\a 三 \enda
|
\produces
\def\a{一 \begingroup \it 二 }
\def\enda{\endgroup 四}
\a 三 \enda
\endexample
\enddesc

%\begindesc
%\makecolumns 4/2:
%\easy%
%\ctsact { \xrdef{@lbrace}
%\cts bgroup {}
%\ctsact } \xrdef{@rbrace}
%\cts egroup {}
%\explain
%The left and right braces are commands that begin and end a
%\minref{group}.
%The |\bgroup| and |\egroup| \minref{control sequence}s are equivalent
%to `|{|' and `|}|', except that
%\TeX\ treats |\bgroup| and |\egroup| like any other
%\minref{control sequence} when it's scanning its input.
\begindesc
\makecolumns 4/2:
\easy%
\ctsact { \xrdef{@lbrace}
\cts bgroup {}
\ctsact } \xrdef{@rbrace}
\cts egroup {}
\explain
左花括号和右花括号命令的作用是用来开始或结束一个\minref{编组}。
除了在扫描输入时 \TeX\ 会把 |\bgroup| 和 |\egroup|
像其它\minref{控制序列}一样对待以外，
|\bgroup| 和 |\egroup| \minref{控制序列}与 `|{|' 和 `|}|'是等价的。

%|\bgroup| and |\egroup| can be useful when you're
%defining paired macros, one of which
%starts a brace-delimited construct (not necessarily a group)
%and the other one of which ends that construct.
%^^{macros//using \b\tt\\bgroup\e\ and \b\tt\\egroup\e\ in}
%You can't define such macros using ordinary braces---if you try,
%your macro definitions will contain unmatched braces
%and will therefore be unacceptable to \TeX.
%Usually you should use these commands only when you can't use
%ordinary braces.
当你定义两个成对的宏时，|\bgroup| 和 |\egroup| 会非常有用。
这两个宏中其中一个开始一个由花括号定界的结构（不一定是一个组），
而另一个结束该结构。
^^{宏//用 \b\tt\\bgroup\e\ 和 \b\tt\\egroup\e}
你不能使用常规的花括号来定义这样的宏，否则你的宏定义会包含没有匹配的花括号，
而这样的定义是不被 \TeX\ 所接受的。
一般情况下你需要在你没有办法使用花括号时使用这些命令。

%\example
%Braces define the {\it boundaries\/} of a group.
%|
%\produces
%Braces define the {\it boundaries\/} of a group.
%\nextexample
%\def\a{One \vbox\bgroup}
%% You couldn't use { instead of \bgroup  here because
%% TeX would not recognize the end of the macro
%\def\enda#1{{#1\egroup} two}
%% This one is a little tricky, since the \egroup actually
%% matches a left brace and the following right brace
%% matches the \bgroup.  But it works!!
%\a \enda{\hrule width 1in}
%|
%\produces
%\def\a{One \vbox\bgroup}
%% You couldn't use { instead of \bgroup  here because
%% TeX would not recognize the end of the macro
%\def\enda#1{{#1\egroup} two}
%% This one is a little tricky, since the \egroup actually
%% matches a left brace and the following right brace
%% matches the \bgroup.  But it works!
%\a \enda{\hrule width 1in}
%\endexample
%\enddesc
\example
一个编组的 {\it 边界\/} 可由花括号定义.
|
\produces
一个编组的~{\it 边界\/}~可由花括号定义.
\nextexample
\def\a{一 \vbox\bgroup}
% 在这里你不能使用一个 { 来代替 \bgroup,
% 否则 TeX 不会识别这个宏
\def\enda#1{{#1\egroup} 二}
% 这有点技巧性, 因为 \egroup 事实上和左花括号匹配,
% 而它右边的右边的花括号和 \bgroup 匹配.
% 不过这个歪门邪道行得通!!
\a \enda{\hrule width 1in}
|
\produces
\def\a{一 \vbox\bgroup}
% 在这里你不能使用一个 { 来代替 \bgroup,
% 否则 TeX 不会识别这个宏
\def\enda#1{{#1\egroup} 二}
% 这有点技巧性, 因为 \egroup 事实上和左花括号匹配,
% 而它右边的右边的花括号和 \bgroup 匹配.
% 不过这花招能用!!
\a \enda{\hrule width 1in}
\endexample
\enddesc

%\begindesc
%\cts global {}
%\explain
%This command makes the following definition
%or \minref{assignment} \minref{global} \seeconcept{global} so that it
%becomes effective independent of \minref{group} boundaries.
%You can apply a |\global| prefix to any kind of definition
%or \minref{assignment},
%including a \minref{macro} definition or a \minref{register} assignment.
%\example
%{\global\let\la = \leftarrow}
%$a \la b$
%|
%\produces
%% for safety's sake we fake this one!
%\let\la = \leftarrow
%$a \la b$
%\endexample
%\enddesc
\begindesc
\cts global {}
\explain
这个命令使得它随后的定义或\minref{赋值}成为\minref{全局}性的%
\seeconcept{全局的}，而不是仅局限在所处的\minref{组}之中生效。
你可以把 |\global| 放在
包括宏定义和\minref{寄存器}赋值在内的任何定义或\minref{赋值}前。
\example
{\global\let\la = \leftarrow}
$a \la b$
|
\produces
% for safety's sake we fake this one!
\let\la = \leftarrow
$a \la b$
\endexample
\enddesc

%\begindesc
%\cts globaldefs {\param{number}}
%\explain
%This parameter controls whether or not \TeX\ takes definitions
%and other assignments to be
%\minref{global}:
%\ulist
%\li If |\globaldefs| is zero (as it is by default), a definition is global
%if and only if it is preceded by |\global| either explicitly or implicitly.
%(The ^|\gdef| and ^|\xdef| commands (\xref\gdef) have an implicit
%|\global| prefix).
%\li If |\globaldefs| is greater than zero, all assignments and
%definitions are implicitly prefixed by ^|\global|.
%\li If |\globaldefs| is less than zero, all ^|\global| prefixes are ignored.
%\endulist
%\enddesc
\begindesc
\cts globaldefs {\param{number}}
\explain
这个参数控制 \TeX\ 是否把定义和其它的赋值作为\minref{全局}的:
\ulist
\li 如 |\globaldefs| 是 (默认值) 零,
当且仅当一个定义是由直接或者间接的 |\global| 命令指定的.
(^|\gdef| 和 ^|\xdef| 命令 (\xref\gdef) 间接地在定义前面加了 |\global| 命令).
\li 如果 |\globaldefs| 大于零, 所有的定义和赋值都会间接地在前面加上 ^|global|.
\li 如果 |\globaldefs| 小于零, 所有的 ^|\global| 都被忽略.
\endulist
\enddesc

%\begindesc
%\margin{Order of {\tt\\aftergroup} and {\tt\\afterassignment} changed.}
%\cts aftergroup {\<token>}
%\explain
%When \TeX\ encounters this command during input,
%it saves \<token>.
%After the end of the current \minref{group},
%it inserts \<token> back into the input and expands it.
%If a group contains several |\aftergroup|s, the corresponding tokens
%are \emph{all} inserted following the end of the group, in the order
%in which they originally appeared.
\begindesc
\margin{改变了 {\tt\\aftergroup} 和 {\tt\\afterassignment} 顺序.}
\cts aftergroup {\<token>}
\explain
当 \TeX\ 在读取输入时遇到了这个命令，它就把 \<token> 保存下来。
并在当前\minref{组}后插入展开后的 \<token>。
如果一个编组有好几个 |\aftergroup|，则每个标记\emph{全}都会依次插入这个编组的最后。

%The example that follows shows how you can use |\aftergroup| to postpone
%processing a token that you generate within a \minref{conditional test}.
%\example
%\def\neg{negative} \def\pos{positive}
%% These definitions are needed because \aftergroup applies
%% to a single token, not to a sequence of tokens or even
%% to a brace-delimited text.
%\def\arith#1{Is $#1>0$? \begingroup
%   \ifnum #1>-1 Yes\aftergroup\pos
%   \else No\aftergroup\neg\fi
%   , it's \endgroup. }
%\arith 2
%\arith {-1}
%|
%\produces
%\def\neg{negative} \def\pos{positive}
%% These definitions are needed because \aftergroup applies
%% to a single token, not a sequence of tokens or even
%% a group.
%\def\arith#1{Is $#1>0$? \begingroup
%   \ifnum #1>-1 Yes\aftergroup\pos
%   \else No\aftergroup\neg\fi
%   , it's \endgroup. }
%\arith 2
%\arith {-1}
%\endexample
%\eix^^{groups}
%\enddesc
下面的例子向你展示了如何用 |\aftergroup| 来延迟处理一个在\minref{条件测试}中产生的标记.
\example
\def\neg{负} \def\pos{正}
% 因为一个 \aftergroup 只能作用到一个标记上,
% 而不是到一系列的标记上, 甚至不能是一个用括号定界的文本,
% 所以下面的代码是必需的.
\def\arith#1{是否 $#1>0$? \begingroup
   \ifnum #1>-1 是\aftergroup\pos
   \else 否\aftergroup\neg\fi
   , 它是\endgroup. }
\arith 2
\arith {-1}
|
\produces
\def\neg{负} \def\pos{正}
% 因为一个 \aftergroup 只能作用到一个标记上,
% 而不是到一系列的标记上, 甚至不能是一个用括号定界的文本,
% 所以下面的代码是必需的.
\def\arith#1{是否 $#1>0$? \begingroup
   \ifnum #1>-1 是\aftergroup\pos
   \else 否\aftergroup\neg\fi
   , 它是\endgroup. }
\arith 2
\arith {-1}
\endexample
\eix^^{编组}
\enddesc

%\begindesc
%\cts afterassignment {\<token>}
%\explain
%When \TeX\ encounters this command it saves \<token> in a special
%place.  After it next performs an \minref{assignment}, it inserts
%\<token> into the input and expands it.  If you call |\afterassignment|
%more than once before an assignment, only the last call has any effect.
%One use of |\afterassignment|
%is in writing \minref{macro}s for commands intended to be written
%in the
%form of assignments, as in the example below.
\begindesc
\cts afterassignment {\<token>}
\explain
当 \TeX\ 遇到这个命令，它会把 \<token> 保存在一个特殊的地方。
在它下次执行赋值时，它会把展开后的 \<token> 放到其后。
如果你调用了几次 |\afterassignment|，那仅有最后一次是生效的。
|\afterassignment| 命令的一个用处是可以写定义形式的\minref{宏}命令，
例子如下。

%See \knuth{page~279} for a precise description
%of the behavior of |\afterassignment|.
%\example
%\def\setme{\afterassignment\setmeA\count255}
%\def\setmeA{$\number\count255\advance\count255 by 10
%   +10=\number\count255$}
%Some arithmetic: \setme = 27
%% After expanding \setme, TeX sets \count255 to 27 and
%% then calls \setmeA.
%|
%\produces
%\def\setme{\afterassignment\setmeA\count255}
%\def\setmeA{$\number\count255\advance\count255 by 10
%+10=\number\count255$}
%Some arithmetic: \setme = 27
%% After expanding \setme, TeX sets \count255 to 27 and
%% then calls \setmeA.
%\endexample
%\enddesc
精确的 |\afterassignment| 行为定义请参见 \knuth{page~279}.
\example
\def\setme{\afterassignment\setmeA\count255}
\def\setmeA{$\number\count255\advance\count255 by 10
   +10=\number\count255$}
算术式: \setme = 27
% 在展开 \setme 以后, TeX 把 \count255
% 设为 27, 然后调用 \setmeA.
|
\produces
\def\setme{\afterassignment\setmeA\count255}
\def\setmeA{$\number\count255\advance\count255 by 10
   +10=\number\count255$}
算术式: \setme = 27
% 在展开 \setme 以后, TeX 把 \count255
% 设为 27, 然后调用 \setmeA.
\endexample
\enddesc


%==========================================================================
%\section {Macros}
\section {宏}

%==========================================================================
%\subsection {Defining macros}
\subsection {定义宏}

%\begindesc
%\bix^^{macros}
%\bix^^{macros//defining}
%\xrdef{mac1}% begin the section on macros
%%
%\cts def {\<control sequence> \<parameter text> \rqbraces{\<replacement text>}}
%\explain
%This command defines \<control sequence> as a \minref{macro} with the
%specified \<parameter text> and \<replacement text>.
%See \xrefpg{macro} for a full explanation of how to write a macro
%definition.
%\example
%\def\add#1+#2=?{#1+#2&=
%   \count255=#1 \advance\count255 by #2 \number\count255\cr}
%$$\eqalign{
%   \add 27+9=?
%   \add -5+-8=?}$$
%|
%\dproduces
%\def\add#1+#2=?{#1+#2&=
%   \count255=#1 \advance\count255 by #2 \number\count255\cr}
%$$\eqalign{
%   \add 27+9=?
%   \add -5+-8=?}$$
%\endexample
%\enddesc
\begindesc
\bix^^{宏}
\bix^^{宏//定义宏}
\xrdef{mac1}% begin the section on macros
%
\cts def {\<control sequence> \<parameter text> \rqbraces{\<replacement text>}}
\explain
这个命令根据 \<parameter text> 和 \<replacement text> 把 \<control sequence> 定义为一个\minref{宏}。
请参阅\xrefpg{宏}获取关于如何定义宏的完整信息。
\example
\def\add#1+#2=?{#1+#2&=
   \count255=#1 \advance\count255 by #2 \number\count255\cr}
$$\eqalign{
   \add 27+9=?
   \add -5+-8=?}$$
|
\dproduces
\def\add#1+#2=?{#1+#2&=
   \count255=#1 \advance\count255 by #2 \number\count255\cr}
$$\eqalign{
   \add 27+9=?
   \add -5+-8=?}$$
\endexample
\enddesc

%\begindesc
%\cts edef {\<control sequence> \<parameter text> \rqbraces{\<replacement text>}}
%\explain
%This command defines a macro in the same general way as |\def|.
%The difference is that \TeX\ expands the \<replacement text>
%of an |\edef| immediately (but still without executing anything).
%Thus any definitions within the \<replacement text> are expanded, but
%assignments and commands that produce things such as boxes and glue
%are left as is.  For example, an |\hbox| command within
%the \<replacement text> of an |\edef| remains as a command and is not
%turned into a box as \TeX\ is processing the definition.
%It isn't always obvious what's expanded and what isn't, but you'll
%find a complete list of expandable control sequences on
%\knuth{pages~212--215}.
\begindesc
\cts edef {\<control sequence> \<parameter text> \rqbraces{\<replacement text>}}
\explain
这个命令和 |\def| 一样可以定义宏.
唯一的区别在于, \TeX\ 会把 |\edef| 的 \<replacement text> 立即展开 (但是不会执行它).
因此, 任何在 \<replacement text> 中的内容会被展开, 但那些产生盒子或粘连的排列或命令依然保持原来的样子.
比如 \TeX\ 在处理这个定义时, 在由 |\edef| 的定义中的 \<replacement text> 中的 |\hbox| 命令依然会保持命令竹的格式, 而不会变成一个盒子.
一般情况下, 并不能明显看出什么会被展开, 什么不会, 但你可以在 \knuth{页~212-215} 找到一张可被展开的控制序列列表.

%You can inhibit the expansion of a control sequence that would otherwise
%be expanded by using |\no!-expand| (\xref\noexpand). ^^|\noexpand|
%You can postpone the expansion of a control sequence by using
%^|\expandafter| (\xref\expandafter).
你可以使用 |\no!-expand| 命令 (\xref\noexpand) 来阻止一个控制序列的展开.
^^|\noexpand|
你可以使用 ^|\expandafter| (\xref\expandafter) 命令来延迟一个控制序列的展开.

%The |\write|, |\message|, |\errmessage|, |\wlog|, and |\csname|
%commands expand their
%token lists using the same rules that |\edef| uses to expand its
%replacement text.
%^^|\write//expanded by {\tt\\edef} rules|
%^^|\message//expanded by {\tt\\edef} rules|
%^^|\errmessage//expanded by {\tt\\edef} rules|
%^^|\wlog//expanded by {\tt\\edef} rules|
%^^|\csname//expanded by {\tt\\edef} rules|
%\example
%\def\aa{xy} \count255 = 1
%\edef\bb{w\ifnum \count255 > 0\aa\fi z}
%% equivalent to \def\bb{wxyz}
%\def\aa{} \count255 = 0 % leaves \bb unaffected
%\bb
%|
%\produces
%\def\aa{xy} \count255 = 1
%\edef\bb{w\ifnum \count255 > 0\aa\fi z}
%% equivalent to \def\bb{wxyz}
%\def\aa{} \count255 = 0 % leaves \bb unaffected
%\bb
%\endexample
%\enddesc
|\write|, |\message|, |\errmessage|, |\wlog| 和 |\csname| 命令会把它们的标记使用和 |\edef| 替换文本相同的法则进行展开.
^^|\write//用 {\tt\\edef} 规则展开|
^^|\message//用 {\tt\\edef} 规则展开|
^^|\errmessage//用 {\tt\\edef} 规则展开|
^^|\wlog//用 {\tt\\edef} 规则展开|
^^|\csname//用 {\tt\\edef} 规则展开|
\example
\def\aa{xy} \count255 = 1
\edef\bb{w\ifnum \count255 > 0\aa\fi z}
% 和 \def\bb{wxyz} 等价
\def\aa{} \count255 = 0 % 不影响 \bb
\bb
|
\produces
\def\aa{xy} \count255 = 1
\edef\bb{w\ifnum \count255 > 0\aa\fi z}
% 和 \def\bb{wxyz} 等价
\def\aa{} \count255 = 0 % 不影响 \bb
\bb
\endexample
\enddesc

%\begindesc
%\cts gdef {\<control sequence> \<parameter text> \rqbraces{\<replacement text>}}
%\explain
%This command is equivalent to |\global\def|.
%\enddesc
\begindesc
\cts gdef {\<control sequence> \<parameter text> \rqbraces{\<replacement text>}}
\explain
这个命令等价于 |\global\def|.
\enddesc

%\begindesc
%\cts xdef {\<control sequence> \<parameter text> \rqbraces{\<replacement text>}}
%\explain
%This command is equivalent to |\global\edef|.
%\enddesc
\begindesc
\cts xdef {\<control sequence> \<parameter text> \rqbraces{\<replacement text>}}
\explain
这个命令等价于 |\global\edef|.
\enddesc

%\begindesc
%\cts long {}
%\explain
%This command is used as a prefix to a \minref{macro} definition.
%It tells \TeX\ that the arguments to the macro are permitted to include
%|\par| tokens (\xref{\@par}), which normally indicate the end of a paragraph.
%^^|\par//in macro arguments|
%If \TeX\
%tries to expand a macro defined without |\long| and any of
%the macro's arguments include a |\par| token,
%\TeX\ will complain about a runaway argument.  The purpose
%of this behavior is to provide you with some protection against unterminated
%macro arguments.
%|\long| gives you a way of bypassing the protection.
%\example
%\long\def\aa#1{\par\hrule\smallskip#1\par\smallskip\hrule}
%\aa{This is the first line.\par
%This is the second line.}
%% without \long, TeX would complain
%|
%\produces
%\medskip
%\long\def\aa#1{\par\hrule\smallskip#1\par\smallskip\hrule}
%\aa{This is the first line.\par
%This is the second line.}
%% without \long, TeX would complain
%\endexample
%\enddesc
\begindesc
\cts long {}
\explain
这个命令加在\minref{宏}定义前面.
它告诉 \TeX\ 该宏的参数可以包括 |\par| 标记 (\xref{\@par}),
该标记一般表示一个段的结束.
^^|\par//在宏参量中|
如果 \TeX\ 尝试把一个没有 |\long| 的宏定义展开,
而该宏的任意一部分的参数包括了一个 |\par| 标记,
\TeX\ 就会报错错这是一个失控的参数.
这个行为的目的, 是为了确保宏参数的完整结束.
而 |\long| 就给你提供了一个回避这个行为的方法.
\example
\long\def\aa#1{\par\hrule\smallskip#1\par\smallskip\hrule}
\aa{这是第一行.\par
这是第二行.}
% 没有 \long, TeX 会报错
|
\produces
\medskip
\long\def\aa#1{\par\hrule\smallskip#1\par\smallskip\hrule}
\aa{这是第一行.\par
这是第二行.}
% 没有 \long, TeX 会报错
\endexample
\enddesc

%\begindesc
%\cts outer {}
%\explain
%\null ^^{outer}
%This command is used as a prefix to a \minref{macro} definition.
%It tells \TeX\ that the macro is outer (\xref{outer})
%and cannot be used in certain contexts.
%If the macro is used in a forbidden context, \TeX\ will complain.
\begindesc
\cts outer {}
\explain
\null ^^{外部的}
这个命令加在\minref{宏}定义前。
它告诉 \TeX\ 这个宏是外部的（\xref{外部的}），
所以不能在某些情况中使用。
如果这个宏出现在那些被禁止的情下，\TeX\ 会报错。

%\example
%\outer\def\chapterhead#1{%
%   \eject\topglue 2in \centerline{\bf #1}\bigskip}
%% Using \chapterhead in a forbidden context causes an
%% error message.
%|
%\endexample
%\enddesc
\example
\outer\def\chapterhead#1{%
   \eject\topglue 2in \centerline{\bf #1}\bigskip}
% 在一个被禁止的情况下使用 \chapterhead
% 会出现错误信息.
|
\endexample
\enddesc

%\begindesc
%\cts chardef {\<control sequence>=\<charcode>}
%\explain
%^^{characters//defined by \b\tt\\chardef\e}
%This command defines \<control sequence>
%to be \<charcode>.
%Although |\chardef| is most often used to define characters, you can also
%use it to give a name to a number in the range $0$--$255$ even when you
%aren't using that number as a character code.
%\example
%\chardef\percent = `\% 21\percent, {\it 19\percent}
%% Get the percent character in roman and in italic
%|
%\produces
%\chardef\percent = `\%
%21\percent, {\it 19\percent}
%% You'll get the percent character in roman and in italic
%\endexample
%\enddesc
\begindesc
\cts chardef {\<control sequence>=\<charcode>}
\explain
^^{字符//用 \b\tt\\chardef\e 定义}
上面的命令把 \<charcode> 定义为 \<control sequence>.
虽然 |\chardef| 常在定义字符时用到,
你也可以使用它来给 $0$--$255$ 之间的任何一个数定义一个名字,
即使你没用以字符码的形式使用该数.
\example
\chardef\percent = `\% 21\percent, {\it 19\percent}
% 排印出正体和意大利体的百分号
|
\produces
\chardef\percent = `\%
21\percent, {\it 19\percent}
% 排印出正体和意大利体的百分号
\endexample
\enddesc

%\begindesc
%^^{math characters}
%^^{mathcodes}
%\cts mathchardef {\<control sequence>=\<mathcode>}
%\explain
%This command defines \<control sequence> as a math character
%with the given \minrefs{mathcode}\<mathcode>.
%The control sequence will only be legal in math mode.
%\example
%\mathchardef\alphachar = "010B % As in plain TeX.
%$\alphachar$
%|
%\produces
%\mathchardef\alphachar = "010B % As in plain TeX.
%$\alphachar$
%\endexample
%\eix^^{macros//defining}
%\enddesc
\begindesc
^^{数学字符}
^^{数学码}
\cts mathchardef {\<control sequence>=\<mathcode>}
\explain
这个命令把 \<control sequence> 定义为一个给定\minref{数学字符码}的数学字符.
这个控制序列仅在数学模式下有效
\example
\mathchardef\alphachar = "010B % 类似 plain TeX 的定义
$\alphachar$
|
\produces
\mathchardef\alphachar = "010B % 类似 plain TeX 的定义
$\alphachar$
\endexample
\eix^^{宏//定义宏}
\enddesc

%==========================================================================
%\subsection {Other definitions}
\subsection {其它定义方法}

%\begindesc
%\cts let {\<control sequence> = \<token>}
%\explain
%^^{control sequences//defining with \b\tt\\let\e}
%\minrefs{token}
%This command causes
%\<control sequence> to acquire the current meaning of \<token>.
%Even if you redefine \<token> later, the meaning of \<control sequence>
%will not change.  Although \<token> is most commonly a control sequence,
%it can also be a \minref{character} token.
%\enddesc
\begindesc
\cts let {\<control sequence> = \<token>}
\explain
^^{控制序列//用 \b\tt\\let\e 定义}
\minrefs{token}
这个命令会使得 \<control sequence> 去获取当前 \<token> 的含义.
即使你对 \<token> 重新定义,  \<control sequence> 的含义仍然不变.
虽然 \<token> 一般情况下都是一个控制序列,
它其实也可以是一个\minref{字符}标记.
\enddesc

%\begindesc
%\cts futurelet {\<control sequence> \<token$_1$> \<token$_2$>}
%\explain
%This command tells \TeX\ to make \<token$_2$> the meaning of
%\<control sequence> (as would be done with |\let|), and then to
%process \<token$_1$> and \<token$_2$> normally.
%|\futurelet| is useful at the end of macro definitions
%because it gives you a way of looking beyond the token that \TeX\
%is about to process before it processes it.
%\example
%\def\predict#1{\toks0={#1}\futurelet\next\printer}
%% \next will acquire the punctuation mark after the
%% argument to \predict
%\def\printer#1{A \punc\ lies ahead for \the\toks0. }
%\def\punc{%
%   \ifx\next;semicolon\else
%      \ifx\next,comma\else
%         ``\next''\fi\fi}
%\predict{March}; \predict{April}, \predict{July}/
%|
%\produces
%\def\predict#1{\toks0={#1}\futurelet\next\printer}
%\def\printer#1{A \punc\ lies ahead for \the\toks0. }
%\def\punc{%
%   \ifx\next;semicolon\else
%      \ifx\next,comma\else
%         ``\next''\fi\fi
%   }
%\predict{March};
%\predict{April},
%\predict{July}/
%\endexample
%\enddesc
\begindesc
\cts futurelet {\<control sequence> \<token$_1$> \<token$_2$>}
\explain
这个命令告诉 \TeX\ 把 \<token$_2$> 的设为 \<control sequence> 的定义
(可以由 |\let| 完成),
然后按正常的方式来处理 \<token$_1$> 和 \<token$_2$>.
在宏定义的最后 |\futurelet| 很有用, 因为它可以给你提供一个
在 \TeX\ 处理未处理的标记前, 查看它后面的标记的方法.
\example
\def\predict#1{\toks0={#1}\futurelet\next\printer}
% \next 会获取 \predict 后的标点符号.
\def\printer#1{一个 \punc\ 放在 \the\toks0 前. }
\def\punc{%
   \ifx\next;分号\else
      \ifx\next,逗号\else
         ``\next''\fi\fi}
\predict{三月}; \predict{四月}, \predict{七月}/
|
\produces
\def\predict#1{\toks0={#1}\futurelet\next\printer}
% \next 会获取 \predict 后的标点符号.
\def\printer#1{一个 \punc\ 放在 \the\toks0 前. }
\def\punc{%
   \ifx\next;分号\else
      \ifx\next,逗号\else
         ``\next''\fi\fi
   }
\predict{三月}; \predict{四月}, \predict{七月}/
\endexample
\enddesc

%\begindesc
%\cts csname {\<token list> {\bt \\endcsname}}
%\xrdef{\endcsname}
%\explain
%This command produces a control sequence from \<token list>.
%It provides a way of synthesizing control sequences,
%including ones that you can't normally write.
%\<token list> can itself include control sequences; it is expanded
%in the same way as the replacement text of an |\edef| definition (\xref\edef).
%If the final expansion
%yields anything that isn't a character, \TeX\ will complain.
%|\csname| goes from a list of tokens to a control sequence;
%you can go the other way with ^|\string| \ctsref\string.
%\example
%\def\capTe{Te}
%This book purports to be about \csname\capTe X\endcsname.
%|
%\produces
%\def\capTe{Te}
%This book purports to be about \csname\capTe X\endcsname.
%\endexample
%\enddesc
\begindesc
\cts csname {\<token list> {\bt \\endcsname}}
\xrdef{\endcsname}
\explain
这个命令可以由 \<token list> 产生一个控制序列.
它提供了一种把标记合并成控制序列的方式,
包括一些你一般情况下不能直接写的形式.
|\csname| 命令会把它们的标记使用和 |\edef| 替换文本相同的法则进行展开 (\xref\edef).
如果最后的展开会产生不是字符的东西, \TeX\ 会报错.
|\csname| 把一系列的标记转为一个控制序列;
你可以用 ^|\string| \ctsref\string 的方法做相反的事情.
\example
\def\capTe{Te}
本书关于 \csname\capTe X\endcsname.
|
\produces
\def\capTe{Te}
本书关于 \csname\capTe X\endcsname.
\endexample
\enddesc

%==========================================================================
%\subsection {Controlling expansion}
\subsection {控制展开}

%\begindesc
%\bix^^{macros//controlling expansion of}
%\cts expandafter {\<token$_1$> \<token$_2$>}
%\explain
%This command tells \TeX\ to expand \<token$_1$> according to its rules
%for \minref{macro} expansion \emph{after} it has expanded \<token$_2$>
%by one level.  It's useful when \<token$_1$> is something like `|{|'
%^^|{//with {\tt\\expandafter}|
%or ^|\string| that inhibits expansion of \<token$_2$>,
%but you want to expand \<token$_2$> nevertheless.
%\example
%\def\aa{xyz}
%\tt % Use this font so `\' prints that way.
%[\string\aa]  [\expandafter\string\aa]
%[\expandafter\string\csname TeX\endcsname]
%|
%\produces
%\def\aa{xyz}
%\tt
%[\string\aa]  [\expandafter\string\aa]
%[\expandafter\string\csname TeX\endcsname]
%\endexample
%\enddesc
\begindesc
\bix^^{宏//控制宏展开}
\cts expandafter {\<token$_1$> \<token$_2$>}
\explain
这个命令会让 \TeX\ 在展开一层 \<token$_2$> 后把 \<token$_1$> 根据\minref{宏}展开法则进行展开.
有时你想展开 \<token$_2$>,
而它前面有类似 `|{|' 或 ^|\string| 的东西阻止它的展开,
^^|{//和 {\tt\\expandafter} 一起|
这时这个命令会非常有用.
\example
\def\aa{xyz}
\tt % Use this font so `\' prints that way.
[\string\aa]  [\expandafter\string\aa]
[\expandafter\string\csname TeX\endcsname]
|
\produces
\def\aa{xyz}
\tt
[\string\aa]  [\expandafter\string\aa]
[\expandafter\string\csname TeX\endcsname]
\endexample
\enddesc

%\begindesc
%\cts noexpand {\<token>}
%\explain
%This command tells \TeX\ to
%suppress expansion of \<token> if \<token> is a
%\minref{control sequence} that can be expanded.
%If \<token> can't be expanded, e.g., it's a letter,
%\TeX\ acts as though the |\noexpand| wasn't there
%and processes \<token> normally.
%In other words the expansion of `|\noexpand|\<token>'
%is simply \<token> no matter what \<token> happens to be.
%\example
%\def\bunny{rabbit}
%\edef\magic{Pull the \noexpand\bunny\ out of the hat!! }
%% Without \noexpand, \bunny would always be replaced
%% by `rabbit'
%\let\oldbunny=\bunny \def\bunny{lagomorph} \magic
%\let\bunny=\oldbunny \magic
%|
%\produces
%\def\bunny{rabbit}
%\edef\magic{Pull the \noexpand\bunny\ out of the hat! }
%% Without \noexpand, \bunny would always be replaced
%% by `rabbit'
%\let\oldbunny=\bunny \def\bunny{lagomorph} \magic
%\let\bunny=\oldbunny \magic
%\endexample
%\enddesc
\begindesc
\cts noexpand {\<token>}
\explain
这个命令让 \TeX\ 跳过一个可以展开的标记 \<token> 的展开.
如果 \<token> 不能被展开, 比如它是一个字符,
\TeX\ 则不会理会 |\noexpand|, 而把 \<token> 按一般的方法处理.
\example
\def\bunny{兔子}
\edef\magic{把 \noexpand\bunny\ 从帽子中取出!! }
% 如果没有 \noexpand, \bunny 会永远替换为 `兔子'
\let\oldbunny=\bunny \def\bunny{兔} \magic
\let\bunny=\oldbunny \magic
|
\produces
\def\bunny{兔子}
\edef\magic{把 \noexpand\bunny\ 从帽子中取出!! }
% 如果没有 \noexpand, \bunny 会永远替换为 `兔子'
\let\oldbunny=\bunny \def\bunny{兔} \magic
\let\bunny=\oldbunny \magic
\endexample
\enddesc

%\begindesc
%\cts the {\<token>}
%\explain
%This command generally expands to a list of \minref{character} tokens
%that represents \<token>.  \<token> can be any of the following:
\begindesc
\cts the {\<token>}
\explain
这个命令一般会把 \<token> 展开, 表示成一个\minref{字符}串.
其中 \<token>  可以是以下的任何形式:

%\ulist\compact
%\li a \TeX\ \minref{parameter}, e.g., |\parindent| or |\deadcycles|
%^^{parameters//using \b\tt\\the\e\ with}
%\li a \minref{register}, e.g., |\count0|
%^^{registers//with \b\tt\\the\e}
%\margin{Item for special registers removed}
%\li a code associated with an input character, e.g., |\catcode`(|
%\li a font parameter, e.g., |\fontdimen3\sevenbf|
%\li the ^|\hyphenchar| or ^|\skewchar| of a font, e.g.,
%|\skewchar\teni|
%\li ^|\lastpenalty|, ^|\lastskip|, or ^|\lastkern| (values derived from
%the last item on the current horizontal \minrefs{horizontal list}
%or \minref{vertical list})
%\li a control sequence defined by ^|\chardef| or
%^|\mathchardef|
%\endulist
\ulist\compact
\li \TeX\ \minref{参数}, 比如, |\parindent| 或者 |\deadcycles|
^^{参数//和 \b\tt\\the\e\ 一起使用}
\li \minref{寄存器}, 比如, |\count0|
^^{寄存器//和 \b\tt\\the\e 一起}
\margin{去除了特殊寄存器的那项}
\li 输入字符的字符码, 比如, |\catcode`(|
\li 字符参数, 比如, |\fontdimen3\sevenbf|
\li 字体的 ^|\hyphenchar| 或 ^|\skewchar|, 比如, |\skewchar\teni|
\li ^|\lastpenalty|, ^|\lastskip|, 或者 ^|\lastkern|
(当前的水平\minrefs{水平列表}或\minref{竖直列表}的最后一项的数值).
\li ^|\chardef| 或 ^|\mathchardef| 定义的控制序列
\endulist

%\noindent
%In addition, |\the| can expand to noncharacter tokens in the following two
%cases:
%\ulist\compact
%\li |\the| \<font>, which expands to the most recently defined
%control sequence that selects
%the same font as the control sequence \<font>
%\li |\the| \<token variable>, which expands to a copy of the value of the
%variable, e.g., |\the\everypar|
%\endulist
\noindent
此外, |\the| 可以在下面两种情况下, 展开成非字符标记:
\ulist\compact
\li |\the| \<font>, 会展开成当前定义的控制序列,
这个控制序列和控制序列 \<font> 所选择的字体相同.
\li |\the| \<token variable>, 会复制变量的值, 并且对复本进行展开,
比如 |\the\everypar|
\endulist

%See \knuth{pages~214--215} for a more detailed description of what
%|\the| does in various cases.
%\example
%The vertical size is currently \the\vsize.
%The category code of `(' is \the\catcode `(.
%|
%\produces
%The vertical size is currently \the\vsize.
%The category code of `(' is \the\catcode `(.
%\endexample
%\enddesc
请参阅 \knuth{页~214--215} 来获取 |\the| 在各种情况下行为的更详细描述.
\example
目前页面的竪直长度为 \the\vsize.
`(' 字符的类码是 \the\catcode `(.
|
\produces
目前页面的竪直长度为 \the\vsize.
`(' 字符的类码是 \the\catcode `(.
\endexample
\enddesc

%{\tighten
%\see \headcit{Converting information to tokens}{convert},
%|\showthe| (\xref\showthe).
%\par}
{\tighten
\see \headcit{把信息改为标记}{convert},
|\showthe| (\xref\showthe).
\par}

\eix^^{宏//控制宏展开}

%==========================================================================
%\subsection {Conditional tests}
\subsection {条件测试}

%\begindesc
%\xrdef{conds}
%\bix^^{conditional tests}
%%
%\ctspecial if {\<token$_1$> \<token$_2$>}\ctsxrdef{@if}
%\explain
%{\emergencystretch=1em
%This command tests if \<token$_1$> and \<token$_2$>
%have the same \minref{character} code, independent of their
%\minref{category code}s.
%Before performing the test, \TeX\ expands tokens following the |\if|
%until it obtains two tokens that can't be expanded further.
%These two tokens become \<token$_1$> and \<token$_2$>.
%The expansion
%includes replacing  a control sequence |\let| equal to a character token
%by that character token.
%A \minref{control sequence} that can't be further expanded is
%considered to have character code $256$.\par}
%\example
%\def\first{abc}
%\if\first true\else false\fi;
%% ``c'' is left over from the expansion of \first.
%% It lands in the unexecuted ``true'' part.
%\if a\first\ true\else false\fi;
%% Here ``bc'' is left over from the expansion of \first
%\if \hbox\relax true\else false\fi
%% Unexpandable control sequences test equal with ``if''
%|
%\produces
%\def\first{abc}
%\if\first true\else false\fi;
%% ``c'' is left over from the expansion of \first.
%% It lands in the unexecuted ``true'' part.
%\if a\first\ true\else false\fi;
%% Here ``bc'' is left over from the expansion of \first
%\if \hbox\relax true\else false\fi
%% Unexpandable control sequences test equal with ``if''
%\endexample
%\enddesc
\begindesc
\xrdef{conds}
\bix^^{条件测试}
%
\ctspecial if {\<token$_1$> \<token$_2$>}\ctsxrdef{@if}
\explain
此命令测试 \<token$_1$> 和 \<token$_2$> 的\minref{字符}编码是否相同，
不区分它们的\minref{类别码}。
在测试之前，\TeX\ 展开 |\if| 之后的记号，直到得到两个无法继续展开的记号。
这两个记号就是 \<token$_1$> 和 \<token$_2$>。
展开过程也包括将控制序列替换为用 |\let| 设定的某个字符记号。
\TeX\ 将无法继续展开的\minref{控制序列}视为字符编码 $256$ 的记号。
\example
\def\first{abc}
\if\first true\else false\fi;
% ``c'' is left over from the expansion of \first.
% It lands in the unexecuted ``true'' part.
\if a\first\ true\else false\fi;
% Here ``bc'' is left over from the expansion of \first
\if \hbox\relax true\else false\fi
% Unexpandable control sequences test equal with ``if''
|
\produces
\def\first{abc}
\if\first true\else false\fi;
% ``c'' is left over from the expansion of \first.
% It lands in the unexecuted ``true'' part.
\if a\first\ true\else false\fi;
% Here ``bc'' is left over from the expansion of \first
\if \hbox\relax true\else false\fi
% Unexpandable control sequences test equal with ``if''
\endexample
\enddesc

%\begindesc
%\ctspecial ifcat {\<token$_1$> \<token$_2$>}\ctsxrdef{@ifcat}
%\explain
%^^{category codes//testing}
%This command tests if \<token$_1$> and \<token$_2$>
%have the same \minref{category code}.
%Before performing the test, \TeX\ expands tokens following the |\ifcat|
%until it obtains two tokens that can't be expanded further.
%These two tokens become \<token$_1$> and \<token$_2$>.
%The expansion
%includes replacing  a control sequence |\let| equal to a character token
%by that character token.
%A \minref{control sequence} that can't be further expanded is
%considered to have category code $16$.
%\example
%\ifcat axtrue\else false\fi;
%\ifcat ]}true\else false\fi;
%\ifcat \hbox\day true\else false\fi;
%\def\first{12345}
%\ifcat (\first true\else false\fi
%% ``2345'' lands in the true branch of the test
%|
%\produces
%\ifcat axtrue\else false\fi;
%\ifcat ]}true\else false\fi;
%\ifcat \hbox\day true\else false\fi;
%\def\first{12345}
%\ifcat (\first true\else false\fi
%% ``2345'' lands in the true branch of the test
%\endexample
%\enddesc
\begindesc
\ctspecial ifcat {\<token$_1$> \<token$_2$>}\ctsxrdef{@ifcat}
\explain
^^{类别码//测试类别码}
此命令测试 \<token$_1$> 和 \<token$_2$> 的\minref{类别码}是否相同。
在测试之前，\TeX\ 展开 |\ifcat| 之后的记号，直到得到两个无法继续展开的记号。
这两个记号就是 \<token$_1$> 和 \<token$_2$>。
展开过程也包括将控制序列替换为用 |\let| 设定的某个字符记号。
\TeX\ 将无法继续展开的\minref{控制序列}视为类别码 $16$ 的记号。
\example
\ifcat axtrue\else false\fi;
\ifcat ]}true\else false\fi;
\ifcat \hbox\day true\else false\fi;
\def\first{12345}
\ifcat (\first true\else false\fi
% ``2345'' lands in the true branch of the test
|
\produces
\ifcat axtrue\else false\fi;
\ifcat ]}true\else false\fi;
\ifcat \hbox\day true\else false\fi;
\def\first{12345}
\ifcat (\first true\else false\fi
% ``2345'' lands in the true branch of the test
\endexample
\enddesc

%\begindesc
%\ctspecial ifx {\<token$_1$> \<token$_2$>}\ctsxrdef{@ifx}
%\explain
%This command tests if \<token$_1$> and \<token$_2$> agree.
%Unlike |\if| and |\ifcat|, |\ifx| does \emph{not} expand the tokens
%following |\ifx|, so \<token$_1$> and \<token$_2$> are the two
%tokens immediately after |\ifx|.
%There are three cases:
%\olist
%\li If one token is a \minref{macro} and the other one isn't,
%the tokens don't agree.
%\li If neither token is a macro, the tokens agree if:
%\olist
%\li both tokens are characters (or control sequences denoting characters) and
%their \minref{character} codes and \minref{category code}s agree, or
%\li both tokens refer to the same \TeX\ command,
%font, etc.
%\endolist
%\li If both tokens are macros, the tokens agree if:
%\olist\compact
%\li their ``first level'' expansions, i.e.,
%their replacement texts, are identical, and
%\li they have the same status with respect to ^|\long| (\xref\long)
%and ^|\outer| (\xref\outer).
%\endolist
%Note in particular that \emph{any two undefined control
%sequences agree}.
%\endolist
%\noindent
%This test is generally more useful than |\if|.
%\example
%\ifx\alice\rabbit true\else false\fi;
%% true since neither \rabbit nor \alice is defined
%\def\a{a}%
%\ifx a\a true\else false\fi;
%% false since one token is a macro and the other isn't
%\def\first{\a}\def\second{\aa}\def\aa{a}%
%\ifx \first\second true\else false\fi;
%% false since top level expansions aren't the same
%\def\third#1:{(#1)}\def\fourth#1?{(#1)}%
%\ifx\third\fourth true\else false\fi
%% false since parameter texts differ
%|
%\produces
%\ifx\alice\rabbit true\else false\fi;
%% true since neither \rabbit nor \alice is defined
%\def\a{a}%
%\ifx a\a true\else false\fi;
%% false since one token is a macro and the other isn't
%\def\first{\a}\def\second{\aa}\def\aa{a}%
%\ifx \first\second true\else false\fi;
%% false since top level expansions aren't the same
%\def\third#1:{(#1)}\def\fourth#1?{(#1)}%
%\ifx\third\fourth true\else false\fi
%% false since parameter texts differ
%\endexample
%\enddesc
\begindesc
\ctspecial ifx {\<token$_1$> \<token$_2$>}\ctsxrdef{@ifx}
\explain
此命令测试 \<token$_1$> 和 \<token$_2$> 是否相同。
与 |\if| 和 |\ifcat| 不同，|\ifx| 命令\emph{不会}展开 |\ifx| 之后的记号，
因此 \<token$_1$> 和 \<token$_2$> 就是紧随 |\ifx| 之后的两个记号。
\TeX\ 按照如下三种情形处理：
\olist
\li 如果一个记号是\minref{宏}而另一个记号不是，则这两个记号不相同。
\li 如果两个记号都不是宏，它们满足下面条件之一时相同：
\olist
\li 两个记号都是字符（或表示字符的控制序列），
且它们的\minref{字符}编码和\minref{类别码}相同；
\li 两个记号指代相同的 \TeX\ 命令或字体等。
\endolist
\li 如果两个记号都是宏，它们满足下面两个条件时相同：
\olist\compact
\li 它们的``第一层''展开即它们的替换文本相同；
\li 它们有相同的 ^|\long|（\xref\long ）和 ^|\outer|（\xref\outer ）状态。
\endolist
注意特别地\emph{任何两个未定义的控制序列是相同的}。
\endolist
\noindent
此测试通常比 |\if| 更为有用。
\example
\ifx\alice\rabbit true\else false\fi;
% true since neither \rabbit nor \alice is defined
\def\a{a}%
\ifx a\a true\else false\fi;
% false since one token is a macro and the other isn't
\def\first{\a}\def\second{\aa}\def\aa{a}%
\ifx \first\second true\else false\fi;
% false since top level expansions aren't the same
\def\third#1:{(#1)}\def\fourth#1?{(#1)}%
\ifx\third\fourth true\else false\fi
% false since parameter texts differ
|
\produces
\ifx\alice\rabbit true\else false\fi;
% true since neither \rabbit nor \alice is defined
\def\a{a}%
\ifx a\a true\else false\fi;
% false since one token is a macro and the other isn't
\def\first{\a}\def\second{\aa}\def\aa{a}%
\ifx \first\second true\else false\fi;
% false since top level expansions aren't the same
\def\third#1:{(#1)}\def\fourth#1?{(#1)}%
\ifx\third\fourth true\else false\fi
% false since parameter texts differ
\endexample
\enddesc

%\begindesc
%\ctspecial ifnum {\<number$_1$> \<relation> \<number$_2$>}\ctsxrdef{@ifnum}
%\explain
%^^{numbers//comparing}
%This command tests if \<number$_1$> and \<number$_2$>
%satisfy \<relation>, which must be either `|<|', `|=|', or `|>|'.
%The numbers can be constants such as |127|, count registers such as
%|\pageno| or |\count22|, or numerical parameters such as |\hbadness|.
%Before performing the test, \TeX\ expands tokens following the |\ifnum|
%until it obtains a sequence of tokens having
%the form \<number$_1$> \<relation> \<number$_2$>, followed by a token
%that can't be part of \<number$_2$>.
%\example
%\count255 = 19 \ifnum \count255 > 12 true\else false\fi
%|
%\produces
%\count255 = 19 \ifnum \count255 > 12 true\else false\fi
%\endexample
%\enddesc
\begindesc
\ctspecial ifnum {\<number$_1$> \<relation> \<number$_2$>}\ctsxrdef{@ifnum}
\explain
^^{数//比较两个数}
此命令测试 \<number$_1$> 和 \<number$_2$> 是否满足 \<relation>，
即 `|<|'、`|=|' 或者 `|>|' 关系。
这两个数可以是类似 |127| 的常数、类似 |\pageno| 或 |\count22| 的计数寄存器%
或者类似 |\hbadness| 的数值参数。
在执行测试之前，\TeX\ 展开 |\ifnum| 之后的记号，
直到它得到一串形如 \<number$_1$> \<relation> \<number$_2$> 的记号序列，
而且随后的记号不能成为 \<number$_2$> 的一部分。
\example
\count255 = 19 \ifnum \count255 > 12 true\else false\fi
|
\produces
\count255 = 19 \ifnum \count255 > 12 true\else false\fi
\endexample
\enddesc

%\begindesc
%\ctspecial ifodd {\<number>}\ctsxrdef{@ifodd}
%\explain
%^^{numbers//testing for odd/even}
%This command tests if \<number> is odd.
%Before performing the test, \TeX\ expands tokens following the |\ifodd|
%until it obtains a sequence of tokens having the form \<number>,
%followed by a token that can't be part of \<number>.
%\example
%\count255 = 19
%\ifodd 5 true\else false\fi
%|
%\produces
%\ifodd 5 true\else false\fi
%\endexample
%\enddesc
\begindesc
\ctspecial ifodd {\<number>}\ctsxrdef{@ifodd}
\explain
^^{数//测试奇偶性}
此命令测试 \<number> 是否为奇数。
在执行测试之前，\TeX\ 展开 |\ifodd| 之后的记号，
直到它得到一串形如 \<number> 的记号序列，
而且随后的记号不能成为 \<number> 的一部分。
\example
\count255 = 19
\ifodd 5 true\else false\fi
|
\produces
\ifodd 5 true\else false\fi
\endexample
\enddesc

%\begindesc
%\ctspecial ifdim {\<dimen$_1$> \<relation> \<dimen$_2$>}\ctsxrdef{@ifdim}
%\explain
%^^{dimensions//comparing}
%This command tests if \<dimen$_1$> and \<dimen$_2$>
%satisfy \<relation>, which must be either `|<|', `|=|', or `|>|'.
%The dimensions can be constants such as |1in|, dimension registers
%such as |\dimen6|, or dimension parameters such as |\parindent|.
%Before performing the test, \TeX\ expands tokens following the |\ifdim|
%until it obtains a sequence of tokens having
%the form \<dimen$_1$> \<relation> \<dimen$_2$>, followed by a token
%that can't be part of \<dimen$_2$>.
%
%\example
%\dimen0 = 1000pt \ifdim \dimen0 > 3in true\else false\fi
%|
%\produces
%\dimen0 = 1000pt \ifdim \dimen0 > 3in true\else false\fi
%\endexample
%\enddesc
\begindesc
\ctspecial ifdim {\<dimen$_1$> \<relation> \<dimen$_2$>}\ctsxrdef{@ifdim}
\explain
^^{尺寸//比较两个尺寸}
此命令测试 \<dimen$_1$> 和 \<dimen$_2$> 是否满足 \<relation>，
即 `|<|'、`|=|' 或 `|>|' 关系。这两个尺寸可以是类似 |1in| 的常数、
类似 |\dimen6| 的尺寸寄存器或者类似 |\parindent| 的尺寸参数。
在执行测试之前，\TeX\ 展开 |\ifdim| 之后的记号，
直到它得到一串形如 \<dimen$_1$> \<relation> \<dimen$_2$> 的记号序列，
而且随后的记号不能成为 \<dimen$_2$> 的一部分。
\example
\dimen0 = 1000pt \ifdim \dimen0 > 3in true\else false\fi
|
\produces
\dimen0 = 1000pt \ifdim \dimen0 > 3in true\else false\fi
\endexample
\enddesc

%\begindesc
%\ctspecial ifhmode {}\ctsxrdef{@ifhmode}
%\ctspecial ifvmode {}\ctsxrdef{@ifvmode}
%\ctspecial ifmmode {}\ctsxrdef{@ifmmode}
%\ctspecial ifinner {}\ctsxrdef{@ifinner}
%\explain
%^^{horizontal mode//testing for}
%^^{vertical mode//testing for}
%^^{math mode//testing for}
%^^{internal mode//testing for}
%These commands test what \minref{mode} \TeX\ is in:
%\ulist
%\li |\ifhmode| is true if \TeX\ is in ordinary or restricted horizontal mode.
%\li |\ifvmode| is true if \TeX\ is in ordinary or internal vertical mode.
%\li |\ifmmode| is true if \TeX\ is in text math or display math mode.
%\li |\ifinner| is true if \TeX\ is in an ``internal'' mode:
%restricted horizontal, internal vertical, or text math.
%\endulist
%\example
%\def\modes{{\bf
%   \ifhmode
%      \ifinner IH\else H\fi
%   \else\ifvmode
%      \ifinner \hbox{IV}\else \hbox{V}\fi
%   \else\ifmmode \hbox{M}\else
%      error\fi\fi\fi}}
%Formula $\modes$; then \modes,
%   \hbox{next \modes\ and \vbox{\modes}}.
%\par\modes
%|
%\produces
%\def\modes{{\bf
%   \ifhmode
%      \ifinner IH\else H\fi
%   \else\ifvmode
%      \ifinner \hbox{IV}\fi
%   \else\ifmmode \hbox{M}\else
%      error\fi\fi\fi}}
%Formula $\modes$; then \modes,
%   \hbox{next \modes\ and \vbox{\modes}}.
%\par\noindent{\bf V} % sorry folks, we have to fake this one
%\endexample
%\enddesc
\begindesc
\ctspecial ifhmode {}\ctsxrdef{@ifhmode}
\ctspecial ifvmode {}\ctsxrdef{@ifvmode}
\ctspecial ifmmode {}\ctsxrdef{@ifmmode}
\ctspecial ifinner {}\ctsxrdef{@ifinner}
\explain
^^{水平模式//测试水平模式}
^^{竖直模式//测试竖直模式}
^^{数学模式//测试数学模式}
^^{内部模式//测试内部模式}
这些命令测试 \TeX\ 处于何种模式中：
\ulist
\li |\ifhmode| 为真，如果 \TeX\ 处于普通或受限水平模式中。
\li |\ifvmode| 为真，如果 \TeX\ 处于普通或内部竖直模式中。
\li |\ifmmode| 为真，如果 \TeX\ 处于文内数学或陈列数学模式中。
\li |\ifinner| 为真，如果 \TeX\ 处于``内部''模式中：
即位于受限水平模式、内部竖直模式或者文内数学模式中。
\endulist
\example
\def\modes{{\bf
   \ifhmode
      \ifinner IH\else H\fi
   \else\ifvmode
      \ifinner \hbox{IV}\else \hbox{V}\fi
   \else\ifmmode \hbox{M}\else
      error\fi\fi\fi}}
Formula $\modes$; then \modes,
   \hbox{next \modes\ and \vbox{\modes}}.
\par\modes
|
\produces
\def\modes{{\bf
   \ifhmode
      \ifinner IH\else H\fi
   \else\ifvmode
      \ifinner \hbox{IV}\fi
   \else\ifmmode \hbox{M}\else
      error\fi\fi\fi}}
Formula $\modes$; then \modes,
   \hbox{next \modes\ and \vbox{\modes}}.
\par\noindent{\bf V} % sorry folks, we have to fake this one
\endexample
\enddesc

%\begindesc
%\ctspecial ifhbox {\<register>}\ctsxrdef{@ifhbox}
%\ctspecial ifvbox {\<register>}\ctsxrdef{@ifvbox}
%\ctspecial ifvoid {\<register>}\ctsxrdef{@ifvoid}
%\explain
%^^{hboxes//testing for}
%^^{vboxes//testing for}
%^^{boxes//testing if void}
%These commands test the contents of
%the box register numbered \<reg\-ister>.
%Let \<register> be $n$.  Then:
%\ulist
%\li |\ifhbox| is true if |\box|$\,n$ is an \minref{hbox}.
%\li |\ifvbox| is true if |\box|$\,n$ is an \minref{vbox}.
%\li |\ifvoid| is true if |\box|$\,n$ is void, i.e, doesn't have
%a box in it.
%\endulist
%\example
%\setbox0 = \vbox{} % empty but not void
%\setbox1 = \hbox{a}
%\setbox2 = \box1 % makes box1 void
%\ifvbox0 true\else false\fi;
%\ifhbox2 true\else false\fi;
%\ifvoid1 true\else false\fi
%|
%\produces
%\setbox0 = \vbox{}
%\setbox1 = \hbox{a}
%\setbox2 = \box1 % empties box1
%\ifvbox0 true\else false\fi;
%\ifhbox2 true\else false\fi;
%\ifvoid1 true\else false\fi
%\endexample
%\enddesc
\begindesc
\ctspecial ifhbox {\<register>}\ctsxrdef{@ifhbox}
\ctspecial ifvbox {\<register>}\ctsxrdef{@ifvbox}
\ctspecial ifvoid {\<register>}\ctsxrdef{@ifvoid}
\explain
^^{水平盒子//测试水平盒子}
^^{竖直盒子//测试竖直盒子}
^^{盒子//测试空盒子}
这些命令测试编号为 \<reg\-ister> 的盒子寄存器的内容。
设编号 \<register> 为 $n$。则有：
\ulist
\li |\ifhbox| 为真，如果 |\box|$\,n$ 是一个\minref{水平盒子}。
\li |\ifvbox| 为真，如果 |\box|$\,n$ 是一个\minref{竖直盒子}。
\li |\ifvoid| 为真，如果 |\box|$\,n$ 是空的，即它不包含盒子。
\endulist
\example
\setbox0 = \vbox{} % empty but not void
\setbox1 = \hbox{a}
\setbox2 = \box1 % makes box1 void
\ifvbox0 true\else false\fi;
\ifhbox2 true\else false\fi;
\ifvoid1 true\else false\fi
|
\produces
\setbox0 = \vbox{}
\setbox1 = \hbox{a}
\setbox2 = \box1 % empties box1
\ifvbox0 true\else false\fi;
\ifhbox2 true\else false\fi;
\ifvoid1 true\else false\fi
\endexample
\enddesc

%\begindesc
%\ctspecial ifeof {\<number>}\ctsxrdef{@ifeof}
%\explain
%^^{end of file, testing for}
%\minrefs{file}
%This command tests an input stream for end of file.
%It is true if input stream \<number> has not been opened,
%or has been opened and the associated file has been entirely read in
%(or doesn't exist).
%\enddesc
\begindesc
\ctspecial ifeof {\<number>}\ctsxrdef{@ifeof}
\explain
^^{文件尾测试}
\minrefs{file}
此命令测试输入流文件是否结束。
它为真当且仅当第 \<number> 个输入流还没打开，
或者已经打开但对应的文件已经全部读完（或文件不存在）。
\enddesc

%\begindesc
%\ctspecial ifcase
%{\<number>\<case$_0$ text> {\bt \\or }\<case$_1$ text> {\bt \\or}
%   $\ldots$ {\bt \\or} \<case$_n$ text>\hfil\break
%\hglue 3pc{\bt \\else} \<otherwise text> {\bt \\fi}}
%\ctsxrdef{@ifcase}
%\ctsxrdef{@or}
%\explain
%^^{case testing}
%This command introduces a test with numbered multiple cases.
%If \<num\-ber> has the value $k$, \TeX\ will expand \<case$_k$ text> if
%it exists, and \<other\-wise text> if it doesn't.  You can omit the |\else|---%
%in this case, \TeX\ won't expand anything if none of the cases are satisfied.
%\example
%\def\whichday#1{\ifcase #1<day 0>\or Sunday\or Monday%
%   \or Tuesday\or Wednesday\or Thursday\or Friday%
%   \or Saturday\else Nonday\fi
%   \ is day \##1. }
%\whichday2 \whichday3 \whichday9
%|
%\produces
%\def\whichday#1{\ifcase #1<day 0>\or Sunday\or Monday%
%   \or Tuesday\or Wednesday\or Thursday\or Friday%
%   \or Saturday\else Nonday\fi
%   \ is day \##1. }
%\whichday2 \whichday3 \whichday9
%\endexample
%\enddesc
\begindesc
\ctspecial ifcase
{\<number>\<case$_0$ text> {\bt \\or }\<case$_1$ text> {\bt \\or}
   $\ldots$ {\bt \\or} \<case$_n$ text>\hfil\break
\hglue 3pc{\bt \\else} \<otherwise text> {\bt \\fi}}
\ctsxrdef{@ifcase}
\ctsxrdef{@or}
\explain
^^{分支测试}
此命令引入一个带编号的多重分支测试。
假设 \<num\-ber> 的值为 $k$，在 \<case$_k$ text> 存在时 \TeX\ 将展开它，
否则就展开 \<other\-wise text>。你可以省略 |\else| ——%
此时，在各个分支都不满足时 \TeX\ 将不展开任何东西。
\example
\def\whichday#1{\ifcase #1<day 0>\or Sunday\or Monday%
   \or Tuesday\or Wednesday\or Thursday\or Friday%
   \or Saturday\else Nonday\fi
   \ is day \##1. }
\whichday2 \whichday3 \whichday9
|
\produces
\def\whichday#1{\ifcase #1<day 0>\or Sunday\or Monday%
   \or Tuesday\or Wednesday\or Thursday\or Friday%
   \or Saturday\else Nonday\fi
   \ is day \##1. }
\whichday2 \whichday3 \whichday9
\endexample
\enddesc

%\begindesc
%\ctspecial iftrue {}\ctsxrdef{@iftrue}
%\ctspecial iffalse {}\ctsxrdef{@iffalse}
%\explain
%These commands are equivalent to tests that are always true or always
%false.  The main use of these commands is in defining macros that keep
%track of the result of a test.
%\example
%\def\isbigger{\let\bigger=\iftrue}
%\def\isnotbigger{\let\bigger=\iffalse}
%% These \let's MUST be buried in macros!!  If they aren't,
%% TeX erroneously tries to match them with \fi.
%\def\test#1#2{\ifnum #1>#2 \isbigger\else\isnotbigger\fi}
%\test{3}{6}
%\bigger$3>6$\else$3\le6$\fi
%|
%\produces
%\def\isbigger{\let\bigger=\iftrue}
%\def\isnotbigger{\let\bigger=\iffalse}
%% These \let's MUST be buried in macros!
%% If they aren't, TeX erroneously tries to match them with \fi
%\def\test#1#2{\ifnum #1>#2 \isbigger\else\isnotbigger\fi}
%\test{3}{6}
%\bigger$3>6$\else$3\le6$\fi
%\endexample
%\enddesc
\begindesc
\ctspecial iftrue {}\ctsxrdef{@iftrue}
\ctspecial iffalse {}\ctsxrdef{@iffalse}
\explain
这两个命令提供始终为真或始终为假的测试。它们主要用于在宏定义中记录测试结果。
\example
\def\isbigger{\let\bigger=\iftrue}
\def\isnotbigger{\let\bigger=\iffalse}
% These \let's MUST be buried in macros!!  If they aren't,
% TeX erroneously tries to match them with \fi.
\def\test#1#2{\ifnum #1>#2 \isbigger\else\isnotbigger\fi}
\test{3}{6}
\bigger$3>6$\else$3\le6$\fi
|
\produces
\def\isbigger{\let\bigger=\iftrue}
\def\isnotbigger{\let\bigger=\iffalse}
% These \let's MUST be buried in macros!
% If they aren't, TeX erroneously tries to match them with \fi
\def\test#1#2{\ifnum #1>#2 \isbigger\else\isnotbigger\fi}
\test{3}{6}
\bigger$3>6$\else$3\le6$\fi
\endexample
\enddesc

%\begindesc
%\ctspecial else {} \ctsxrdef{@else}
%\explain
%This command introduces the ``false'' alternative of a conditional test.
%\enddesc
\begindesc
\ctspecial else {} \ctsxrdef{@else}
\explain
此命令提供条件测试为``假''时的另一选择。
\enddesc

%\begindesc
%\ctspecial fi {} \ctsxrdef{@fi}
%\explain
%This command ends the text of a conditional test.
%\enddesc
\begindesc
\ctspecial fi {} \ctsxrdef{@fi}
\explain
此命令结束条件测试文本。
\enddesc

%\begindesc
%\ctspecial newif {{\bt \\if}\<test name>}\ctsxrdef{@newif}
%\explain
%This command names a trio of control sequences with names |\alpha!-true|,
%|\alphafalse|,
%and |\ifalpha|, where |alpha| is \<test name>.
%You can use them to define your own tests by
%creating a logical variable that records
%true\slash false information:
%\ulist\compact
%\li |\alphatrue| sets the  logical variable |alpha| true.
%\li |\alphafalse| sets the logical variable |alpha| false
%\li |\ifalpha| is a conditional test that is true if the logical
%variable |alpha| is true and false otherwise.
%\endulist
%The logical variable |alpha| doesn't really exist, but \TeX\ behaves as
%though it did.  After |\newif\ifalpha|, the logical variable is initially
%false.
%
%|\newif| is an outer command, so you can't use it inside a macro
%definition.
%\example
%\newif\iflong  \longtrue
%\iflong Rabbits have long ears.
%\else Rabbits don't have long ears.\fi
%|
%\produces
%\newif\iflong
%\longtrue
%\iflong Rabbits have long ears.\else Rabbits don't have long ears.\fi
%\endexample
%\eix^^{conditional tests}
%\enddesc
\begindesc
\ctspecial newif {{\bt \\if}\<test name>}\ctsxrdef{@newif}
\explain
假设 \<test name> 为 |alpha|，此命令命名了三个控制序列
|\alpha!-true|、|\alphafalse| 和 |\ifalpha|。
通过创建记录真\slash 假信息的逻辑变量，你可以定义自己的测试：
\ulist\compact
\li |\alphatrue| 设定逻辑变量 |alpha| 为真；
\li |\alphafalse| 设定逻辑变量 |alpha| 为假；
\li |\ifalpha| 是一个条件测试，它为真当且仅当逻辑变量 |alpha| 为真。
\endulist
该逻辑变量 |alpha| 实际上不存在，但 \TeX\ 假装它是存在的。
在执行 |\newif\ifalpha| 后，该逻辑变量的初始值为假。

|\newif| 是一个外部命令，因此你不能在宏定义中使用它。
\example
\newif\iflong  \longtrue
\iflong Rabbits have long ears.
\else Rabbits don't have long ears.\fi
|
\produces
\newif\iflong
\longtrue
\iflong Rabbits have long ears.\else Rabbits don't have long ears.\fi
\endexample
\eix^^{条件测试}
\enddesc


%==========================================================================
%\subsection {Repeated actions}
\subsection {重复操作}

%{\def\test{{\bt \\if}$\Omega$}%
%\begindesc
%\bix^^{repeated actions}
%\bix^^{loops}
%\cts loop {$\alpha$ {\test} $\beta$ {\bt \\repeat}}
%\ctspecial repeat {}\ctsxrdef{@repeat}
%\explain
%These commands provide a looping construct for \TeX.
%Here $\alpha$ and $\beta$ are arbitrary sequences of commands
%and \test\ is any of the conditional tests described in
%\headcit{Conditional tests}{conds}.
%The |\repeat| replaces the |\fi| corresponding to the test,
%so you must not write an explicit |\fi| to terminate the test.
%Nor, unfortunately, can you associate an |\else| with the test.
%If you want to use the test in the opposite sense, you need to
%rearrange the test or
%define an auxiliary test with |\newif| (see above) and use that
%test in the sense you want (see the second example below).
%
%\TeX\ expands |\loop| as follows:
%\olist
%\li $\alpha$ is expanded.
%\li {\test} is performed.  If the result is false, the loop is terminated.
%\li $\beta$ is expanded.
%\li The cycle is repeated.
%\endolist
%\example
%\count255 = 6
%\loop
%   \number\count255\
%   \ifnum\count255 > 0
%      \advance\count255 by -1
%\repeat
%|
%\produces
%\count255 = 6
%\loop
%   \number\count255\
%   \ifnum\count255 > 0
%      \advance\count255 by -1
%\repeat
%\nextexample
%\newif\ifnotdone % \newif uses \count255 in its definition
%\count255=6
%\loop
%   \number\count255\
%   \ifnum\count255 < 1 \notdonefalse\else\notdonetrue\fi
%   \ifnotdone
%      \advance\count255 by -1
%\repeat
%|
%\produces
%\newif\ifnotdone
%\count255=6
%\loop
%   \number\count255\
%   \ifnum\count255 < 1 \notdonefalse\else\notdonetrue\fi
%   \ifnotdone
%      \advance\count255 by -1
%\repeat
%%
%\eix^^{repeated actions}
%\eix^^{loops}
%%
%\endexample
%\enddesc
%} % end scope of definition of \test
{\def\test{{\bt \\if}$\Omega$}%
\begindesc
\bix^^{重复操作}
\bix^^{循环}
\cts loop {$\alpha$ {\test} $\beta$ {\bt \\repeat}}
\ctspecial repeat {}\ctsxrdef{@repeat}
\explain
这些命令提供了 \TeX\ 的循环结构。
这里 $\alpha$ 和 $\beta$ 是任意的命令序列，
而 \test\ 是在\headcit{条件测试}{conds}中描述的任何一种条件测试。
|\repeat| 已经替代了对应于该测试的 |\fi|，
因此你不可以显式写出 |\fi| 以结束测试。
这也遗憾地导致你不可以给测试带上 |\else| 部分。
如果你想在相反意义上使用测试，你需要重新安排该测试，
或者用 |\newif|（见上面）定义一个辅助测试%
并按照你的需要使用这个测试（见下面第二个例子）。

\TeX\ 按照下列步骤展开 |\loop| 循环：
\olist
\li 展开 $\alpha$。
\li 执行 {\test}。如果结果为假，循环就此中止。
\li 展开 $\beta$。
\li 重复此循环。
\endolist
\example
\count255 = 6
\loop
   \number\count255\
   \ifnum\count255 > 0
      \advance\count255 by -1
\repeat
|
\produces
\count255 = 6
\loop
   \number\count255\
   \ifnum\count255 > 0
      \advance\count255 by -1
\repeat
\nextexample
\newif\ifnotdone % \newif uses \count255 in its definition
\count255=6
\loop
   \number\count255\
   \ifnum\count255 < 1 \notdonefalse\else\notdonetrue\fi
   \ifnotdone
      \advance\count255 by -1
\repeat
|
\produces
\newif\ifnotdone
\count255=6
\loop
   \number\count255\
   \ifnum\count255 < 1 \notdonefalse\else\notdonetrue\fi
   \ifnotdone
      \advance\count255 by -1
\repeat
%
\eix^^{重复操作}
\eix^^{循环}
%
\endexample
\enddesc
} % end scope of definition of \test

%==========================================================================
%\subsection {Doing nothing}
\subsection {什么也不做}

%\begindesc
%\cts relax {}
%\explain
%This command tells \TeX\ to do nothing.  It's useful in a context where
%you need to provide a command but there's nothing that you want \TeX\ to do.
%\example
%\def\medspace{\hskip 12pt\relax}
%% The \relax guards against the possibility that
%% The next tokens are `plus' or `minus'.
%|
%
%\endexample
%\enddesc
\begindesc
\cts relax {}
\explain
此命令让 \TeX\ 不做任何事情。
此命令常用在需要提供一个命令但却无事可做的环境中。
\example
\def\medspace{\hskip 12pt\relax}
% The \relax guards against the possibility that
% The next tokens are `plus' or `minus'.
|

\endexample
\enddesc

%\begindesc
%\cts empty {}
%\explain
%This command expands to no tokens at all.
%It differs from |\relax| in that it disappears after macro expansion.
%%
%\xrdef{mac2}% end the section on macros
%\eix^^{macros}
%\enddesc
\begindesc
\cts empty {}
\explain
此命令展开后得不到任何记号。它与 |\relax| 的区别在于，在宏展开后它消失了。
%
\xrdef{mac2}% end the section on macros
\eix^^{宏}
\enddesc

%==========================================================================
%\section {Registers}
\section {寄存器}

%==========================================================================
%\subsection {Using registers}
\subsection {使用寄存器}

%\begindesc
%\bix^^{registers}
%\makecolumns 11/2:
%\cts count {\<register> {\bt =} \<number>}
%\cts dimen {\<register> {\bt =} \<dimen>}
%\cts skip {\<register> {\bt =} \<glue>}
%\cts muskip {\<register> {\bt =} \<muglue>}
%\cts toks {\<register> {\bt =} \<token variable>}
%\aux\cts toks {\<register> {\bt =} \rqbraces{\<token list>}}
%\aux\cts count {\<register>}
%\aux\cts dimen {\<register>}
%\aux\cts skip {\<register>}
%\aux\cts muskip {\<register>}
%\aux\cts toks {\<register>}
%\explain
%^^{assignments//of registers}
%The first six commands listed here assign something to a register.
%The |=|'s in the assignments are optional.
%The remaining five control sequences are not true commands
%because they can only appear as part of an argument.
%They yield the contents of the specified register.
%Although you can't use these control sequences by themselves as commands
%in text,  you can use ^|\the| to convert them to text so that
%you can typeset their values.
\begindesc
\bix^^{寄存器}
\makecolumns 11/2:
\cts count {\<register> {\bt =} \<number>}
\cts dimen {\<register> {\bt =} \<dimen>}
\cts skip {\<register> {\bt =} \<glue>}
\cts muskip {\<register> {\bt =} \<muglue>}
\cts toks {\<register> {\bt =} \<token variable>}
\aux\cts toks {\<register> {\bt =} \rqbraces{\<token list>}}
\aux\cts count {\<register>}
\aux\cts dimen {\<register>}
\aux\cts skip {\<register>}
\aux\cts muskip {\<register>}
\aux\cts toks {\<register>}
\explain
^^{赋值//给寄存器赋值}
左边列出的六个命令用于给寄存器赋值，其中的 `|=|' 是可选的。
右边列出的五个控制序列并不是真正的命令，因为它们只能作为参量的一部分。
它们给出了特定寄存器的内容。虽然在文本中你不能将这些控制序列单独用作命令，
但你可以用 ^|\the| 命令将它们转换为文本再排版它们的值。

%You can name and reserve registers
%with the ^|\newcount| command and its relatives
%(\xref{\@newcount}).
%Using these commands is a safe way to obtain registers that
%are known not to have any conflicting usage.
你可以用 ^|\newcount| 及相关命令命名和预留寄存器（\xref{\@newcount}）。
用这些命令获取寄存器更加安全，因为它们保证不会造成冲突。

%^^{count registers}
%A |\count| register contains an integer, which can be either positive or
%negative.
%Integers can be as large as you're ever likely to need them to be.\footnote
%{Here's the only exercise in this book: find out what's the largest
%integer that \TeX\ will accept.}
%\TeX\ uses count registers $0$--$9$ to keep track of the
%page number (see \knuth{page~119}).
%|\count255| is the only count register available for use
%without a reservation.
%\example
%\count255 = 17 \number\count255
%|
%\produces
%\count255 = 17 \number\count255
%\endexample
^^{计数寄存器}
|\count| 寄存器存储一个整数，可正可负。
该整数可以很大，比你可能需要的都大。\footnote
{这里是本书仅有的一个练习：找出 \TeX\ 可以接受的最大整数。}
\TeX\ 将计数寄存器 $0$--$9$ 用于记录页码（见\knuth{第~119~页}）。
|\count255| 是无需预留就能使用的唯一计数寄存器。
\example
\count255 = 17 \number\count255
|
\produces
\count255 = 17 \number\count255
\endexample

%\medskip\noindent
%^^{dimension registers}
%A |\dimen| register contains a dimension.
%Registers |\dimen0| through |\dimen9| and |\dimen255| are available
%for scratch use.
\medskip\noindent
^^{尺寸寄存器}
|\dimen| 寄存器存储一个尺寸。
寄存器 |\dimen0| 到 |\dimen9| 及 |\dimen255| 都可用于临时用途。

%\example
%\dimen0 = 2.5in
%\hbox to \dimen0{$\Leftarrow$\hfil$\Rightarrow$}
%|
%\produces
%\dimen0 = 2.5in
%\hbox to \dimen0{$\Leftarrow$\hfil$\Rightarrow$}
%\doruler{\8\8\8}3{in}
%\endexample
\example
\dimen0 = 2.5in
\hbox to \dimen0{$\Leftarrow$\hfil$\Rightarrow$}
|
\produces
\dimen0 = 2.5in
\hbox to \dimen0{$\Leftarrow$\hfil$\Rightarrow$}
\doruler{\8\8\8}3{in}
\endexample

%\medskip\noindent
%^^{skip registers}
%A |\skip| register contains the dimensions of glue.
%Unlike a |\dimen| register, it
%records an amount of shrink and stretch as well as a natural size.
%Registers |\skip0| through |\skip9| and |\skip255| are available
%for use without a reservation.
\medskip\noindent
^^{间距寄存器}
|\skip| 寄存器存储粘连的尺寸。
与 |\dimen| 寄存器不同，它除了记录粘连的自然尺寸外，还记录其伸长量和收缩量。
寄存器 |\skip0| 到 |\skip9| 及 |\skip255| 都可用于临时用途。

%\example
%\skip2 = 2in
%$\Rightarrow$\hskip \skip2 $\Leftarrow$
%|
%\produces
%\skip2 = 2in
%$\Rightarrow$\hskip \skip2 $\Leftarrow$\par
%\noindent\hphantom{$\Rightarrow$}\ruler{\8\8}2{in}
%\endexample
\example
\skip2 = 2in
$\Rightarrow$\hskip \skip2 $\Leftarrow$
|
\produces
\skip2 = 2in
$\Rightarrow$\hskip \skip2 $\Leftarrow$\par
\noindent\hphantom{$\Rightarrow$}\ruler{\8\8}2{in}
\endexample

%\medskip\noindent
%^^{muskip registers}
%A |\muskip| register is like a |\skip| register,
%but the glue in it is always measured in ^|mu|
%\seeconcept{mathematical unit}.
%The size of a |mu| depends on the current font.
%For example, it's usually a little
%smaller in a subscript than in ordinary text.
%Registers |\muskip0| through |\muskip9| and |\muskip255| are available
%for use without a reservation.
\medskip\noindent
^^{数学间距寄存器}
|\muskip| 寄存器与 |\skip| 寄存器相似，
但其中的粘连始终以 ^|mu| 为单位\seeconcept{数学单位}。
一个 |mu| 的大小与当前字体有关，比如在下标中通常就比在普通文本中小一点。
寄存器 |\muskip0| 到 |\muskip9| 及 |\muskip255| 都可用于临时用途。

%\example
%\muskip0 = 24mu % An em and a half, no stretch or shrink.
%$\mathop{a \mskip\muskip0 b}\limits^{a \mskip\muskip0 b}$
%% Note the difference in spacing.
%|
%\produces
%\muskip0 = 24mu % an em and a half
%$\mathop{a \mskip\muskip0 b}\limits^{a \mskip\muskip0 b}$
%% Note the difference in spacing
%\endexample
\example
\muskip0 = 24mu % An em and a half, no stretch or shrink.
$\mathop{a \mskip\muskip0 b}\limits^{a \mskip\muskip0 b}$
% Note the difference in spacing.
|
\produces
\muskip0 = 24mu % an em and a half
$\mathop{a \mskip\muskip0 b}\limits^{a \mskip\muskip0 b}$
% Note the difference in spacing
\endexample

%\medskip\noindent
%^^{token registers}
%You can assign either a token variable
%(a register or a parameter) or a token list
%to a |\toks| register.
%When you assign a token list to a token register,
%the tokens in the token list are \emph{not} expanded.
\medskip\noindent
^^{记号寄存器}
你可以指定一个记号变量（一个寄存器或一个参数）或一个记号列给 |\toks| 寄存器。
当你指定一个记号列给记号寄存器时，记号列中的记号\emph{不会}被展开。

%Once the tokens in a token list have been inserted into text
%using ^|\the|, they are
%expanded just like tokens that were read in directly.
%They have the category codes that they received when \TeX\ first
%saw them in the~\hbox{input}.
一旦用 ^|\the| 命令将记号列中的记号插入文本中，\TeX\ 就像直接读入那样展开它们。
它们的类别码是 \TeX\ 在\hbox{输入}中首次看到时给出的。

%\example
%\toks0 = {the \oystereaters\ were at the seashore}
%% This assignment doesn't expand \oystereaters.
%\def\oystereaters{Walrus and Carpenter}
%\toks1 = \toks0
%% the same tokens are now in \toks0 and \toks1
%Alice inquired as to whether \the\toks1.
%|
%\produces
%\toks0 = {the \oystereaters\ were at the seashore}
%% This assignment doesn't expand \oystereaters
%\def\oystereaters{Walrus and Carpenter}
%\toks1 = \toks0
%% the same tokens are now in \toks0 and \toks1
%Alice inquired as to whether \the\toks1.
%\endexample
%\enddesc
\example
\toks0 = {the \oystereaters\ were at the seashore}
% This assignment doesn't expand \oystereaters.
\def\oystereaters{Walrus and Carpenter}
\toks1 = \toks0
% the same tokens are now in \toks0 and \toks1
Alice inquired as to whether \the\toks1.
|
\produces
\toks0 = {the \oystereaters\ were at the seashore}
% This assignment doesn't expand \oystereaters
\def\oystereaters{Walrus and Carpenter}
\toks1 = \toks0
% the same tokens are now in \toks0 and \toks1
Alice inquired as to whether \the\toks1.
\endexample
\enddesc

%\begindesc
%\cts maxdimen {}
%\explain
%^^{dimensions//maximum}
%This control sequence yields a \<dimen> that is the
%largest dimension acceptable to \TeX\ (nearly 18 feet).
%It is not a true command because it can only appear as part of an argument
%to another command.
%\example
%\maxdepth = \maxdimen % Remove restrictions on \maxdepth.
%|
%\endexample
%\enddesc
\begindesc
\cts maxdimen {}
\explain
^^{尺寸//最大尺寸}
这个控制序列生成 \TeX\ 所能接受的最大尺寸 \<dimen>（差不多为 18 英尺）。
它不是真正的命令，因为它只能作为其他命令的参量的一部分。
\example
\maxdepth = \maxdimen % Remove restrictions on \maxdepth.
|
\endexample
\enddesc

\see |\advance| (\xref\advance), |\multiply|,
|\divide| (\xref\divide), |\set!-box|, |\box| (\xref\box).

%==========================================================================
%\subsection {Naming and reserving registers, etc.}
\subsection {命名和预留寄存器等}

%\begindesc
%\bix^^{registers//reserving}
%\makecolumns 11/2:
%\ctspecial newcount \ctsxrdef{@newcount}
%\ctspecial newdimen \ctsxrdef{@newdimen}
%\ctspecial newskip \ctsxrdef{@newskip}
%\ctspecial newmuskip \ctsxrdef{@newmuskip}
%\ctspecial newtoks \ctsxrdef{@newtoks}
%\ctspecial newbox \ctsxrdef{@newbox}
%\ctspecial newread \ctsxrdef{@newread}
%\ctspecial newwrite \ctsxrdef{@newwrite}
%\ctspecial newfam \ctsxrdef{@newfam}
%\ctspecial newinsert \ctsxrdef{@newinsert}
%\ctspecial newlanguage \ctsxrdef{@newlanguage}
%\explain
%These commands
%reserve and name an entity of the indicated type:
%\ulist
%{\tolerance = 5000
%\fontdimen3\the\font = 2\fontdimen3\the\font % allow spaces to stretch more
%\li |\new!-count|, |\newdimen|, |\newskip|, |\new!-mu!-skip|, |\new!-toks|,
%and |\new!-box| each reserve a \minref{register} of the indicated type.
%}
%^^{count registers//reserved by \b\tt\\newcount\e}
%^^{dimension registers//reserved by \b\tt\\newdimen\e}
%^^{skip registers//reserved by \b\tt\\newskip\e}
%^^{muskip registers//reserved by \b\tt\\newmuskip\e}
%^^{token registers//reserved by \b\tt\\newtoks\e}
%^^{box registers//reserved by \b\tt\\newbox\e}
%\li |\newread| and |\newwrite| reserve an input stream and
%an output stream \minrefs{input stream}\minrefs{output stream}
%respectively.
%^^{input streams//reserved by \b\tt\\newread\e}
%^^{output streams//reserved by \b\tt\\newwrite\e}
%\li |\newfam| reserves a \minref{family} of math fonts.
%^^{family//reserved by \b\tt\\newfam\e}
%\li |\newinsert| reserves an insertion type.
%(Reserving an insertion type involves reserving several different registers.)
%^^{insertions//numbers reserved by \b\tt\\newinsert\e}
%\li |\newlanguage| reserves a set of hyphenation patterns.
%\endulist
%You should use these commands whenever you need one of these entities,
%other than in a very local region,
%in order to avoid numbering conflicts.
\begindesc
\bix^^{寄存器//预留寄存器}
\makecolumns 11/2:
\ctspecial newcount \ctsxrdef{@newcount}
\ctspecial newdimen \ctsxrdef{@newdimen}
\ctspecial newskip \ctsxrdef{@newskip}
\ctspecial newmuskip \ctsxrdef{@newmuskip}
\ctspecial newtoks \ctsxrdef{@newtoks}
\ctspecial newbox \ctsxrdef{@newbox}
\ctspecial newread \ctsxrdef{@newread}
\ctspecial newwrite \ctsxrdef{@newwrite}
\ctspecial newfam \ctsxrdef{@newfam}
\ctspecial newinsert \ctsxrdef{@newinsert}
\ctspecial newlanguage \ctsxrdef{@newlanguage}
\explain
这些命令预留并命名一个指定类型的实体：
\ulist
{\tolerance = 5000
\fontdimen3\the\font = 2\fontdimen3\the\font % allow spaces to stretch more
\li |\new!-count|、|\newdimen|、|\newskip|、|\new!-mu!-skip|、
|\new!-toks| 以及 |\new!-box| 各自预留一个指定类型的\minref{寄存器}。
}
^^{计数寄存器//用 \b\tt\\newcount\e 预留}
^^{尺寸寄存器//用 \b\tt\\newdimen\e 预留}
^^{间距寄存器//用  \b\tt\\newskip\e 预留}
^^{数学间距寄存器//用  \b\tt\\newmuskip\e 预留}
^^{记号寄存器//用  \b\tt\\newtoks\e 预留}
^^{盒子寄存器//用  \b\tt\\newbox\e 预留}
\li |\newread| 和 |\newwrite| 分别预留一个输入流和输出流%
\minrefs{input stream}\minrefs{output stream}。
^^{输入流//用 \b\tt\\newread\e 预留}
^^{输出流//用 \b\tt\\newwrite\e 预留}
\li |\newfam| 预留一个数学字体\minref{族}。
^^{族//用 \b\tt\\newfam\e 预留}
\li |\newinsert| 预留一个插入项类型。%
（预留一个插入项类型包括预留几个不同的寄存器。）
^^{插入项//用 \b\tt\\newinsert\e 预留编号}
\li |\newlanguage| 预留一套连字模式。
\endulist
为避免编号冲突，在需要这些实体之一时你应当使用这些命令，除非在很局部的范围中。

%There's an important difference among these commands:
%\ulist
%\li The control sequences defined by
%|\newcount|, |\newdimen|, |\newskip|, |\newmuskip|, and |\newtoks|
%each designate an entity of the appropriate type.
%For instance, after the command:
%\csdisplay
%\newdimen\listdimen
%|
%the control sequence |\listdimen| can be used as a dimension.
%\li The control sequences defined by
%|\newbox|, |\newread|, |\newwrite|, |\newfam|, |\newinsert|,
%and |\newlanguage|  each
%evaluate to the \emph{number} of an entity of the appropriate type.
%For instance, after the command:
%\csdisplay
%\newbox\figbox
%|
%the control sequence |\figbox| must be used in conjunction with
%a |\box|-like command, e.g.:
%\csdisplay
%\setbox\figbox = \vbox{!dots}
%|
%\endulist
%\enddesc
这些命令之间还有一个很重要的区别：
\ulist
\li 用 |\newcount|、|\newdimen|、|\newskip|、|\newmuskip| 以及
|\newtoks| 定义的控制序列各自指明一个相应类型的实体。
例如在执行命令
\csdisplay
\newdimen\listdimen
|
之后，控制序列 |\listdimen| 可以用作一个尺寸。
\li 用 |\newbox|、|\newread|、|\newwrite|、|\newfam|、|\newinsert| 以及
|\newlanguage| 定义的控制序列各自表示相应类型的实体的\emph{编号}。
例如在执行命令
\csdisplay
\newbox\figbox
|
之后，控制序列 |\figbox| 必须和 类似 |\box| 的命令一起使用，比如：
\csdisplay
\setbox\figbox = \vbox{!dots}
|
\endulist
\enddesc

%\begindesc
%\cts countdef {\<control sequence> {\bt =} \<register>}
%\cts dimendef {\<control sequence> {\bt =} \<register>}
%\cts skipdef {\<control sequence> {\bt =} \<register>}
%\cts muskipdef {\<control sequence> {\bt =} \<register>}
%\cts toksdef {\<control sequence> {\bt =} \<register>}
%\explain
%These commands define \<control sequence> to refer to the
%\minref{register} of the indicated category whose number is \<register>.
%Normally you should use the commands in the previous group
%(|\newcount|, etc.) in preference to these commands in order to avoid
%numbering conflicts.  The commands in the previous group are
%defined in terms of the commands \hbox{in this group}.
%\example
%\countdef\hatters = 19 % \hatters now refers to \count19
%\toksdef\hares = 200 % \hares now refers to \toks200
%|
%\endexample
%\enddesc
\begindesc
\cts countdef {\<control sequence> {\bt =} \<register>}
\cts dimendef {\<control sequence> {\bt =} \<register>}
\cts skipdef {\<control sequence> {\bt =} \<register>}
\cts muskipdef {\<control sequence> {\bt =} \<register>}
\cts toksdef {\<control sequence> {\bt =} \<register>}
\explain
这些命令将 \<control sequence> 定义为指定类型的编号为 \<register> 的\minref{寄存器}。
为避免编号冲突，通常你应当使用前面那些命令（|\newcount| 等），而不是使用这些命令。
实际上，前面那些命令就是用这些命令来定义的.
\example
\countdef\hatters = 19 % \hatters now refers to \count19
\toksdef\hares = 200 % \hares now refers to \toks200
|
\endexample
\enddesc

%\see |\newif| (\xref{\@newif}), |\newhelp| (\xref{\@newhelp}).
%\eix^^{registers//reserving}
\see |\newif| (\xref{\@newif}), |\newhelp| (\xref{\@newhelp}).
\eix^^{寄存器//预留寄存器}

%==========================================================================
%\subsection {Doing arithmetic in registers}
\subsection {寄存器中的算术运算}

%\begindesc
%\bix^^{arithmetic}
%\bix^^{registers//arithmetic in}
%%
%\cts advance {\<count register> {\bt by} \<number>}
%\aux\cts advance {\<dimen register> {\bt by} \<dimen>}
%\aux\cts advance {\<skip register> {\bt by} \<glue>}
%\aux\cts advance {\<muskip register> {\bt by} \<muglue>}
%\explain
%This command adds a compatible quantity to a register.  For \<glue>
%or \<muglue> all three components (natural value, stretch, and shrink)
%\minrefs{glue} are added.
%Any of the quantities can be negative.  For purposes of these calculations
%(and other assignments as well), \<glue> can be converted to a
%\<dimen> by dropping the stretch and shrink, and a \<dimen> can be converted
%to a \<number> by taking its value in scaled points
%\seeconcept{dimension}.
%You can omit the word |by| in these commands---\TeX\ will understand them
%anyway.
%\example
%\count0 = 18 \advance\count0 by -1 \number\count0\par
%\skip0 = .5in \advance\skip0 by 0in plus 1in % add stretch
%\hbox to 2in{a\hskip\skip0 b}
%|
%\produces
%\count0 = 18 \advance\count0 by -1 \number\count0\par
%\skip0 = .5in \advance\skip0 by 0in plus 1in % add stretch
%\hbox to 2in{a\hskip\skip0 b}
%\doruler{\8\8}2{in}
%\endexample
%\enddesc
\begindesc
\bix^^{算术}
\bix^^{寄存器//寄存器中的算术运算}
%
\cts advance {\<count register> {\bt by} \<number>}
\aux\cts advance {\<dimen register> {\bt by} \<dimen>}
\aux\cts advance {\<skip register> {\bt by} \<glue>}
\aux\cts advance {\<muskip register> {\bt by} \<muglue>}
\explain
此命令给寄存器加上一个兼容的数量。对于 \<glue> 或 \<muglue>，
三个部分（自然尺寸、伸长量和收缩量）\minrefs{粘连}都被加上。
任何数量都可以是负的。为方便这些计算（以及其他的赋值），
\<glue> 可以通过丢掉伸长量和收缩量转换为 \<dimen>，
而 \<dimen> 可以通过取以 scaled point 为单位的值转换为 \<number>%
\seeconcept{尺寸}。
在这些命令中，你可以忽略单词 |by| ——这两种写法 \TeX\ 都能理解。
\example
\count0 = 18 \advance\count0 by -1 \number\count0\par
\skip0 = .5in \advance\skip0 by 0in plus 1in % add stretch
\hbox to 2in{a\hskip\skip0 b}
|
\produces
\count0 = 18 \advance\count0 by -1 \number\count0\par
\skip0 = .5in \advance\skip0 by 0in plus 1in % add stretch
\hbox to 2in{a\hskip\skip0 b}
\doruler{\8\8}2{in}
\endexample
\enddesc

%\begindesc
%\cts multiply {\<register> {\bt by} \<number>}
%\cts divide {\<register> {\bt by} \<number>}
%\explain
%These commands multiply and divide the value in \<register>
%by \<number> (which can be negative).
%The register can be a ^|\count|, ^|\dimen|, ^|\skip|, or ^|\muskip|
%register.
%For a ^|\skip| or ^|\muskip| register (\xref\skip),
%all three components of the \minref{glue} in the register are modified.
%You can omit the word |by| in these commands---\TeX\ will understand them
%anyway.
\begindesc
\cts multiply {\<register> {\bt by} \<number>}
\cts divide {\<register> {\bt by} \<number>}
\explain
这两个命令将 \<register> 中的值乘以或除以 \<number>（它可以为负数）。
其中的寄存器可以是 ^|\count|、^|\dimen|、^|\skip| 或 ^|\muskip| 寄存器。
对于 ^|\skip| 或 ^|\muskip| 寄存器（\xref\skip ），
在寄存器中\minref{粘连}的三个部分都被修改。
在这些命令中，你可以忽略单词 |by| ——这两种写法 \TeX\ 都能理解。

%You can also obtain a multiple of a \<dimen> by preceding it by a \<number>
%\minrefs{number}
%or decimal constant, e.g.,
%|-2.5\dimen2|.
%You can also use this notation for \<glue>, but watch out---the result
%is a \<dimen>, not \<glue>.
%Thus |2\baselineskip| yields a \<dimen> that is twice the natural size
%of |\baselineskip|, with no stretch or shrink.
%\example
%\count0 = 9\multiply \count0 by 8 \number\count0 ;
%\divide \count0 by 12 \number\count0 \par
%\skip0 = 20pt plus 2pt minus 3pt \multiply \skip0 by 3
%Multiplied value of skip0 is \the\skip0.\par
%\dimen0 = .5in \multiply\dimen0 by 6
%\hbox to \dimen0{a\hfil b}
%|
%\produces
%\count0 = 9\multiply \count0 by 8 \number\count0 ;
%\divide \count0 by 12 \number\count0 \par
%\skip0 = 20pt plus 2pt minus 3pt \multiply \skip0 by 3
%Multiplied value of skip0 is \the\skip0.\par
%\dimen0 = .5in \multiply\dimen0 by 6
%\hbox to \dimen0{a\hfil b}
%\doruler{\8\8\8}3{in}
%\endexample
在 \<dimen> 前面加上 \<number>\minrefs{number}或小数，你可以得到它的倍数，
比如 |-2.5\dimen2|。在 \<glue> 前面也可以使用此写法，
但小心注意——结果是一个 \<dimen> 而不是 \<glue>。
比如用 |2\baselineskip| 将得到一个 \<dimen>，
它等于 |\baselineskip| 的自然尺寸的两倍，但没有伸长量和收缩量。
\example
\count0 = 9\multiply \count0 by 8 \number\count0 ;
\divide \count0 by 12 \number\count0 \par
\skip0 = 20pt plus 2pt minus 3pt \multiply \skip0 by 3
Multiplied value of skip0 is \the\skip0.\par
\dimen0 = .5in \multiply\dimen0 by 6
\hbox to \dimen0{a\hfil b}
|
\produces
\count0 = 9\multiply \count0 by 8 \number\count0 ;
\divide \count0 by 12 \number\count0 \par
\skip0 = 20pt plus 2pt minus 3pt \multiply \skip0 by 3
Multiplied value of skip0 is \the\skip0.\par
\dimen0 = .5in \multiply\dimen0 by 6
\hbox to \dimen0{a\hfil b}
\doruler{\8\8\8}3{in}
\endexample

%\eix^^{arithmetic}
%\eix^^{registers//arithmetic in}
%\eix^^{registers}
%\enddesc
\eix^^{算术}
\eix^^{寄存器//寄存器中的算术运算}
\eix^^{寄存器}
\enddesc

%==========================================================================
%\section {Ending the job}
\section {结束任务}

%\begindesc
%^^{ending the job}
%\easy\ctspecial bye \ctsxrdef{@bye}
%\explain
%This command tells \TeX\ to fill out and produce the last page, print
%any held-over \minref{insertion}s, and end the job.
%It is the usual way to end your input file.
%\enddesc
\begindesc
^^{结束任务}
\easy\ctspecial bye \ctsxrdef{@bye}
\explain
此命令让 \TeX\ 填满并生成最后的页面，打印遗留的\minref{插入项}，并结束任务。
这是结束输入文件的常用方式。
\enddesc

%\begindesc
%\cts end {}
%\explain
%This command tells \TeX\ to produce the last page and end the job.
%It does not fill out the page, however,
%so it's usually better to use |\bye| rather than |\end|.
%\enddesc
\begindesc
\cts end {}
\explain
此命令让 \TeX\ 生成最后的页面并结束任务。
但由于它不会填满页面，一般情形用 |\bye| 比用 |\end| 更好些。
\enddesc

%==========================================================================
%\section {Input and output}
\section {输入和输出}

%==========================================================================
%\subsection {Operations on input files}
\subsection {操作输入文件}

%\begindesc
%\bix^^{files}
%\bix^^{input files}
%\easy\cts input {\<filename>}
%\explain
%\minrefs{file}\minrefs{file name}
%This command tells \TeX\ to read its input from file \<filename>.
%When that file is exhausted, \TeX\ returns to reading from its previous
%input source.  You can nest input files to any level you like
%(within reason).
\begindesc
\bix^^{文件}
\bix^^{输入文件}
\easy\cts input {\<filename>}
\explain
\minrefs{file}\minrefs{file name}
此命令让 \TeX\ 从文件 \<filename> 读取输入。
当该文件用完后，\TeX\ 回到之前的输入来源继续读取。
你可以嵌套输入文件到任何层级（在合理范围内）。

%When you're typesetting a large document, it's usually a good idea to
%structure your main file as a sequence of |\input| commands that refer
%to the subsidiary parts of the document.  That way you can process the
%individual parts easily as you're working on drafts.  It's also a good
%practice to put all of your \minref{macro} definitions into a separate file and
%summon that file with an |\input| command as the first action in your
%main file.
在排版一个大文档时，通常在主文件写上一系列 |\input| 命令，以引入文档的各个子文件。
用这种方式，在打草稿阶段你可以很方便地处理文档的单个部分。
还有个好习惯就是，将所有\minref{宏定义}放在一个独立文件中，
并在主文件一开始用 |\input| 命令引入它。

%\TeX\ uses different rules for scanning file names than it does for scanning
%\minref{token}s in general (see \xref{file name}).
%If your implementation expects file names to have extensions (usually
%indicated by a preceding dot), then \TeX\ provides a default extension
%of |.tex|.
%\example
%\input macros.tex
%\input chap1 % equivalent to chap1.tex
%|
%\endexample
%\enddesc
\TeX\ 扫描文件名的规则一般和扫描\minref{记号}的不同（见\xref{文件名}）。
如果 \TeX\ 系统要求文件名包含扩展名（通常在前面加上点号表示），
则 \TeX\ 以 |.tex| 作为默认扩展名。
\example
\input macros.tex
\input chap1 % equivalent to chap1.tex
|
\endexample
\enddesc

%\begindesc
%\cts endinput {}
%\explain
%This command tells \TeX\ to stop reading input from the current file when it
%next reaches the end of a line.
%\enddesc
\begindesc
\cts endinput {}
\explain
此命令让 \TeX\ 在这一行读完后停止从当前文件读取输入。
\enddesc

%\begindesc
%\cts inputlineno {}
%\explain
%This command yields a number (not a string) giving the line number of the
%current line, defined to be the number that would appear in an error message
%if an error occurred at this point.
%\enddesc
\begindesc
\cts inputlineno {}
\explain
此命令生成一个给出当前行编号的数（不是字符串），
当此处有错误时，它就是写在错误信息中的行数。
\enddesc

%\begindesc
%\cts openin {\<number> {\bt =} \<filename>}
%\explain
%This command tells \TeX\ to open the file named \<filename>
%and make it available for reading  via the input stream
%designated by \<number>.
%^^{input streams//opening}
%\<number> must be between $0$ and $15$.
%Once you've opened a file and connected it to an input stream,
%you can read from the file using the |\read| command
%with the input stream's number.
\begindesc
\cts openin {\<number> {\bt =} \<filename>}
\explain
此命令让 \TeX\ 打开名为 \<filename> 的文件，
让我们可以通过编号为 \<number> 的输入流读取它。
^^{输入流//打开输入流}
\<number> 必须在 $0$ 和 $15$ 之间。
一旦打开了一个文件并将它连接到一个输入流，
你就可以用|\read| 命令以输入流编号读取其内容。

%You can associate more than one input stream with the same
%file.  You can then read from several different positions within
%the file, one for each input stream.
你可以把同一个文件和多个输入流连接。
这样你就可以从文件的多个不同位置读取内容，每个输入流对应一个位置。

%You should allocate stream numbers for |\openin| using
%|\new!-read| (\xref{\@newread}).
%\example
%\newread\auxfile  \openin\auxfile = addenda.aux
%% \auxfile now denotes the number of this opening
%% of addenda.aux.
%|
%\endexample
%\enddesc
你应当用 |\new!-read|（\xref{\@newread}）命令分配 |\openin| 的流编号。
\example
\newread\auxfile  \openin\auxfile = addenda.aux
% \auxfile now denotes the number of this opening
% of addenda.aux.
|
\endexample
\enddesc

%\begindesc\secondprinting{\vglue-.5\baselineskip\vskip0pt}
%\cts closein {\<number>}
%\explain
%This command tells \TeX\ to close the \minref{input stream} numbered
%\<number>, i.e.,
%end the association between the input stream and its file.
%The input stream with this number then becomes available for use with a
%different file.
%You should close an input stream once you're finished using its file.
%\example
%\closein\auxfile
%|
%\endexample
%\enddesc
\begindesc%\secondprinting{\vglue-.5\baselineskip\vskip0pt}
\cts closein {\<number>}
\explain
此命令让 \TeX\ 关闭编号为 \<number> 的\minref{输入流}，
结束输入流与文件之间的关联。
此编号的输入流以后就可以用于其他文件。
在文件使用完成后你应当关闭输入流。
\example
\closein\auxfile
|
\endexample
\enddesc

%\begindesc\secondprinting{\vglue-.5\baselineskip\vskip0pt}
%\cts read {\<number> {\bt to} \<control sequence>}
%\explain
%^^{input streams//reading with \b\tt\\read\e}
%^^{reading a file}
%This command tells \TeX\ to read a line from the file
%associated with the \minref{input stream}
%designated by \<number> and assign the tokens on that line to
%\<control sequence>.  The \minref{control sequence} then becomes a
%parameterless \minref{macro}.  No macro expansion takes place
%during the reading operation.  If the line contains any unmatched
%left braces, \TeX\ will read additional lines until the braces are
%all matched.  If \TeX\ reaches the end of the file without matching all the
%braces, it will complain.
\begindesc%\secondprinting{\vglue-.5\baselineskip\vskip0pt}
\cts read {\<number> {\bt to} \<control sequence>}
\explain
^^{输入流//用 \b\tt\\read\e 读取}
^^{读取文件}
此命令让 \TeX\ 从编号 \<number> 的\minref{输入流}关联的文件中读取一行，
并将该行的记号赋予 \<control sequence>。
该\minref{控制序列}就成为一个不带参数的\minref{宏}。
在读取操作中 \TeX\ 不会执行宏展开。如果该行包含未配对的左花括号，
\TeX\ 将读取额外的行直到花括号全部配对。
如果直到文件结束还无法配对所有花括号，\TeX\ 将报错。

%If \<number> is greater than $15$ or hasn't been associated with a file
%using ^|\openin|, \TeX\ prompts you with `\<control sequence> |=|'
%on your terminal and waits for you to type a line of input.
%It then assigns the input line to \<control sequence>.
%If \<number> is less than zero, it reads a line of input from your
%terminal but omits the prompt.
%\example
%\read\auxfile to \holder
%% Expanding \holder will produce the line just read.
%|
%\endexample
%\eix^^{input files}
%\enddesc
如果 \<number> 大于 $15$ 或者还未用 ^|\openin| 关联文件，
\TeX\ 将在终端上显示提示符 `\<control sequence> |=|'，
等待你键入一行输入，然后将该行输入赋予 \<control sequence>。
如果 \<number> 小于零，它同样从终端读取输入，但不显示提示符。
\example
\read\auxfile to \holder
% Expanding \holder will produce the line just read.
|
\endexample
\eix^^{输入文件}
\enddesc

%\secondprinting{\vfill\eject}


%==========================================================================
%\subsection {Operations on output files}
\subsection {操作输出文件}

%\bix^^{output files}
%\begindesc
%\cts openout {\<number> {\bt =} \<filename>}
%\explain
%^^{output streams//opening}
%This command tells \TeX\ to open the file named \<filename>
%and make it available for writing  via the \minref{output stream}
%designated by \<number>.
%\<number> must be between $0$ and $15$.
%Once you've opened a file and connected it to an output stream,
%you can write to the file using the |\write| command
%with the output stream's number.
\bix^^{输出文件}
\begindesc
\cts openout {\<number> {\bt =} \<filename>}
\explain
^^{输出流//打开输出流}
此命令让 \TeX\ 打开名为 \<filename> 的文件，
让我们可以通过编号为 \<number> 的\minref{输出流}写入它。
\<number> 必须在 $0$ 和 $15$ 之间。
一旦打开了一个文件并将它连接到一个输出流，
你就可以用 |\write| 命令以输出流编号读取其内容。

%An |\openout| generates a whatsit that becomes part of a box.
%The |\openout| does not take effect until \TeX\ ships out that box
%to the \dvifile,
%unless you've preceded the |\openout| with ^|\immediate|.
|\openout| 命令生成一个作为盒子一部分的小玩意。
直到 \TeX\ 将该盒子送出到 \dvifile 时 |\openout| 才会起作用，
除非你在 |\openout| 之前加上 ^|\immediate| 命令。

%\TeX\ won't complain if you associate more than one output stream with the
%same file, but you'll get garbage in the file if you try it!
如果你把同一个文件和多个输出流关联，\TeX\ 不会报错，但这样做将得到一些垃圾！

%You should allocate stream numbers for |\openout| using
%|\newwrite| (\xref{\@newwrite}).
%\example
%\newwrite\auxfile  \openout\auxfile = addenda.aux
%% \auxfile now denotes the number of this opening
%% of addenda.aux.
%|
%\endexample
%\enddesc
你应当用 |\newwrite|（\xref{\@newwrite}）为 |\openout| 分配编号。
\example
\newwrite\auxfile  \openout\auxfile = addenda.aux
% \auxfile now denotes the number of this opening
% of addenda.aux.
|
\endexample
\enddesc

%\begindesc
%\cts closeout {\<number>}
%\explain
%^^{output streams//closing}
%This command tells \TeX\ to close the \minref{output stream} numbered
%\<number>. i.e.,
%end the association between the output stream and its file.
%The output stream with this number then becomes available for use with a
%different file.
%You should close an output stream once you're finished using its file.
\begindesc
\cts closeout {\<number>}
\explain
^^{输出流//关闭输出流}
此命令让 \TeX\ 关闭编号为 \<number> 的\minref{输出流}，
结束输出流与文件之间的关联。
此编号的输出流以后就可以用于其他文件。
在文件使用完成后你应当关闭输出流。

%A |\closeout| generates a whatsit that becomes part of a box.
%The |\closeout| does not take effect until \TeX\ ships out that box
%to the \dvifile,
%unless you've preceded the |\closeout| with ^|\immediate|.
%\example
%\closeout\auxfile
%|
%\endexample
%\enddesc
|\closeout| 命令生成一个作为盒子一部分的小玩意。
直到 \TeX\ 将该盒子送出到 \dvifile 时 |\closeout| 才会起作用，
除非你在 |\closeout| 之前加上 ^|\immediate| 命令。
\example
\closeout\auxfile
|
\endexample
\enddesc

%\begindesc
%\cts write {\<number> \rqbraces{\<token list>}}
%\explain
%^^{output streams//writing}
%^^{writing a file}
%This command tells \TeX\ to write \<token list> to the file
%associated with the \minref{output stream}
%designated by \<number>.
%It generates a whatsit that becomes part of a box.
%The actual writing does not take place until \TeX\ ships out that box
%to the \dvifile,
%unless you've preceded the |\write| with ^|\immediate|.
\begindesc
\cts write {\<number> \rqbraces{\<token list>}}
\explain
^^{输出流//写入输出流}
^^{写入文件}
此命令让 \TeX\ 将 \<token list> 写入编号为 \<number> 的\minref{输出流}的关联文件中。
它生成一个作为盒子一部分的小玩意。
直到 \TeX\ 将该盒子送出到 \dvifile 时才会实际写入文件，
除非你在 |\write|  之前加上 ^|\immediate| 命令。

%For a |\write| that is not immediate, \TeX\ does not expand macros in
%\<token list> until the token list is actually written to the file.
%The macro expansions follow the same rules as |\edef| (\xref\edef).
%In particular, any control sequence that is not
%the name of a macro is written as
%^|\escapechar| followed by the control sequence name
%and a space.  Any `|#|' tokens
%in \<token list> are doubled, i.e., written as `|##|'.
对于非立即（immediate）的 |\write|，
\TeX\ 直到实际写入文件时才展开 \<token list> 中的宏。
宏展开遵循与 |\edef|（\xref\edef ）一样的规则。
任何不是宏名称的控制序列被写成 ^|\escapechar| 加上控制序列名，
后面再加一个空格。\<token list> 中的任何 `|#|' 记号被重复两遍，即写成 `|##|'。

%If \<number> is not in the range from $0$ to $15$, \TeX\ writes
%\<token list> to the log file.
%^^{log file//written by \b\tt\\write\e}
%If \<number> is greater than $15$ or isn't associated with an output
%stream, \TeX\ also writes \<token list> to the terminal.
%\example
%\def\aa{a a}
%\write\auxfile{\hbox{$x#y$} \aa}
%% Writes the string `\hbox {$x##y$} a a' to \auxfile.
%|
%\endexample
%\enddesc
如果 \<number> 不在 $0$ 到 $15$ 的范围中，
\TeX\ 将 \<token list> 写入到日志文件。
^^{日志文件//用 \b\tt\\write\e 写入}
如果 \<number> 大于 $15$ 或该输出流未关联文件，
\TeX\ 还同时将 \<token list> 写到终端中。
\example
\def\aa{a a}
\write\auxfile{\hbox{$x#y$} \aa}
% Writes the string `\hbox {$x##y$} a a' to \auxfile.
|
\endexample
\enddesc

%\begindesc
%\cts immediate {}
%\explain
%This command should precede an |\openout|, |\closeout|, or |\write|.
%^^|\write//with {\tt\\immediate}|
%^^|\openout//with {\tt\\immediate}|
%^^|\closeout//with {\tt\\immediate}|
%It tells \TeX\ to perform the specified file operation without delay.
%\example
%\immediate\write 16{I'm stuck!!}
%% has the same effect as \message
%|
%\endexample\enddesc
\begindesc
\cts immediate {}
\explain
此命令应当放在 |\openout|、|\closeout| 或 |\write| 之前。
^^|\write//和 {\tt\\immediate} 一起|
^^|\openout//和 {\tt\\immediate} 一起|
^^|\closeout//和 {\tt\\immediate} 一起|
它让 \TeX\ 立即执行指定的文件操作。
\example
\immediate\write 16{I'm stuck!!}
% has the same effect as \message
|
\endexample\enddesc

%\begindesc
%\cts special {\rqbraces{\<token list>}}
%\explain
%This command tells \TeX\ to
%write \<token list> directly to the \dvifile\ when it next
%ships out a page.
%A typical use of |\special| would be to tell the device driver to incorporate
%the contents of a named graphics file into the output page.
%^^{device drivers//instructions from \b\tt\\special\e}
%The |\special| command produces a whatsit that associates
%\<token list> with a particular position on the page, namely,
%the position that a zero-size box would have had if such a box
%had appeared instead of the |\special| command.
%Any use you might make of |\special| depends strictly on
%the ^{device drivers} that you have available.
%\example
%\special{graphic expic}
%% Display the graphics file `expic' here.
%|
%\endexample
%\enddesc
\begindesc
\cts special {\rqbraces{\<token list>}}
\explain
此命令让 \TeX\ 下次送出页面时将 \<token list> 直接写入 \dvifile 中。
|\special| 的一个典型用法是，
让设备驱动器将指定名称的图片文件整合到输出页面中。
^^{设备驱动//用 \b\tt\\special\e 指导它}
|\special| 命令生成一个包含 \<token list> 和一个特定位置的小玩意，
该位置是将 |\special| 命令换成零尺寸盒子时该盒子应该出现的位置。
你可以怎样使用 |\special| 命令，完全取决于你可用的^{设备驱动器}。
\example
\special{graphic expic}
% Display the graphics file `expic' here.
|
\endexample
\enddesc

%\begindesc
%\cts newlinechar {\param{number}}
%\explain
%This parameter contains a character that indicates a new line on
%output.  When \TeX\ encounters this character
%while reading the argument of
%a |\write|, |\message|, or
%|\errmessage| command, it starts a new line.
%If |\newlinechar| is not in the range $0$--$255$,
%there is no character that indicates
%a new line on output.
%\PlainTeX\ sets |\newlinechar| to $-1$.
%\example
%\newlinechar = `\^^J
%\message{This message appears^^Jon two lines.}
%|
%\logproduces
%This message appears
%on two lines.
%|
%\endexample
%\enddesc
\begindesc
\cts newlinechar {\param{number}}
\explain
此参数表示输出时所用的换行符。
在读取 |\write|、|\message| 或 |\errmessage| 命令的参量时，
如果 \TeX\ 遇到这个字符，它就新起一行。
如果 |\newlinechar| 不在 $0$--$255$ 的范围内，
输出中就不会任何换行符。
\PlainTeX\ 设定 |\newlinechar| 等于 $-1$。
\example
\newlinechar = `\^^J
\message{This message appears^^Jon two lines.}
|
\logproduces
This message appears
on two lines.
|
\endexample
\enddesc

%\see |\newread|, |\newwrite| (\xref{\@newwrite}).
%\eix^^{files}
%\eix^^{output files}
\see |\newread|, |\newwrite| (\xref{\@newwrite}).
\eix^^{文件}
\eix^^{输出文件}

%==========================================================================
%\subsection {Interpreting input characters}
\subsection {解释输入字符}

%\begindesc
%\cts catcode {\<charcode> \tblentry{number}}
%\explain
%^^{category codes//in \b\tt\\catcode\e\ table}
%This table entry contains the \minref{category code} of the character
%whose \ascii\ code is \<charcode>.
%The category codes are listed on \xrefpg{catcodes}.
%By changing the category code of a character you can get \TeX\ to treat
%that character differently.
%\example
%\catcode `\[ = 1 \catcode `\] = 2
%% Make [ and ] act like left and right braces.
%|
%\endexample
%\enddesc
\begindesc
\cts catcode {\<charcode> \tblentry{number}}
\explain
^^{类别码//在 \b\tt\\catcode\e\ 表格中}
此表格项表示 \ascii\ 码为 \<charcode> 的字符的\minref{类别码}。
\xrefpg{catcodes}列出了所有的类别码。
通过修改一个字符的类别码，你可以让 \TeX\ 用不同方式处理该字符。
\example
\catcode `\[ = 1 \catcode `\] = 2
% Make [ and ] act like left and right braces.
|
\endexample
\enddesc

%\begindesc
%\cts active {}
%\explain
%This command contains the
%category code for an active character, namely, the number $13$.
%\example
%\catcode `\@ = \active % Make @ an active character.
%|
%\endexample
%\enddesc
\begindesc
\cts active {}
\explain
此命令表示活动字符的类别码，即数字 $13$。
\example
\catcode `\@ = \active % Make @ an active character.
|
\endexample
\enddesc

%\begindesc
%\cts mathcode {\<charcode> \tblentry{number}}
%\explain
%This table entry contains the \minref{mathcode} of the character
%whose \ascii\ code is \<charcode> \seeconcept{mathcode}.
%The mathcode specifies that character's interpretation in math mode.
%\example
%\mathcode\> = "313E % as in plain TeX
%% The > character has class 3 (relation), family 1 (math
%% italic), and character code "3E
%|
%\endexample
%\enddesc
\begindesc
\cts mathcode {\<charcode> \tblentry{number}}
\explain
此表格项表示 \ascii\ 码为 \<charcode> 的字符的\minref{数学码}\seeconcept{数学码}。
数学码指明在数学模式中如何解释该字符。
\example
\mathcode\> = "313E % as in plain TeX
% The > character has class 3 (relation), family 1 (math
% italic), and character code "3E
|
\endexample
\enddesc

%\begindesc
%\margin{{\tt\\delcode} was explained in two places.  This explanation
%combines them.  (The other place was in the math section.)}
%\cts delcode {\<charcode>\tblentry{number}}
%\explain
%^^{delimiter codes}
%This table entry specifies the \minref{delimiter} code for the input character
%whose \ascii\ code is \<charcode>.
%The delimiter code tells \TeX\ how to find the best output character to use
%for typesetting the indicated input character as a delimiter.
\begindesc
\margin{{\tt\\delcode} was explained in two places.  This explanation
combines them.  (The other place was in the math section.)}
\cts delcode {\<charcode>\tblentry{number}}
\explain
^^{定界码}
此表格项表示 \ascii\ 码为 \<charcode> 的输入字符的定界码。
定界码指引 \TeX\ 找到最佳输出字符以将该输入字符排版为定界符。

%\<number> is normally written in hexadecimal notation.
%Suppose that \<number> is the hexadecimal number $s_1s_2s_3\,
%l_1l_2l_3$.  Then when the character is used as a delimiter,
%\TeX\ takes the character to have small variant
%$s_1s_2s_3$ and large variant $l_1l_2l_3$.  Here $s_1s_2s_3$ indicates
%the math character found in position $s_2s_3$ of family $s_1$, and
%similarly for $l_1l_2l_3$.  This is the same convention as the one
%used for ^|\mathcode| (\xref \mathcode),
%except that |\mathcode| also specifies a class.
%\example
%\delcode `( = "028300  % As in plain TeX.
%|
%\endexample
%\enddesc
通常以十六进制表示 \<number>。
假设 \<number> 等于十六进制数 $s_1s_2s_3\,l_1l_2l_3$。
则当该字符用作定界符时，该字符的小型变体为 $s_1s_2s_3$，大型变体为 $l_1l_2l_3$。
这里 $s_1s_2s_3$ 表示在第 $s_1$ 族的 $s_2s_3$ 位置的数学字符，$l_1l_2l_3$ 类似。
这与 ^|\mathcode|（\xref\mathcode ）中的用法一样，
只是 |\mathcode| 还另外指定了字符类。
\example
\delcode `( = "028300  % As in plain TeX.
|
\endexample
\enddesc

%\begindesc
%\cts endlinechar {\param{number}}
%\explain
%This parameter
%contains the character code for the  character that
%\TeX\ appends to the end of each input line.
%^^{input lines}
%A value not in the range $0$--$255$
%indicates that no character should be appended.
%\PlainTeX\ leaves |\end!-line!-char| at
%|`\^^M| (the {\ascii} code for \asciichar{return}).
%\enddesc
\begindesc
\cts endlinechar {\param{number}}
\explain
此参数表示 \TeX\ 在每个输入行后添加的行尾符。
^^{输入行}
取不在 $0$--$255$ 范围内的值则表示不添加行尾符。
\PlainTeX\ 设定 |\end!-line!-char| 为 |`\^^M|%
（即 \asciichar{return} 符的{\ascii}码）。
\enddesc

%\begindesc
%\cts ignorespaces {}
%\explain
%This command tells \TeX\ to read and expand tokens until it finds one that
%is not a space \minref{token}, ignoring any space tokens
%that it finds on the way.
%|\ignorespaces| is often useful at the end of a \minref{macro} as a way
%of making the macro insensitive to any spaces or ends of line
%that might follow calls on it.
%(An empty line after |\ignorespaces| still produces a |\par| token,
%however.)
%\example
%\def\aa#1{yes #1\ignorespaces}
%\aa{may}
%be
%|
%\produces
%\def\aa#1{yes #1\ignorespaces}
%\aa{may}
%be
%\endexample
%\enddesc
\begindesc
\cts ignorespaces {}
\explain
此命令让 \TeX\ 读取和展开记号，
直到找到一个非空格\minref{记号}，并忽略它找到的任何空格记号。
|\ignorespaces| 常用在\minref{宏}结尾处，
使得调用宏时不受后面的空格符或换行符的影响。%
（但是 |\ignorespaces| 之后的空行依然生成 |\par| 记号）。
\example
\def\aa#1{yes #1\ignorespaces}
\aa{may}
be
|
\produces
\def\aa#1{yes #1\ignorespaces}
\aa{may}
be
\endexample
\enddesc

%==========================================================================
%\section {Controlling interaction with \TeX}
\section {控制与 \TeX\ 的交互}

%\begindesc
%\bix^^{controlling \TeX}
%\bix^^{running \TeX}
%\cts errorstopmode {}
%\explain
%This command tells \TeX\
%to stop for interaction whenever it finds an error.
%This is the normal mode of operation.
%\enddesc
\begindesc
\bix^^{控制 \TeX}
\bix^^{运行 \TeX}
\cts errorstopmode {}
\explain
此命令让 \TeX\ 遇到错误时暂停以和用户交互。
这是 \TeX\ 运行的正常模式。
\enddesc

%\begindesc
%\cts scrollmode {}
%\explain
%This command tells \TeX\
%not to stop for most errors,
%but to continue displaying the error messages on your terminal.
%Typing `|S|' or `|s|' in response to an error message puts you
%into scroll mode.
%\enddesc
\begindesc
\cts scrollmode {}
\explain
此命令让 \TeX\ 遇到大多数错误时不暂停，而仅在终端上显示错误信息。
在回应错误信息时键入 `|S|' 或 `|s|' 就进入卷动模式。
\enddesc

%\begindesc
%\cts nonstopmode {}
%\explain
%This command tells \TeX\
%not to stop for errors, even those pertaining to files that
%it can't find, but to continue displaying the error messages on your terminal.
%Typing `|R|' or `|r|' in response to an error message puts you
%into nonstop mode.
%\enddesc
\begindesc
\cts nonstopmode {}
\explain
此命令让 \TeX\ 遇到错误时不暂停，即使是那些无法找到文件的错误，
而仅仅在终端上显示错误信息。
在回应错误信息时键入 `|R|' 或 `|r|' 就进入直达模式。
\enddesc

%\begindesc
%\cts batchmode {}
%\explain
%This command tells \TeX\
%not to stop for errors and to suppress all further output to your terminal.
%Typing `|Q|' or `|q|' in response to an error message puts you
%into batch mode.
%\enddesc
\begindesc
\cts batchmode {}
\explain
此命令让 \TeX\ 遇到错误时不暂停，且取消在终端上显示此后的输出。
在回应错误信息时键入 `|Q|' 或 `|q|' 就进入批处理模式。
\enddesc

%\begindesc
%\cts pausing {\param{number}}
%\explain
%If this parameter is greater than zero, \TeX\ will pause
%at each line of input to give you an opportunity to
%replace it with a different line.  If you type in a replacement,
%\TeX\ will use that line instead of the original one; if you respond
%with \asciichar{return}, \TeX\ will use the original line.
\begindesc
\cts pausing {\param{number}}
\explain
如果此参数大于零，\TeX\ 将在每个输入行后暂停，让你有机会将该行替换为另外一行。
如果你键入替换行，\TeX\ 就将原来的行替换为此行；
如果你键入\asciichar{return}符，\TeX\ 将使用原来的行。

%Setting |\pausing| to $1$ can be useful as a way of patching a document as
%\TeX\ is processing it.  For example,
%you can use this facility to insert ^|\show| commands (see below).
%\eix^^{running \TeX}
%\eix^^{controlling \TeX}
%\enddesc
将 |\pausing| 设定为 $1$，是在 \TeX\ 处理文档时修补它的常用方法。
例如，你可以用这种方式插入 ^|\show| 命令（见下面）。
\eix^^{运行 \TeX}
\eix^^{控制 \TeX}
\enddesc

%==========================================================================
%\section {Diagnostic aids}
\section {帮助调试}

%\subsection{Displaying internal data}
\subsection{显示内部数据}

%\begindesc
%\bix^^{tracing}
%\bix^^{debugging}
%\bix^^{diagnostic aids}
%\cts show {\<token>}
%\cts showthe {\<argument>}
%\cts showbox {\<number>}
%\cts showlists {}
%\explain
%These commands record information in the log of your \TeX\ run:
%\ulist
%\li |\show| records the meaning of \<token>.\minrefs{token}
%^^{tokens//displayed by \b\tt\\show\e}
%\li |\showthe| records
% whatever tokens would be produced by
%|\the| \<arg\-u\-ment> (see \xref \the).
%\li |\showbox| records the contents of the \minref{box}
%\minref{register} numbered \<num\-ber>.
%The number of
%leading dots in the log indicates the number of
%levels of nesting of inner boxes.
%\li |\showlists| records
%the contents of each list that \TeX\ is currently constructing.
%(These lists are nested one within another.)
%See \knuth{pages~88--89} for further information about interpreting
%the output of |\showlists|.
%\endulist
%For |\show| and |\showthe|, \TeX\ also displays the information at your
%^{terminal}.
%For |\showbox| and |\showlists|, \TeX\ displays the information at your
%terminal only
%if ^|\tracingonline| (\xref \tracingonline) is greater than zero;
%if ^|\tracingonline| is zero or less (the default case),
%the information is not displayed.
\begindesc
\bix^^{追踪}
\bix^^{调试}
\bix^^{帮助诊断}
\cts show {\<token>}
\cts showthe {\<argument>}
\cts showbox {\<number>}
\cts showlists {}
\explain
这些命令在 \TeX\ 运行时记录信息到日志文件中：
\ulist
\li |\show| 记录 \<token> 的含义。\minrefs{token}
^^{记号//用 \b\tt\\show\e 显示}
\li |\showthe| 记录用 |\the| \<arg\-u\-ment> 生成的所有记号（见 \xref\the ）。
\li |\showbox| 记录编号为 \<num\-ber> 的\minref{盒子}\minref{寄存器}的内容。
日志文件中的前导点号的个数表示内部盒子的嵌套层级。
\li |\showlists| 记录 \TeX\ 正在构造的各个列表的内容。%
（这些列表将会互相嵌套。）%
见\knuth{第~88--89~页}中对 |\showlists| 的输出的进一步介绍。
\endulist
对于 |\show| 和 |\showthe|，\TeX\ 还在^{终端}中显示这些信息。
对于 |\showbox| 和 |\showlists|，
\TeX\ 仅在 ^|\tracingonline|（\xref \tracingonline ）大于零时才在终端显示信息；
如果 ^|\tracingonline| 小于或等于零（默认情形），这些信息就不在终端显示。

%Whenever \TeX\ encounters a |\show|-type command it
%stops for interaction.  The request for interaction does \emph{not}
%indicate an error, but it does give you an opportunity to ask \TeX\ to
%show you something else.  If you don't want to see anything else, just
%press \asciichar{return}.
在遇到类似 |\show| 的命令时，\TeX\ 暂停以和用户交互。
请求交互\emph{并不}表示有错误发生，但这确实给你机会让 \TeX\ 显示其他东西。
如果你不想看到其他东西，键入\asciichar{return}符即可。

%You can control the amount of output produced by |\showbox| by setting
%|\show!-box!-breadth| and |\show!-box!-depth| (\xref\showboxbreadth).
%^^|\showboxbreadth| ^^|\showboxdepth|
%These parameters respectively have default values of $5$
%and $3$, which is why
%just five items appear for each box described
%in the log output below.  (The `|..etc.|' indicates additional items
%within the boxes that aren't displayed.)
要控制 |\showbox| 生成的输出的数量，
你可以设定 |\show!-box!-breadth| 和 |\show!-box!-depth|（\xref\showboxbreadth ）。
^^|\showboxbreadth| ^^|\showboxdepth|
这两个参数的默认值分别为 $5$ 和 $3$，
因而在下面的日志输出中每个盒子只显示五个项目。%
（`|..etc.|' 表示盒子内的其他未显示的项目。）
%\example
%\show a
%\show \hbox
%\show \medskip
%\show &
%|
%\logproduces
%> the letter a.
%> \hbox=\hbox.
%> \medskip=macro:
%->\vskip \medskipamount .
%> alignment tab character &.
%|
%\nextexample
%\showthe\medskipamount
%\toks27={\hbox{Joe's\quad\ Diner}}
%\showthe\toks27
%|
%\logproduces
%> 6.0pt plus 2.0pt minus 2.0pt.
%> \hbox {Joe's\quad \ Diner}.
%|
%\nextexample
%\setbox 3=\vbox{\hbox{A red dog.}\hrule A black cat.}
%\showbox 3
%|
%\logproduces
%> \box3=
%\vbox(16.23332+0.0)x53.05565
%.\hbox(6.94444+1.94444)x46.41675
%..\tenrm A
%..\glue 3.33333 plus 1.66498 minus 1.11221
%..\tenrm r
%..\tenrm e
%..\tenrm d
%..etc.
%.\rule(0.4+0.0)x*
%.\hbox(6.94444+0.0)x53.05565
%..\tenrm A
%..\glue 3.33333 plus 1.66498 minus 1.11221
%..\tenrm b
%..\tenrm l
%..\tenrm a
%..etc.
%|
%\endexample
%%\vfil\eject
%\example
%\vbox{A \hbox
%   {formula
%       $x \over y\showlists$}}
%|
%\logproduces
%### math mode entered at line 3
%\mathord
%.\fam1 y
%this will be denominator of:
%\fraction, thickness = default
%\\mathord
%\.\fam1 x
%### restricted horizontal mode entered at line 2
%\tenrm f
%\tenrm o
%\tenrm r
%\tenrm m
%\kern-0.27779
%\tenrm u
%\tenrm l
%\tenrm a
%\glue 3.33333 plus 1.66666 minus 1.11111
%spacefactor 1000
%### horizontal mode entered at line 1
%\hbox(0.0+0.0)x20.0
%\tenrm A
%\glue 3.33333 plus 1.66498 minus 1.11221
%spacefactor 999
%### internal vertical mode entered at line 1
%prevdepth ignored
%### vertical mode entered at line 0
%prevdepth ignored
%|
%\endexample
%\enddesc
\example
\show a
\show \hbox
\show \medskip
\show &
|
\logproduces
> the letter a.
> \hbox=\hbox.
> \medskip=macro:
->\vskip \medskipamount .
> alignment tab character &.
|
\nextexample
\showthe\medskipamount
\toks27={\hbox{Joe's\quad\ Diner}}
\showthe\toks27
|
\logproduces
> 6.0pt plus 2.0pt minus 2.0pt.
> \hbox {Joe's\quad \ Diner}.
|
\nextexample
\setbox 3=\vbox{\hbox{A red dog.}\hrule A black cat.}
\showbox 3
|
\logproduces
> \box3=
\vbox(16.23332+0.0)x53.05565
.\hbox(6.94444+1.94444)x46.41675
..\tenrm A
..\glue 3.33333 plus 1.66498 minus 1.11221
..\tenrm r
..\tenrm e
..\tenrm d
..etc.
.\rule(0.4+0.0)x*
.\hbox(6.94444+0.0)x53.05565
..\tenrm A
..\glue 3.33333 plus 1.66498 minus 1.11221
..\tenrm b
..\tenrm l
..\tenrm a
..etc.
|
\endexample
%\vfil\eject
\example
\vbox{A \hbox
   {formula
       $x \over y\showlists$}}
|
\logproduces
### math mode entered at line 3
\mathord
.\fam1 y
this will be denominator of:
\fraction, thickness = default
\\mathord
\.\fam1 x
### restricted horizontal mode entered at line 2
\tenrm f
\tenrm o
\tenrm r
\tenrm m
\kern-0.27779
\tenrm u
\tenrm l
\tenrm a
\glue 3.33333 plus 1.66666 minus 1.11111
spacefactor 1000
### horizontal mode entered at line 1
\hbox(0.0+0.0)x20.0
\tenrm A
\glue 3.33333 plus 1.66498 minus 1.11221
spacefactor 999
### internal vertical mode entered at line 1
prevdepth ignored
### vertical mode entered at line 0
prevdepth ignored
|
\endexample
\enddesc

%\see |\showboxbreadth|, |\showboxdepth| \ctsref\showboxbreadth.
\see |\showboxbreadth|、|\showboxdepth|\ctsref\showboxbreadth 。

%\subsection{Specifying what is traced}
\subsection{指定追踪的内容}

%\begindesc
%\cts tracingonline {\param{number}}
%\explain
%If this parameter is greater than zero,
%\TeX\ will display the results of tracing
%(including ^|\showbox| and ^|\showlists|)
%at your terminal in addition to recording them in the log file.
%\enddesc
\begindesc
\cts tracingonline {\param{number}}
\explain
如果此参数大于零，除了记录到日志文件外，
\TeX\ 还在终端上显示追踪的结果（包括 ^|\showbox| 和 ^|\showlists|）。
\enddesc

%\begindesc
%\cts tracingcommands {\param{number}}
%\explain
%If this parameter is $1$ or greater,
%\TeX\ will record in the log file most commands that it executes.
%If ^|\tracingonline| is greater than zero, this information will also appear
%at your terminal.
%Typesetting the first character of a word counts as a command,
%but (for the purposes of the trace only)
%the actions of typesetting the subsequent characters
%and any punctuation following them
%do not count as commands.
%If |\tracingcommands| is $2$ or greater,
%\TeX\ will also record commands that are expanded
%rather than executed, e.g., conditional tests and their outcomes.
\begindesc
\cts tracingcommands {\param{number}}
\explain
如果此参数大于或等于 $1$，\TeX\ 将在日志文件中记录它执行的大多数命令。
如果 ^|\tracingonline| 大于或等于零，这些信息还将出现在终端上。
排版一个单词的首个字符算作一个命令，
但（仅对追踪的目的而言）排版之后的字符和标点却不算作命令。
如果 |\tracingcommands| 大于或等于 $2$，
\TeX\ 还将记录展开但不执行的命令，比如条件测试及它们的输出。
%\example
%\tracingcommands = 1 If $x+y>0$ we quit.\par
%On the other hand, \tracingcommands = 0
%|
%\logproduces
%{vertical mode: the letter I}
%{horizontal mode: the letter I}
%{blank space  }
%{math shift character $}
%{math mode: the letter x}
%{the character +}
%{the letter y}
%{the character >}
%{the character 0}
%{math shift character $}
%{horizontal mode: blank space  }
%{the letter w}
%{blank space  }
%{the letter q}
%{blank space  }
%{\par}
%{vertical mode: the letter O}
%{horizontal mode: the letter O}
%{blank space  }
%{the letter t}
%{blank space  }
%{the letter o}
%{blank space  }
%{the letter h}
%{blank space  }
%{\tracingcommands}
%|
%\endexample
%\enddesc
\example
\tracingcommands = 1 If $x+y>0$ we quit.\par
On the other hand, \tracingcommands = 0
|
\logproduces
{vertical mode: the letter I}
{horizontal mode: the letter I}
{blank space  }
{math shift character $}
{math mode: the letter x}
{the character +}
{the letter y}
{the character >}
{the character 0}
{math shift character $}
{horizontal mode: blank space  }
{the letter w}
{blank space  }
{the letter q}
{blank space  }
{\par}
{vertical mode: the letter O}
{horizontal mode: the letter O}
{blank space  }
{the letter t}
{blank space  }
{the letter o}
{blank space  }
{the letter h}
{blank space  }
{\tracingcommands}
|
\endexample
\enddesc

%\begindesc
%\cts tracinglostchars {\param{number}}
%\explain
%If this parameter is greater than zero,
%\TeX\ will record an indication in the log file of each time
%that it drops an output character because that character does not exist
%in the current font.
%If ^|\tracingonline| is greater than zero, this information will also appear
%at your terminal.
%\PlainTeX\ defaults it to $1$ (unlike the others).
%\example
%\tracinglostchars = 1
%A {\nullfont few} characters.
%|
%\logproduces
%Missing character: There is no f in font nullfont!!
%Missing character: There is no e in font nullfont!!
%Missing character: There is no w in font nullfont!!
%|
%\endexample
%\enddesc
\begindesc
\cts tracinglostchars {\param{number}}
\explain
如果此参数大于零，每次因某字符不在当前字体中而丢弃它时，
\TeX\ 将在日志文件中记录一个声明。
如果 ^|\tracingonline| 大于零，此信息还将显示在终端上。
\PlainTeX\ 设定该参数的默认值为 $1$（与其他参数不一样）。
\example
\tracinglostchars = 1
A {\nullfont few} characters.
|
\logproduces
Missing character: There is no f in font nullfont!!
Missing character: There is no e in font nullfont!!
Missing character: There is no w in font nullfont!!
|
\endexample
\enddesc

%\begindesc
%\cts tracingmacros {\param{number}}
%\explain
%If this parameter is $1$ or greater,
%\TeX\ will record in the log file the expansion and arguments
%of every macro that it executes.
%^^{macros//tracing}
%If |\tracingmacros| is $2$ or greater,
%\TeX\ will record, in addition,
%every expansion of a \minref{token} list such as
%|\output| or |\everycr|.
%If ^|\tracingonline| is greater than zero, this information will also appear
%at your terminal.
%\example
%\def\a{first \b, then \c}
%\def\b{b} \def\c{c}
%\tracingmacros = 2
%Call \a once.
%|
%\logproduces
%\a ->first \b , then \c
%
%\b ->b
%
%\c ->c
%|
%\endexample
%\enddesc
\begindesc
\cts tracingmacros {\param{number}}
\explain
如果此参数大于或等于 $1$，
\TeX\ 将在日志文件中记录它执行的每个宏的展开和参量。
^^{宏//追踪宏}
如果 |\tracingmacros| 大于或等于 $2$，
\TeX\ 还将记录每个\minref{记号}列的展开，比如 |\output| 或 |\everycr|。
如果 ^|\tracingonline| 大于零，这些信息还将显示在终端上。
\example
\def\a{first \b, then \c}
\def\b{b} \def\c{c}
\tracingmacros = 2
Call \a once.
|
\logproduces
\a ->first \b , then \c

\b ->b

\c ->c
|
\endexample
\enddesc

%\begindesc
%\cts tracingoutput {\param{number}}
%\explain
%If this parameter is greater than zero,
%\TeX\ will record in the log file the contents of every box that
%it sends to the \dvifile.
%^^{\dvifile//boxes recorded in log file}
%If ^|\tracingonline| is greater than zero, this information will also appear
%at your terminal.
%The number of leading dots in each line of the trace output indicates
%the nesting level of the box at that line.
%You can control the amount of tracing by setting
%^|\showboxbreadth| and ^|\showboxdepth| (\xref\showboxbreadth).
\begindesc
\cts tracingoutput {\param{number}}
\explain
如果此参数大于零，
\TeX\ 将在日志文件中记录它送出到 \dvifile 的每个盒子的内容。
^^{\dvifile//在日志文件中记录盒子内容}
如果 ^|\tracingonline| 大于零，这些信息还将显示在终端上。
追踪输出中每行开头的点号个数表示该行盒子的嵌套层级。
你可以用 ^|\showboxbreadth| 和 ^|\showboxdepth|（\xref\showboxbreadth ）%
控制追踪的数量。

%Setting |\tracingoutput| to $1$ can be particularly helpful when you're trying
%to determine why you've gotten ^{extra space} on a page.
若你想确定页面为何出现^{多余空格}，
设定 |\tracingoutput| 为 $1$ 就特别有用。

%\example
%% This is the entire file.
%\tracingoutput = 1 \nopagenumbers
%One-line page. \bye
%|
%\logproduces
%Completed box being shipped out [1]
%\vbox(667.20255+0.0)x469.75499
%.\vbox(0.0+0.0)x469.75499, glue set 13.99998fil
%..\glue -22.5
%..\hbox(8.5+0.0)x469.75499, glue set 469.75499fil
%...\vbox(8.5+0.0)x0.0
%...\glue 0.0 plus 1.0fil
%..\glue 0.0 plus 1.0fil minus 1.0fil
%.\vbox(643.20255+0.0)x469.75499, glue set 631.2581fill
%..\glue(\topskip) 3.05556
%..\hbox(6.94444+1.94444)x469.75499, glue set 386.9771fil
%...\hbox(0.0+0.0)x20.0
%...\tenrm O
%...\tenrm n
%...\tenrm e
%...\tenrm -
%...etc.
%..\glue 0.0 plus 1.0fil
%..\glue 0.0 plus 1.0fill
%.\glue(\baselineskip) 24.0
%.\hbox(0.0+0.0)x469.75499, glue set 469.75499fil
%..\glue 0.0 plus 1.0fil
%|
%\endexample
%\enddesc
\example
% This is the entire file.
\tracingoutput = 1 \nopagenumbers
One-line page. \bye
|
\logproduces
Completed box being shipped out [1]
\vbox(667.20255+0.0)x469.75499
.\vbox(0.0+0.0)x469.75499, glue set 13.99998fil
..\glue -22.5
..\hbox(8.5+0.0)x469.75499, glue set 469.75499fil
...\vbox(8.5+0.0)x0.0
...\glue 0.0 plus 1.0fil
..\glue 0.0 plus 1.0fil minus 1.0fil
.\vbox(643.20255+0.0)x469.75499, glue set 631.2581fill
..\glue(\topskip) 3.05556
..\hbox(6.94444+1.94444)x469.75499, glue set 386.9771fil
...\hbox(0.0+0.0)x20.0
...\tenrm O
...\tenrm n
...\tenrm e
...\tenrm -
...etc.
..\glue 0.0 plus 1.0fil
..\glue 0.0 plus 1.0fill
.\glue(\baselineskip) 24.0
.\hbox(0.0+0.0)x469.75499, glue set 469.75499fil
..\glue 0.0 plus 1.0fil
|
\endexample
\enddesc

%\begindesc
%\cts tracingpages {\param{number}}
%\explain
%If this parameter is greater than zero,
%\TeX\ will record in the log file its calculations of the cost of
%various page breaks that it tries.
%^^{page breaks//tracing}
%If |\tracing!-online| ^^|\tracingonline|
%is greater than zero, this information will also appear
%at your terminal.
%\TeX\ produces a line of this output
%whenever it first places a box or \minref{insertion}
%on the current page list, and also whenever it processes a potential
%break point for the page.
%Examining this output can be helpful when you're trying to determine
%the cause of a bad page break.
%See \knuth{pages~112--114} for an illustration and explanation of
%this output.
\begindesc
\cts tracingpages {\param{number}}
\explain
如果此参数大于零，
\TeX\ 将在日志文件中记录它尝试各种分页所计算的代价。
^^{分页//追踪分页}
如果 |\tracing!-online| ^^|\tracingonline| 大于零，
这些信息还将显示在终端上。
在放置一个盒子或\minref{插入项}到当前的页面列表，
或者在处理页面的某个可能分页点时，\TeX\ 都在日志输出中写上一行。
检查此输出将有助于你确定糟糕分页的起因。
见\knuth{第~112--114~页}中此类输出的示例和解释。

%Some production forms of \TeX\ ignore the value of |\tracingpages|
%so that they can run faster.
%If you need to use this parameter, be sure to use a form that
%responds to it.
%\enddesc
某些 \TeX\ 实现形式忽略 |\tracingpages| 的取值以更快地运行。
如果你需要此参数，确保你用的 \TeX\ 形式能用此参数。
\enddesc

%\begindesc
%\cts tracingparagraphs {\param{number}}
%\explain
%If this parameter is greater than zero,
%\TeX\ will record in the log file its calculations of the cost of
%various line breaks that it tries.
%^^{line breaking//tracing}
%If ^|\tracingonline| is greater than zero, this information will also appear
%at your terminal.
%\TeX\  produces this output when it reaches the end of each paragraph.
%See \knuth{pages~98--99} for an illustration and explanation of
%this output.
\begindesc
\cts tracingparagraphs {\param{number}}
\explain
如果此参数大于零，
\TeX\ 将在日志文件中记录它尝试各种断行所计算的代价。
^^{断行//追踪断行}
如果 |\tracingonline| ^^|\tracingonline| 大于零，
这些信息还将显示在终端上。
\TeX\ 在段落的结尾处生成这些输出。
见\knuth{第~98--99~页}中此类输出的示例和解释。

%Some production forms of \TeX\ ignore the value of |\tracing!-para!-graphs|
%so that they can run faster.
%If you need to use this parameter, be sure to use a form that
%responds to it.
%\enddesc
某些 \TeX\ 实现形式忽略 |\tracing!-para!-graphs| 的取值以更快地运行。
如果你需要此参数，确保你用的 \TeX\ 形式能用此参数。
\enddesc

%\begindesc
%\cts tracingrestores {\param{number}}
%\explain
%If this parameter is greater than zero,
%\TeX\ will record in the log file
%the values that it restores when it encounters the end of a \minref{group}.
%If ^|\tracingonline| is greater than zero, this information will also appear
%at your terminal.
\begindesc
\cts tracingrestores {\param{number}}
\explain
如果此参数大于零，
\TeX\ 将在日志文件中记录那些在\minref{编组}结尾处被还原的值。
如果 |\tracingonline| ^^|\tracingonline| 大于零，
这些信息还将显示在终端上。

%Some production forms of \TeX\ ignore the value of |\tracing!-restores|
%so that they can run faster.
%If you need to use this parameter, be sure to use a form that
%responds to it.
%\enddesc
某些 \TeX\ 实现形式忽略 |\tracing!-restores| 的取值以更快地运行。
如果你需要此参数，确保你用的 \TeX\ 形式能用此参数。
\enddesc

%\begindesc
%\cts tracingstats {\param{number}}
%\explain
%If this parameter is $1$ or greater, \TeX\ will
%include a report on the resources that it used to run your job
%(see \knuth{page~300} for a list and explanation of these resources).
%Moreover, if |\tracingstats| is $2$ or greater,
%\TeX\ will report on its memory usage whenever it does a
%^|\shipout| (\xref \shipout) for a page.
%The report appears at the end of the log file.
%^^{log file//tracing statistics in}
%If ^|\tracingonline| is greater than zero, the information will also appear
%at your terminal.
%If you're having trouble with \TeX\ exceeding one of its
%capacities, the information provided by |\tracingstats| may help you
%pinpoint the cause of the difficulty.
\begindesc
\cts tracingstats {\param{number}}
\explain
如果此参数大于或等于 $1$，
\TeX\ 将报告它运行任务时所用的各种资源%
（见\knuth{第~300~页}中这些资源的列表和解释）。
另外，如果 |\tracingstats| 大于或等于 $2$，
\TeX\ 将在 ^|\shipout|（\xref \shipout ）页面时报告所用的内存占用。
这些报告写在日志文件的末尾。
^^{日志文件//在其中追踪统计信息}
如果 |\tracingonline| ^^|\tracingonline| 大于零，
这些信息还将显示在终端上。
如果出现 \TeX\ 超出其中某个容量的问题，
|\tracingstats| 提供的这些信息将帮助你准确定位问题的起因。

%Some production forms of \TeX\ ignore the value of |\tracingstats|
%so that they can run faster.
%If you need to use this parameter, be sure to use a form that
%responds to it.
某些 \TeX\ 实现形式忽略 |\tracingstats| 的取值以更快地运行。
如果你需要此参数，确保你用的 \TeX\ 形式能用此参数。

%The following example shows a sample of
%the tracing output you'd get on one implementation
%of \TeX.  It may be different on other implementations.
%{\codefuzz = 1in
%\example
%\tracingstats=1
%|
%\logproduces
%Here is how much of TeX's memory you used:
% 4 strings out of 5540
% 60 string characters out of 72328
% 5956 words of memory out of 262141
% 921 multiletter control sequences out of 9500
% 14794 words of font info for 50 fonts, out of 72000 for 255
% 14 hyphenation exceptions out of 607
% 7i,4n,1p,68b,22s stack positions out of 300i,40n,60p,3000b,4000s
%|
%\endexample
%}% end scope of codefuzz
%\enddesc
下面的例子显示了在某个 \TeX\ 实现中实际的追踪输出。
在其他 \TeX\ 实现中也许会有所不同。
{\codefuzz = 1in
\example
\tracingstats=1
|
\logproduces
Here is how much of TeX's memory you used:
 4 strings out of 5540
 60 string characters out of 72328
 5956 words of memory out of 262141
 921 multiletter control sequences out of 9500
 14794 words of font info for 50 fonts, out of 72000 for 255
 14 hyphenation exceptions out of 607
 7i,4n,1p,68b,22s stack positions out of 300i,40n,60p,3000b,4000s
|
\endexample
}% end scope of codefuzz
\enddesc

%\begindesc
%\cts tracingall {}
%\explain
%This command tells \TeX\ to
%turn on every available form of tracing.
%It also sets ^|\tracingonline| to $1$ so that the trace output will appear
%at your terminal.
%\enddesc
\begindesc
\cts tracingall {}
\explain
此命令让 \TeX\ 打开所有可用的追踪形式，
并设定 ^|\tracingonline| 为 $1$ 以让追踪输出显示在终端上。
\enddesc

%\begindesc
%\cts showboxbreadth {\param{number}}
%\explain
%This parameter specifies the maximum number of list items
%that \TeX\ displays for one level of one box when it is producing
%the output for ^|\showbox| or ^|\tracingoutput|.
%\PlainTeX\ sets |\showboxbreadth| to $5$.
%\enddesc
\begindesc
\cts showboxbreadth {\param{number}}
\explain
此参数指定 \TeX\ 为 ^|\showbox| 或 ^|\tracingoutput| 生成输出时，%
对各级盒子的列表项显示的最大数目。
\PlainTeX\ 设定 |\showboxbreadth| 等于 $5$。
\enddesc

%\begindesc
%\cts showboxdepth {\param{number}}
%\explain
%This parameter specifies the
%level of the deepest list that \TeX\ displays when
%it is producing the output for ^|\showbox| or ^|\showlists|.
%\PlainTeX\ sets |\showboxdepth| is $3$.
%\eix^^{tracing}
%\eix^^{debugging}
%\eix^^{diagnostic aids}
%\enddesc
\begindesc
\cts showboxdepth {\param{number}}
\explain
此参数指定 \TeX\ 为 ^|\showbox| 或 ^|\tracingoutput| 生成输出时，%
所显示的列表的最深层级。
\PlainTeX\ 设定 |\showboxdepth| 等于 $3$。
\eix^^{追踪}
\eix^^{调试}
\eix^^{帮助诊断}
\enddesc

%==========================================================================
%\subsection {Sending messages}
\subsection {传送信息}

%\begindesc
%\bix^^{messages, sending}
%\bix^^{error messages}
%\cts message {\rqbraces{\<token list>}}
%\cts errmessage {\rqbraces{\<token list>}}
%\explain
%These commands display the message given by \<token list> on your
%terminal and also enter it into the log.  Any \minref{macro}s in the
%message are expanded, but no commands are executed.  This is the same rule
%that \TeX\ uses for |\edef| (\xref \edef).
\begindesc
\bix^^{信息发送}
\bix^^{错误信息}
\cts message {\rqbraces{\<token list>}}
\cts errmessage {\rqbraces{\<token list>}}
\explain
这两个命令在终端上显示由 \<token list> 给出的信息，并将它们记录到日志中。
信息中的任何\minref{宏}都将被展开 ，但是命令不会被执行。
这与 \TeX\ 用于 |\edef|（\xref\edef ）的规则一样。

%For |\errmessage|, \TeX\ pauses
%in the same way that it does for one of its own error messages
%and displays the |\errhelp| tokens if you ask for help.
对于 |\errmessage|，\TeX\ 如同显示自己的错误信息一样暂停运行，
并在请求帮助时显示 |\errhelp| 记号列。

%You can generate multiline messages by using the ^|\newlinechar|
%character (\xref \newlinechar).
%\example
%\message{Starting a new section.}
%|
%\endexample
%\enddesc
要生成多行的信息，你可以用 ^|\newlinechar| 字符（\xref \newlinechar ）。
\example
\message{Starting a new section.}
|
\endexample
\enddesc

%\begindesc
%\cts wlog {\rqbraces{\<token list>}}
%\explain
%This command writes \<token list> on the log file.
%^^{log file//written by \b\tt\\wlog\e}
%\minrefs{log file}
%\TeX\ expands \<token list> according to the same rules that it uses
%for |\edef| (\xref\edef).
%\example
%\wlog{Take two aspirins and call me in the morning.}
%|
%\logproduces
%Take two aspirins and call me in the morning.
%|
%\endexample
%\enddesc
\begindesc
\cts wlog {\rqbraces{\<token list>}}
\explain
此命令在日志文件写入 \<token list>。
^^{日志文件//用 \b\tt\\wlog\e 写入}
\minrefs{log file}
\TeX\ 按照与 |\edef|（\xref\edef ）一样的规则展开 \<token list>。
\example
\wlog{Take two aspirins and call me in the morning.}
|
\logproduces
Take two aspirins and call me in the morning.
|
\endexample
\enddesc

%\begindesc
%\cts errhelp {\param{token list}}
%\explain
%This parameter contains the token list that \TeX\ displays
%when you ask for help in response to an |\errmessage| command.
%We recommend that when
%you're generating an error message with |\errmessage|, you
%set |\errhelp| to a string that describes the nature of the
%error and use |\newhelp| to produce that string.
%You can use the ^|\newlinechar| character to produce multiline messages.
%\enddesc
\begindesc
\cts errhelp {\param{token list}}
\explain
此参数包含 \TeX\ 用户在 |\errmessage| 命令中请求帮助时显示的记号列表。
我们建议在用 |\errmessage| 生成错误信息时，
将|\errhelp| 设定为描述错误形式的字符串，并用 |\newhelp| 生成该字符串。
你可以用 ^|\newlinechar| 字符生成多行的信息。
\enddesc

%\begindesc
%\ctspecial newhelp \ctsxrdef{@newhelp} {\<control sequence>
%   \rqbraces{\<help text>}}
%\explain
%This command assigns the ^{help message} given by \<help text> to
%\<control sequence>.  It provides an efficient way of defining
%the ^{help text} that further explains an error message.
%Before issuing the error message with the |\errmessage| command,
%you should assign \<control sequence> to ^|\errhelp|.  The help text
%will then appear if the user types `|H|'
%or `|h|' in response to the error message.
%\example
%\newhelp\pain{Your input includes a token that I find^^J
%   to be offensive. Don't bother me again with this^^J
%   document until you've removed it.}
%\errhelp = \pain \newlinechar = `\^^J
%% ^^J will start a new line
%\errmessage{I do not appreciate receiving this token}
%|
%\logproduces
%!! I do not appreciate receiving this token.
%l.8 ...t appreciate receiving this token.}
%
%? H
%\Your input includes a token that I find
% to be offensive. Don't bother me again with this
% document until you've removed it.
%|
%\endexample
%\enddesc
\begindesc
\ctspecial newhelp \ctsxrdef{@newhelp} {\<control sequence>
   \rqbraces{\<help text>}}
\explain
此命令将 \<help text> 给出的^{错误信息}赋予 \<control sequence>。
它提供一种定义^{帮助文本}的快捷方式，帮助文本进一步解释了错误信息。
在用 |\errmessage| 命令报出错误之前，
你应当将 \<control sequence> 赋予 ^|\errhelp|。
这样在显示错误信息时，如果用户键入 `|H|' 或 `|h|'，
\TeX\ 将显示出帮助文本。
\example
\newhelp\pain{Your input includes a token that I find^^J
   to be offensive. Don't bother me again with this^^J
   document until you've removed it.}
\errhelp = \pain \newlinechar = `\^^J
% ^^J will start a new line
\errmessage{I do not appreciate receiving this token}
|
\logproduces
!! I do not appreciate receiving this token.
l.8 ...t appreciate receiving this token.}

? H
\Your input includes a token that I find
 to be offensive. Don't bother me again with this
 document until you've removed it.
|
\endexample
\enddesc

%\begindesc
%\cts errorcontextlines {\param{number}}
%\explain
%This parameter determines the number of pairs of context lines,
%not counting the top and bottom pairs, that \TeX\ prints when it
%encounters an error.  By setting it to $0$ you can get rid of long
%error messages.
%You can still force out the full context by typing something like:
%\csdisplay
%I\errorcontextlines=100\oops
%|
%in response to an error,
%since the undefined control sequence |\oops| will cause another error.
%\PlainTeX\ sets |\error!-context!-lines| to $5$.
%\enddesc
\begindesc
\cts errorcontextlines {\param{number}}
\explain
此命令确定 \TeX\ 遇到错误时打印的成对信息行的数目，不包括最上面和最下面这两行。
将它设为 $0$ 就可以去掉冗长的错误信息。
你仍然可以强制显示完整的信息，只要在回应错误时这样输入：
\csdisplay
I\errorcontextlines=100\oops
|
这是因为未定义的控制序列将引起另一个错误。
\PlainTeX\ 设定 |\error!-context!-lines| 等于 $5$。
\enddesc

%\see |\write| (\xref \write), |\escapechar| (\xref \escapechar).
%\eix^^{messages, sending}
%\eix^^{error messages}
\see |\write|（\xref \write ）、|\escapechar|（\xref \escapechar ）。
\eix^^{信息发送}
\eix^^{错误信息}

%==========================================================================
%\section {Initializing \TeX}
\section {初始化 \TeX}

%\begindesc
%\cts dump {}
%\explain
%This command, which must not appear inside a group, dumps the
%contents of \TeX's memory
%to a ^{format file} (\xref{format file}).
%By using ^|virtex|, a special ``virgin'' form of \TeX,
%you can then reload the format file at high speed and
%continue in the same state that \TeX\ was in at the time of the dump.
%|\dump| also ends the run.  Since |\dump| can only be used
%in ^|initex|, not in production forms of \TeX, it is only useful
%to people who are installing \TeX.
%\enddesc
\begindesc
\cts dump {}
\explain
这个命令不能在编组中使用，它可以把 \TeX\ 记录的内容导出成一个^{格式文件}（\xref{格式文件}）。
如果使用的是 ^|virtex| 这种特殊的 \TeX\ 形式，
\footnote{译注：|virtex| 和 |initex| 在现代的 \TeX\ 系统中不再被使用。
在远古时代，人们必须使用 |initex| 命令来导出格式文件，用 |virtex| 命令载入格式文件，
而 |tex| 程序不能导出或载入格式文件。而在现代的发行版中，|tex| 命令可以处理这一切。}
你能够以很快的速度载入这个格式文件，
载入后的 \TeX\ 状态和你当初导出格式文件时的状态并无二致。
|\dump| 命令会同时结束本次运行。
由于 |\dump| 只能在 ^|initex| 中运行，
而不是生产版本的 \TeX ，所以它仅仅在你安装 \TeX\ 时会用到。
\enddesc

%\begindesc
%\cts everyjob {\param{token list}}
%\explain
%This parameter contains a \minref{token} list that \TeX\ expands at the
%start of every job.  Because an assignment to |\everyjob| cannot affect
%the current run (by the time you've done the assignment it's already too
%late), it is only useful to people who are preparing format files.
%\enddesc
\begindesc
\cts everyjob {\param{token list}}
\explain
此参数包含一个\minref{记号}列，\TeX\ 在开始每个任务时展开它们。
由于对 |\everyjob| 的赋值无法影响当前任务（在你赋值时已经太迟了），
它仅对制作格式文件的人有用。
\enddesc

\enddescriptions

\ifoldeplain\else\ifcompletebook\else
\vskip4em{\sectionfonts\leftline{本章索引}}
\readindexfile{i}
\fi\fi

\endchapter \byebye
